---
layout: post
title: 重写平方串，润和琳墩串
subtitle: /dk
tags: 字符串
---

做xix open cup遇到了两个平方串题。再写一写，可能这次会比较深刻吧。

-----

square

定义一个串是平方串，当且仅当它的前一半和后一半相同。它的前一半称作它的平方根或简称根。

类似地可以定义立方串，四次方串......但是它们意义不是很大。

-----

boi2004 repeats

求一个串的最长重串。如果有多个，求连续重复次数最大的。

给出一个求所有重串的做法。从大到小枚举根的长度$$l$$，然后按$$l$$大小分块，那么根一定是一个块前缀和一个块后缀。用sa求出相邻两块的lcp和lcs，然后就得到一个区间的重串，这里还是画一下吧 : 

![img](/img/2022-05-16-lyndon-word-runs-and-squares/lcp-lcs.png)

然后为了求出连续重复次数，我们可以直接在这个上面尝试继续扩展。

-----

noi2016 优秀的拆分

我们枚举一个拆分，也就是枚举两个相邻的重串这样的，那么问题是求出每个位置作为开头和结尾的重串数量。套用上个题的做法即可。

-----

zjoi2020 字符串

套用上个题的做法，发现好像失败了。不过没关系的!

-----

run

注意到上面的方法说明相同长度的平方串形成若干个区间。定义一个run(译名好像是 顶天立地串/kx)是一个周期$$p$$和极长的以这一周期作为最小周期的子串$$[l,r]$$组成的二元组，显然它表示了一堆平方串。

**The runs theorem** 一个串中run的个数不超过$$n$$。

定义一个run的根是它里面任意一个长$$p$$的子串。如果我们找到了一个run的一个根，那么可以向两边

定义一个run的指数是$$\frac{r-l+1}{p}$$。

**The runs theorem** 一个串中run的指数和不超过$$3n-3$$。

如果我们求出了所有run，那么很容易枚举所有平方串。

-----

lyndon word

接下来我们描述lyndon word的理论。

一个串是lyndon串，当且仅当它比所有非平凡后缀都小，或者说它是所有循环同构中严格最小的。按照定义，aaaaa不是lyndon串，但是a是。

接下来我们考虑lyndon串的结构。

**显然** 如果lyndon串$$w=uv$$，那么$$u<v$$。

**定理1** 一个串$$w$$是lyndon串，当且仅当它是单字符，或者它可以分解成两个lyndon串$$w=uv$$，其中$$u<v$$。

**证明** $$\Leftarrow$$ : 考虑所有后缀。

$$\Rightarrow$$ : 找到$$w$$的最小真后缀，那么根据定义它是lyndon串，直接令它为$$v$$，剩下的部分为$$u$$。接下来证明$$u$$是lyndon串，考虑$$w$$比$$w$$的任意后缀小，而$$u$$比$$w$$小，所以$$u$$比$$w$$的任意后缀小，而$$v$$是$$w$$的最小真后缀，在$$w$$的一个后缀中把$$v$$替换成空对大小不会有影响，而把$$v$$替换成空就变成了$$u$$的后缀，所以$$u$$比$$u$$的任意后缀小。

定义一个lyndon串的标准分解是最小真后缀和剩下的部分。分解形成一棵树，可以猜到这是它的sa的笛卡尔树。

-----

lyndon root, lyndon array

显然由于run的周期是最小周期，我们知道每个run必有一个lyndon串作为它的根，称为lyndon根。接下来我们指出lyndon根的重要性质。

**引理1** 设$$w=u^ku^\prime a$$，其中$$u$$是lyndon串，$$a$$是一个字符，$$u^\prime$$是$$u$$的极长前缀(可能为空)，也就是向后加入$$a$$的话则不再是$$u$$的前缀。设$$u$$中$$u^\prime$$之后的字符是$$c=u_{\vert u^\prime+1\vert}$$。则

 - 如果$$a>c$$，那么$$w$$是一个lyndon串。

 - 如果$$a<c$$，那么以$$w$$为前缀的串的最长lyndon前缀必然是$$u$$。

**证明** 很直接。

 - 如果$$a>c$$，那么显然。

 - 如果$$a<c$$，那么显然。

反复阅读你就懂了（

所以我们知道，如果遇到了case 2，那么这个run的lyndon根必然是原串一个后缀的最长lyndon前缀，这个数组称为lyndon数组，而我们马上会描述求这个东西。为了稳定遇到case 2，我们可以把字典序反过来做一遍，这样正序和反序下的lyndon array必然有一个给出了lyndon根(，实际上，容易发现另一个总是给出长$$1$$的平凡lyndon串)。

为了求lyndon数组，我们可以考虑从右往左扫，维护当前后缀的一个极小lyndon串分解，根据定理1我们知道极小当且仅当这些lyndon串是从大到小排列的。使用反证，容易证明lyndon分解唯一。接下来我们会加入一个字符，然后我们不断尝试把这个字符和右边合并，还是根据定理1我们知道合并只需要比较两个lyndon子串的字典序，比较后缀的字典序即可。最多会进行$$n-1$$次合并，所以我们可以使用二分hash做到$$O(n\log n)$$，或者sais 四毛子rmq做到$$O(n)$$。

-----

duval's algorithm

根据引理1，我们可以简单地线性求出每个前缀的lyndon分解。直接从左往右扫，维护$$u,k,u^\prime$$即可。