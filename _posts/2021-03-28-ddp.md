---
layout: post
title: ddp
subtitle: 得得得得得得得得得得得得得得得得得得得得得得得得得得得得得得p（bushi
tags: 数据结构 ddp
---

ddp通过把转移写成矩阵的形式来证明结合律并简单地合并转移。一般情况下，由于转移具有结合律并可以快速合并，我们使用线段树等数据结构来维护转移，从而解决带修改或range query的简单dp问题。

### 广义矩阵乘法，两个基本定理

首先我们要定义广义矩阵乘法。设$$\oplus,\otimes$$是两种运算，那么定义两个矩阵$$A,B$$的广义矩阵积$$C$$为 : 

$$
c_{i,j}=\bigoplus_{k=1}^{l}a_{i,k}\otimes b_{k,j}
$$

当然这里$$A$$是$$n\times l$$的矩阵，$$B$$是$$l\times m$$的矩阵，$$C$$就是$$n\times m$$的矩阵。

**定理1** 如果$$\otimes,\oplus$$都有结合律，并且$$\otimes$$对$$\oplus$$有分配律，那么这个广义矩乘也满足结合律。自证不难，爆力展开即可。

常见的一些有$$\oplus=\min/\max,\otimes=+$$，结合律显然，分配律就是$$\min(a,b)+c=\min(a+c,b+c)$$。

还有$$\oplus=\mathrm{xor},\otimes=\mathrm{and}$$，暴力计算可以证明对于$$01$$的情况是有分配律的，因此这个东西对于任意位也满足分配律。注意$$\mathrm{or}$$和$$\mathrm{xnor}$$并没有这么好的性质。

**定理2** 还是上面的条件，那么这个广义矩乘满足矩阵加法对矩阵乘法的分配律，或者说$$(A\times B)\oplus(A\times C)=A\times(B\oplus C)$$。当然这里加法也是$$\otimes$$意义下的。自证也不难。

这个可以把一些"矩阵乘完什么东西之后加起来"变成"矩阵加起来再乘什么东西"，合并转移矩阵的时候可能用到。

### 序列上的ddp

CF618E Robot Arm

显然可以把每一节表示成一个平移，那么我们只要写出矩阵然后复合就好了。

注意到每次旋转会同时转后面所有的，这个可以通过旋转的差分来解决(旋转同时有交换律)，更好的办法是从后往前应用线性变换，这样前面的旋转就可以作用于后面了。

-----

单点修改区间最大子段和

题意 : 单点修改，区间最大子段和。

设$$dp_i$$为右端点为$$i$$的最大子段和，$$ans_i$$为只考虑前$$i$$个的答案，可以写出如下的转移 : 

$$
\begin{aligned}
dp_i&:=max(dp_{i-1}+a_i,a_i)\\
ans_i&:=max(ans_{i-1},dp_i)
\end{aligned}
$$

写成矩阵乘法的形式，就是

$$
\begin{bmatrix}
a_i&-\infty&a_i\\
a_i&0&a_i\\
-\infty&-\infty&0
\end{bmatrix}
\begin{bmatrix}
dp_{i-1}\\
ans_{i-1}\\
0
\end{bmatrix}
=
\begin{bmatrix}
dp_i\\
ans_i\\
0
\end{bmatrix}
$$

-----

不知道哪里来的题的加强版

题意 : 有一堆人要按某种顺序给你投票。每个人有一个理想评分$$a_i$$(当然可以是负数)，如果他投票的时候，你得到的分数$$<a_i$$，他会给你点+1；如果$$>a_i$$则点-1，如果$$=a_i$$则什么也不做。一开始每个人的理想评分都是$$0$$，你需要支持修改一个人的理想评分，或者查询 如果你可以随便安排顺序，最多可以得到多少分。

贪心地，容易发现按理想评分从小到大排是最优的，然后容易发现得分变化是一开始一串连续的-1，接下来全是+1或不变。考虑我们分开讨论，对于第一段可以二分出 理想评分 和 一直-1的得分 的交点，第二段可以写成ddp的形式。如果我们设$$f_i$$表示前$$i$$个人打完之后的得分，那么有

$$
f_i:=\min(f_{i-1}+1,a_i)
$$

所以可以写出转移矩阵

$$
\begin{bmatrix}
1&a_i\\
\infty&0\\
\end{bmatrix}
\begin{bmatrix}
f_{i-1}\\
0
\end{bmatrix}
=
\begin{bmatrix}
f_i\\
0
\end{bmatrix}
$$

开一棵值域线段树维护即可。

-----

CF750E New Year and Old Subsequence

考虑这是一个子序列自动机上乱蹦的模型，所以先画个自动机出来。

![am](/img/2021-03-28-ddp/am.png)

考虑设$$f_{i,j}$$表示考虑了前$$i$$个字符，走到自动机上的结点$$j$$至少需要删多少字符。

分别考虑四种字符，那么可以写出超大的转移矩阵(认为$$0\times\infty=0$$) : 

$$
\begin{bmatrix}
0 & \infty[a_i=6] & \infty[a_i\neq 6] & \infty & \infty & \infty\\
\infty & [a_i=6] & \infty[a_i\neq 7] & \infty & \infty & \infty\\
\infty & \infty & [a_i\in\{6,7\}] & \infty[a_i\neq 1] & \infty & \infty\\
\infty & \infty & \infty & [a_i=1] & \infty[a_i\neq 0] & \infty\\
\infty & \infty & \infty & \infty & [a_i=0] & \infty[a_i\neq 2]\\
\infty & \infty & \infty & \infty & \infty & [a_i=2]\\
\end{bmatrix}
\begin{bmatrix}
f_{i-1,5}\\
f_{i-1,4}\\
f_{i-1,3}\\
f_{i-1,2}\\
f_{i-1,1}\\
f_{i-1,0}
\end{bmatrix}
=
\begin{bmatrix}
f_{i,5}\\
f_{i,4}\\
f_{i,3}\\
f_{i,2}\\
f_{i,1}\\
f_{i,0}
\end{bmatrix}
$$

注意这里因为是静态问题，使用矩阵乘向量可以大大减小常数。

### 树上的ddp

洛谷P4719 【模板】"动态 DP"&动态树分治

树上的ddp是什么呢?它一般用来解决一些从儿子们转移来的dp，当然它能解决的不止这些。

众所周知HLD之后树就是重链+轻边，重链上我们可以用序列上的ddp解决，而轻儿子的贡献就需要考虑一下。

树上的最大权独立集大家都会求。

考虑链上的问题，或者说序列上的问题，设$$f_{u,0/1}$$表示$$u$$子树内$$u$$选/不选的答案。假设现在$$u$$只有一个重儿子$$v$$，那就有 : 

$$
\begin{bmatrix}
0&0\\
a_u&-\infty
\end{bmatrix}
\begin{bmatrix}
f_{v,0}\\
f_{v,1}
\end{bmatrix}
=
\begin{bmatrix}
f_{u,0}\\
f_{u,1}
\end{bmatrix}
$$

考虑菊花上的问题，如果一个点有一堆儿子，那么我们把儿子们的转移矩阵分别乘初始向量，得到的结果都加起来就好了。所以我们得到一个垃圾算法 : 从每个叶子开始，拿着初始向量乘这个点的矩阵，然后在每个结点处把儿子们的向量加起来。这个做法实在是太垃圾了，因为我们只会合并向量而不会合并矩阵!

换个想法，我们把轻儿子的转移并入父亲，设$$g_{u,0/1}$$表示强制不选/选$$u$$，只考虑轻儿子的答案，枚举轻儿子$$v$$，容易发现有 : 

$$
\begin{aligned}
g_{u,0}&=\sum_{v}\max(f_{v,0},f_{v,1})\\
g_{u,1}&=\sum_{v}f_{v,0}
\end{aligned}
$$

设重儿子是$$v$$，于是可以得到这样的转移 : 

$$
\begin{bmatrix}
g_{u,0}&g_{u,0}\\
g_{u,1}&-\infty
\end{bmatrix}
\begin{bmatrix}
f_{v,0}\\
f_{v,1}
\end{bmatrix}
=
\begin{bmatrix}
f_{u,0}\\
f_{u,1}
\end{bmatrix}
$$

考虑修改产生的影响，重链上的影响容易处理，对于每个重链头向上连的轻边，我们用重链头的转移矩阵乘初始向量得到重链头的dp值，然后去更新重链头的父亲的$$g$$。复杂度是$$O(n\log^2 n)$$。

-----

洛谷P4751 【模板】"动态DP"&动态树分治（加强版）

把hld+线段树换成静态lct即可。

-----

[SDOI2017] 切树游戏

这看起来是个树上背包，设$$f_{u,k}$$表示$$u$$为根的连通块，权值为$$k$$的方案数，容易写出方程 : 

$$
f_{u,k}=\sum_{v\in\mathrm{son}(u)}f_{v,a_{u}\space\mathrm{xor}\space k}
$$

直接做这个dp是单次$$O(nm^2)$$的，可以用fwt优化异或卷积做到单次$$O(nm\log m)$$。如果一上来就fwt，在dp过程中用fwt值进行运算，最后再ifwt回来，复杂度会降低到$$O(nm\log m)-O(nm+m\log m)$$。

要想支持修改，有两种思路 : 

1. 仍然使用fwt，尝试进行树上的ddp。

2. 改用点分治优化dp，尝试用点分树维护。

我们先考虑ddp，这个点分治留到最后讨论（

设$$g_u$$表示把$$u$$的轻儿子们都合并起来得到的背包，$$f_u$$表示把$$u$$的所有儿子都合并起来得到的背包，那么转移显然。注意转移的时候需要$$+1$$表示可以不选。

注意到10007是质数，那么可以求逆，每个$$g$$的贡献就可以快速消除，于是ddp维护即可。

等等，一定可以快速消除吗?如果这个数是10007的倍数，那就没法快速消除了。这里有两种做法，一种是对儿子再进行一轮分治，也就是每个点开一棵线段树维护轻儿子，从而避免消除贡献；一种是扩域，用一个计数器记录乘了多少个同余于$$0$$的数，当要乘$$0$$的时候给这个计数器+1，除的时候-1。