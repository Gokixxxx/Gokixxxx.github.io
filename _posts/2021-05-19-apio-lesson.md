---
layout: post
title: APIO2021的课
subtitle: 还挺强
tags: 课
---

## 5.19 决策单调性与四边形不等式

### 抽象

决策单调性优化的dp总是可以转化成在矩阵中求每一行最小值的问题。比如经典的方程

$$
dp(i)=\min_{j<i}(dp(j)+w(i,j))
$$

就可以用$$A_{i,j}=dp(j)+w(i,j)$$构成一个矩阵$$A$$，这样$$i$$行的最小值就是$$dp(i)$$。以下默认一行的最小值是位置最大的最小值。

啊当然我们一般没有必要整个求出这个矩阵，它往往可以通过某种方法快速计算。

决策单调性优化的基础是，这个矩阵是单调矩阵。单调矩阵指的是每一行的最小值位置单调不降。

有些问题的性质更优美，它的矩阵是完全单调矩阵，也就是它的每个子矩阵都是单调矩阵，子矩阵说的是删去若干行列得到的矩阵。满足四边形不等式的都是完全单调矩阵。

能适用于单调矩阵的只有分治，而二分栈和SMAWK及其扩展都只适用于完全单调矩阵。

### 分治

北大集训2018 小z的旅行计划

给一个排列和一棵树，把排列分成$$k$$个区间的并，使得 每个区间并上$$1$$在树上的最小斯坦呐树边数 的和最大。$$nk\leq 2\times 10^5$$，注意是$$nk$$不是$$n,k$$。

发现这个转移用到的最小斯坦呐树边数有四边形不等式(反着的)，于是是完全单调矩阵，可以考虑分治或者二分栈，SMAWK不会真有人在场上写吧。

分治的优秀性质就体现在这里。这个转移的权值不好直接计算，但是可以类似莫队移动指针，维护一个set，可以在$$O(\log n)$$内增删一个元素。直接移动的话发现复杂度就是$$O(nk\log^2 n)$$。

-----

在完全单调矩阵中，定义一列是冗余的，当且仅当任何一行的最小值也不在它上面。

你发现有一个很好的性质，那就是对于两列$$i,j$$，

 - 如果$$j$$列在$$k$$行比$$i$$列更差，那么在此之前它总是比$$i$$列更差，也就是$$j$$列在$$k$$行之前是冗余的。

 - 如果$$j$$列在$$k$$行不比$$i$$列更差，那么在此之后它还是不比$$i$$列更差，也就是$$i$$列在$$k$$行之后是冗余的。

 证明?否则把这两列拿出来就不是单调矩阵了，不满足完全单调矩阵的定义。

 注意单调矩阵并没有这样的性质。

### SMAWK及其扩展

SMAWK基于一个有趣的操作reduce。它可以在线性时间内把需要求解的完全单调矩阵砍掉一些冗余列，具体地，可以把$$m\times n$$变成$$m\times\min(n,m)$$。

reduce操作从左往右扫过每一列，维护一个$$k$$，表示只考虑前$$k$$列的话，它们在主对角线上方都是冗余的(不包含主对角线)。

比较$$A_{k,k}$$和$$A_{k,k+1}$$，如果$$A_{k,k}\geq A_{k,k+1}$$，那么第$$k$$列整个都没有用了(因为主对角线上方已经没用了)，可以删掉第$$k$$列，并让$$k:=k-1$$(因为$$k+1$$列还不一定在主对角线上方冗余)，注意这里删除之后主对角线也会实时更新。删除一列的操作，因为不用随机寻址列，可以用链表维护没有删除的列。

反过来，如果$$A_{k,k}<A_{k,k+1}$$，那么说明第$$k+1$$列在主对角线上方全部冗余了，让$$k:=k+1$$。呃如果此时$$k=n$$那就不好了，不过我们可以直接删掉$$k+1$$列。

复杂度显然是线性。

SMAWK的主过程，每次选出偶数行构成新矩阵，reduce删掉多余列然后递归下去求解，然后每个奇数行在相邻偶数行的决策点之间爆力枚举。除了递归，每一步显然都是线性的，最后可以分析出一个$$O(m(1+\log\frac{n}{m})+n)$$的复杂度，相当于线性。

可惜SMAWK看起来有四倍常数，并且不能处理单调矩阵，也没有指针移动的性质，跟分治比起来没有很大优势。

-----

Wilber和Eppstein

可以做到和二分栈一样的事情，只不过是线性的。

常数巨大并且难写，OI中目前只有理论价值，换句话说你口胡的时候可以认为自己砍掉了一个$$\log$$。

### 四边形不等式DAG定长最短路问题

邮局 上环版

$$n,k\leq 2.5\times 10^5$$，5s，构造方案。

-----

**定理** 满足四边形不等式的DAG定长最短路的凸性

邮局 这个问题，观察dp方程，可以转化成DAG上定长最短路问题，同时这个边权是满足四边形不等式的。

呃具体怎么转化......就是如果$$i<j$$，那么$$i\rightarrow j$$的边权是$$w(i,j)$$，然后求从每个$$i$$到$$i+n-1$$，经过$$k$$条边的最短路，取$$\min$$就是答案。

设$$f(k)$$表示长$$k$$的最短路长度，考虑$$f(k+1)-f(k)\geq f(k)-f(k-1)$$这个东西(就是凸性)，可以证一个更强的结论 : 对于$$s<r<t$$，有$$f(s)+f(t)\geq f(r)+f(s+t-r)$$，这个代入$$s=k-1,r=k,t=k+1$$就得到凸性。

考虑设$$f(s)$$的路径是$$p_0\rightsquigarrow p_s$$，$$t$$的当然是$$q_0\rightsquigarrow q_t$$。

我们设$$v=r-s$$，如果可以找到一个$$i$$使得$$p_i\leq q_{i+v}<q_{i+v+1}\leq p_{i+1}$$，那么构造$$p_0,...,p_i,q_{i+v+1},...,q_t$$作为$$f(s+t-r)$$的路径，$$q_0,...,q_{i+v},p_i,...,p_s$$作为$$f(r)$$，根据四边形不等式容易得到它不比调整之前差(这个也可以直观理解，就是调整之后一条变长一条变短，而四边形不等式也是一种凸性)。

呃这里可能不是很好理解，我们画个图来看看。这是$$s=5,r=7,t=9,v=2$$的一个可能情况，红色是$$f(s)$$，蓝色是$$f(t)$$，剩下的懂的都懂。

![路径的调整](/img/2021-05-19-apio-lesson/paths.png)

那么怎么说明一定可以找到这样的$$i$$?

你发现一开始$$p_0=q_0$$，最后$$p_s=q_t$$，而$$s<t$$，直观来看$$p$$的平均跨度应该比$$q$$要大。然后你发现$$r$$是任取的，所以看起来对于$$[1,t-s-1]$$中的所有$$v$$都应该可以找到这样的$$i$$。

诶你发现看着上面那个图就显得非常直观。如果不存在这样的$$i$$，那么最后显然就不满足$$p_s=q_t$$了，具体怎么说明，大家懂的都懂......嗯!

然后我们就可以wqs二分，爆力枚举起点搞就可以了。复杂度$$O(n^2\log v)$$。啊还有构造方案......最后再说!

-----

路径单调性和路径不交性

容易证明，如果$$u_1<u_2,v_1<v_2$$，那么$$u_1\rightsquigarrow v_1$$和$$u_2\rightsquigarrow v_2$$的字典序最小的最短路一定不会相互穿过。证明方法就是调整一下不会变差，而字典序变小了(所以要求字典序最小)。

于是我们知道，要求的这$$n$$条路径互不穿过，这称为路径不交性。

然后就有一个想法，我们随便选一个点开始，用前面的算法求一条路径，假设它是$$p_0,...,p_k$$，那么剩下的所有路径$$q$$，都要满足$$q_i\in[p_i,p_{i+1}]$$，否则就不满足路径不交性。

注意到这些区间的长度和只有$$O(n+k)$$!

此时我们可以想到一个暴力做法，这些段里面一定有一段长度是$$\frac{n}{k}$$以内的，并且不管在哪条最短路里面，这一段里一定要选一个点。不妨把它转成第一段，然后直接枚举这个第一个点，每次可以爆力$$O(nk)$$计算，总枚举量是$$O(\frac{n}{k})$$，乘起来我们得到$$O(n^2)$$。

另一种想法是，考虑进行分治，同时维护所有$$k$$个点的可能区间，每次在第一个区间里面取中点作为第一个点，然后依次在剩下$$k-1$$个区间里跑SMAWK得到一条最短路，并把这些区间劈开递归下去。

看起来这很像$$O(n(\log n+\log v))$$，但是实际上不是，因为 由于中点会同时递归到两边，每次劈开都会让总区间长度增加$$k$$，一共要劈开$$n-1$$次，最后一层的总区间长度会变成$$O(nk)$$，就死掉了。

怎么解决这个问题?如果我们可以让递归层数少一点，也就是让第一段长度小一点......考虑把$$O(\frac{n}{k})$$那一段转到第一段来做，这样会劈开$$O(\frac{n}{k})$$次，每次增加$$k$$个点，最后一共增加$$O(n)$$个点，这样复杂度就正确了，变成了$$O(n(\log n+\log v))$$。

SMAWK太难写了，我们可以换成分治，于是得到了$$O(n\log n(\log n+\log v))$$做法，可以通过。

呃等等，我们还没构造方案呢!

-----

wqs二分在满足四边形不等式的DAG定长最短路问题中的快速构造方案

众所周知wqs二分的时候，如果遇到三点共线，那么各种奇技淫巧都难以搞到中间那个点，因此构造方案比较困难。一个可行的方法是爆力枚举第一段怎么选然后wqs二分剩下的，但是这样会让复杂度变得很劣。

不过我们有了上面的定理，就可以做一些很有意思的事情。我们跑两遍，一遍尽可能往左切，一遍尽可能往右切，就可以得到共线的左右端点，不妨设它们分的段数分别是$$s,t$$，那么显然$$s<k<t$$(如果有相等可以直接输出)，于是我们可以采用刚才的定理构造出长$$k$$和$$s+t-k$$的路径。容易证明这条长$$k$$的路径就是长$$k$$的最优路径，所以我们就得到了答案。

### 四边形不等式旅行商

给一张完全图，它的邻接矩阵满足四边形不等式，解tsp。$$n\leq 10^5$$。

-----

双调tsp

大家都知道双调tsp问题，毕竟这个在算导上作为例题。

啊你不知道?就是说，一开始一直往右走，走到头转而一直往左走，就叫双调；最后走回$$1$$就是双调回路；每个点都走一遍就叫双调tsp。

**定理** 四边形不等式旅行商问题一定存在一个最优解是双调的。

**证明** 归纳就行了。

$$n\leq 3$$的时候所有回路都是双调的。

考虑一个不是双调回路的最优回路，因为它不是双调的，一定存在一个点，使得回路中它前后的点编号都比它大，设这个三个点依次是$$u,v,w$$。

根据四边形不等式，我们知道$$w(u,w)+w(v,v)\leq w(u,v)+w(v,w)$$(注意$$v<u,w$$，而不是$$u<v<w$$)，所以先把$$v$$拿出来自环，把$$u,w$$接起来形成总共两条回路，答案不会变差。

此时这条长$$n-1$$的回路，根据归纳假设可以换成另一条不劣的双调回路。

最后在换好的双调回路上找到相邻的$$x,y$$使得$$x<v<y$$，根据四边形不等式有$$w(x,u)+w(u,y)\leq w(x,y)+w(u,u)$$，所以就可以把$$v$$插回去，得到新的双调回路。

-----

因为满足四边形不等式，双调tsp的dp还可以继续优化。

啊你说双调tsp的dp是什么?设$$dp(i,j)$$表示从$$i$$往$$1$$走，然后转而从$$1$$往$$j$$走的最短路径(因为从$$n$$走到$$1$$再回去，和从$$n$$走到$$1$$再回去都是双调回路)。转移只有$$\vert i-j\vert=1$$时需要枚举一个大的一边的前驱来转移，否则大的一边前驱是确定的，复杂度$$O(n^2)$$。

要优化，首先这个状态数太多了。我们可以只记录$$f(i)=dp(i+1,i),g(i)=dp(i,i+1)$$，然后打前缀和$$sf(i)=sf(i-1)+w(i-1,i),sg(i)=sg(i-1)+w(i,i-1)$$，考虑它们的转移 : 

$$
\begin{aligned}
f(i)&=\min_{j=1}^{i-1}g(j)+sf(i)-sf(j+1)
g(i)&=\min_{j=1}^{i-1}f(j)+sg(i)-sg(j+1)
\end{aligned}
$$

你发现这个新的前缀和也是满足四边形不等式的，所以可以用二分栈来处理，或者直接Eppstein做到线性。

## 5.20 Open Cup趣题选讲

这个实在是毒瘤。jiangly眼中的趣题能不毒瘤吗/kel

-----

Cactus Competition

给定一张$$n\times m$$的网格图，$$(i,j)$$的权值为$$a_i+b_j$$，其中$$a,b$$是给定的两数列。

求有多少对$$s,t$$满足存在一条从$$(s,1)$$走到$$(t,m)$$的路径(行从上到下，列从左到右标号)，每一步只能往下或往右走一步，且经过的所有格子的权值非负。

$$n,m\leq 2\times 10^5$$，2s 1GB。

考虑$$s=1,t=n$$怎么做。

结论 : 可行，当且仅当下列所有情况都不存在 : 

 - 有一行不能走，也就是$$\min a+\max b<0$$

 - 有一列不能走，也就是$$\min b+\max a<0$$

 - 存在某一个格子$$(x,y)$$，它往上往左发射射线，射线经过的格子都不能走，把起点围住了。也就是对于所有$$1\leq i\leq x,1\leq j\leq y$$，都有$$a_x+b_j<0,a_i+b_y<0$$

 - 存在某一个格子$$(x,y)$$，它往下往右发射射线，射线经过的格子都不能走，把终点围住了。也就是对于所有$$x\leq i\leq n,y\leq j\leq m$$，都有$$a_x+b_j<0,a_i+b_y<0$$

。如何证明?显然其中某一个出现的时候都不存在可行路径，所以我们只需要证充分性(都不出现则有可行路径)。

你发现如果前两个都不出现，就说明有至少一行一列全是可以走的，也就是$$\max a,\max b$$对应的行列。考虑它们的交点，设为$$(x,y)$$。

下面证明，从这个交点一定可以走到起点和终点，这两部分是类似的，所以我们只证可以走到起点。

画个图吧。绿色是可以走的一行一列 : 

![img1](/img/2021-05-19-apio-lesson/squares1.png)

现在只考虑左上方这个小方格。如果存在一列全是可以走的(蓝色) : 

![img2](/img/2021-05-19-apio-lesson/squares2.png)

那么我们考虑这一列和刚才可以走的那一行框起来的区域(灰色)，这是一个子问题。如果存在一行全是可以走的，情况类似。所以我们对这个进行归纳就可以了。

如果不存在这样的行或者列，容易想到我们要证明它一定不满足后两个条件。

你发现，不存在一行都能走，说明$$\min b+\max a<0$$(只考虑左上这个方格)，说明$$\min b$$这一列就都不能走。同理，$$\min a$$这一行也不能走。我们取这一行一列的交点，就符合了上面的第三种情况，所以一定存在一行或者一列可以走。

好了现在我们得到了一个看起来很强的结论，怎么用它解决这道题呢?

先考虑第三个条件，它限制了一些起点总是不可行的，第四个限制了一些终点总是不可行的，除此之外没有其它的限制。考虑怎么预处理出来这些不可行的起点，终点类似。

呃考虑对于每一个$$x$$，求出从$$(x,1)$$往右，有多少个连续的格子是不能走的。然后从这一段连续不能走的某个位置，再尝试向上尽可能进行延伸，这样遮住的一个起点区间都不可行。再画个图 : 

![img2](/img/2021-05-19-apio-lesson/squares3.png)

红色是连续不能走的，于是最高的那个ban掉了左边的一个起点区间。

这个东西怎么求?往右延伸可以搞一个前缀$$\max$$然后直接二分，往上延伸的话发现只有往右那一排的$$\min$$有用，可以用单调栈二分干掉。

然后问题是剩下的两个限制了。

一行都不行的话，相当于它上下割裂了，我们对于每一部分分开做即可。

一列都不行的话，容易发现只需要考虑$$\min b$$那一列，然后对于一个ban掉的区间，相当于是让它对应的起点区间都不能走到它对应的终点区间，然后就得到了一些限制，然后就可以求出每个起点可以走到多少终点，就~~终于**~~做完了。

复杂度是$$O(n\log n)$$。

-----

Query on a Tree 17

树，支持链/子树加，查询带权重心。$$n,q\leq 10^5$$，2s 1GB。

以重心为根，每一棵子树大小都不超过一半，所以以$$1$$为根，带权重心的子树权值和至少是总权值和的一半。所以如果我们随便找一个dfs序，那么它的带权中心一定在某个带权重心的子树里。

树链剖分，线段树维护dfs序来二分这个带权重心子树里的一个点。然后我们从这个点出发向上倍增找到带权重心即可，因为这个点上方最后一个子树权值和不超过总权值一半的点一定是带权重心(它的儿子不如它是，它的父亲不可能是，而链上一定有一个)。

复杂度是$$O(n\log^2 n)$$。

-----

Steel Slicing 2

有一个奇怪的多边形，它由若干个从$$x$$轴上分别向上下延伸、宽度为$$1$$的矩形组成。你每次可以切一刀把这个多边形变成恰好两个多边形，求最少切多少次，使得切出来所有东西都是矩形。这个图看起来像是 : 

![img2](/img/2021-05-19-apio-lesson/ss2.png)

。$$n\leq 2.5\times 10^5$$，1s 1GB。

显然只会横着或者竖着切，那么切出来最后肯定都是方的东西，于是全是矩形等价于不存在凹的顶点。

发现每一刀肯定会让凹顶点数减少$$1$$或$$2$$，那么我们只需要最大化减去$$2$$的刀数。

刀们相互之间的影响只有 : 如果横着切了一个顶点，不能再竖着切，反之亦然。另外，如果横着切的时候跨过了一种竖着切的方案，那么这个竖着切的方案就变成了上下两个只能让凹顶点数减少$$1$$的方案，所以它也不能选了。

所以容易想到建立二分图，左右分别是横着和竖着切的方案，对于每一个横着切的方案，向它影响的竖着切的方案连边，求最大独立集。

竖着切很容易预处理出来会减去多少凹顶点，横着切可以用上下两遍单调栈处理出来，最大独立集等于点数减去最大匹配，所以已经可以爆力Dinic做到$$O(n^{2.5})$$了，因为边数很多。

不过这么多的边都有一个性质 : 每个横着切的方案，一定是向一个区间中竖着切的方案连边。

考虑贪心，我们从左往右枚举竖着切的方案，贪心地匹配右端点最靠左的横着切的方案(注意我们现在在求最大匹配)，可以用堆维护。复杂度$$O(n\log n)$$。

-----

Interesting Drug

数轴上有$$n$$个东西，分别在$$1,...,n$$。你可以选择从任何一个点出发，然后可以左右移动，如果你走到一个东西，你就必须拿走它。有两个长$$n$$的数组$$c,d$$，表示如果物品$$i$$是第$$c_i$$个拿走的，你可以得到$$d_i$$的收益。对于每个起点坐标，最大化取得所有物品的收益。$$n\leq 3\times 10^5$$，$$d$$非负。

这种在数轴上往左往右走拿东西的问题，任意时刻拿到的东西一定是一个区间。设$$dp(i,j)$$表示拿了区间$$[i,j]$$中的物品得到的最大收益，决策最后拿最左边还是最右边进行转移即可。这样爆力就可以做到$$O(n^3)$$。

每个点开始跑一遍太恶心了，我们重新设$$dp(i,j)$$表示已经拿了$$[i,j]$$，拿完剩下的东西得到的最大收益，这样可以只跑一遍dp，复杂度是$$O(n^2)$$。

优化比较有意思。这个问题可以抽象成在平面上从$$(1,n)$$开始走，每次可以从$$(x,y)$$走到$$(x+1,y)$$或者$$(x,y-1)$$，也就是向右或者向下走一步。每一次有权值的转移都可以看成一条边，这样的边数量只有$$O(n)$$，我们可以从上往下扫，用BiT批量转移，就做完了。复杂度$$O(n\log n)$$。

-----

Find the LCA

给一个长$$n$$的点权序列$$a$$，对于所有 给每个点在它前面找一个父亲 而生成的有根树，求$$\mathrm{lca}(n-1,n)$$子树内所有点点权乘积的和。$$n\leq 2.5\times 10^5$$，膜$$998244353$$。

XXI Open Cup. Grand Prix of 998244353, Problem F(这一场十个题全是膜$$998244353$$/jy)