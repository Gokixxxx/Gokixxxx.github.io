---
layout: post
title: APIO2021的课
subtitle: 还挺强
tags: 课
---

## 5.19 决策单调性

### 抽象

决策单调性优化的dp总是可以转化成在矩阵中求每一行最小值的问题。比如经典的方程

$$
dp(i)=\min_{j<i}(dp(j)+w(i,j))
$$

就可以用$$A_{i,j}=dp(j)+w(i,j)$$构成一个矩阵$$A$$，这样$$i$$行的最小值就是$$dp(i)$$。以下默认一行的最小值是位置最大的最小值。

啊当然我们一般没有必要整个求出这个矩阵，它往往可以通过某种方法快速计算。

决策单调性优化的基础是，这个矩阵是单调矩阵。单调矩阵指的是每一行的最小值位置单调不降。

有些问题的性质更优美，它的矩阵是完全单调矩阵，也就是它的每个子矩阵都是单调矩阵，子矩阵说的是删去若干行列得到的矩阵。满足四边形不等式的都是完全单调矩阵。

能适用于单调矩阵的只有分治，而二分栈和SMAWK及其扩展都只适用于完全单调矩阵。

### 分治

北大集训2018 小z的旅行计划

给一个排列和一棵树，把排列分成$$k$$个区间的并，使得 每个区间并上$$1$$在树上的最小斯坦呐树边数 的和最大。$$nk\leq 2\times 10^5$$，注意是$$nk$$不是$$n,k$$。

发现这个转移用到的最小斯坦呐树边数有四边形不等式(反着的)，于是是完全单调矩阵，可以考虑分治或者二分栈，SMAWK不会真有人在场上写吧。

分治的优秀性质就体现在这里。这个转移的权值不好直接计算，但是可以类似莫队移动指针，维护一个set，可以在$$O(\log n)$$内增删一个元素。直接移动的话发现复杂度就是$$O(nk\log^2 n)$$。

-----

在完全单调矩阵中，定义一列是冗余的，当且仅当任何一行的最小值也不在它上面。

你发现有一个很好的性质，那就是对于两列$$i,j$$，

 - 如果$$j$$列在$$k$$行比$$i$$列更差，那么在此之前它总是比$$i$$列更差，也就是$$j$$列在$$k$$行之前是冗余的。

 - 如果$$j$$列在$$k$$行不比$$i$$列更差，那么在此之后它还是不比$$i$$列更差，也就是$$i$$列在$$k$$行之后是冗余的。

 证明?否则把这两列拿出来就不是单调矩阵了，不满足完全单调矩阵的定义。

 注意单调矩阵并没有这样的性质。

### SMAWK及其扩展

SMAWK基于一个有趣的操作reduce。它可以在线性时间内把需要求解的完全单调矩阵砍掉一些冗余列，具体地，可以把$$m\times n$$变成$$m\times\min(n,m)$$。

reduce操作从左往右扫过每一列，维护一个$$k$$，表示只考虑前$$k$$列的话，它们在主对角线上方都是冗余的(不包含主对角线)。

比较$$A_{k,k}$$和$$A_{k,k+1}$$，如果$$A_{k,k}\geq A_{k,k+1}$$，那么第$$k$$列整个都没有用了(因为主对角线上方已经没用了)，可以删掉第$$k$$列，并让$$k:=k-1$$(因为$$k+1$$列还不一定在主对角线上方冗余)，注意这里删除之后主对角线也会实时更新。删除一列的操作，因为不用随机寻址列，可以用链表维护没有删除的列。

反过来，如果$$A_{k,k}<A_{k,k+1}$$，那么说明第$$k+1$$列在主对角线上方全部冗余了，让$$k:=k+1$$。呃如果此时$$k=n$$那就不好了，不过我们可以直接删掉$$k+1$$列。

复杂度显然是线性。

SMAWK的主过程，每次选出偶数行构成新矩阵，reduce删掉多余列然后递归下去求解，然后每个奇数行在相邻偶数行的决策点之间爆力枚举。除了递归，每一步显然都是线性的，最后可以分析出一个$$O(m(1+\log\frac{n}{m})+n)$$的复杂度，相当于线性。

可惜SMAWK看起来有四倍常数，并且不能处理单调矩阵，也没有指针移动的性质，跟分治比起来没有很大优势。

-----

Wilber和Eppstein

可以做到和二分栈一样的事情，只不过是线性的。

常数巨大并且难写，OI中目前只有理论价值，换句话说你口胡的时候可以认为自己砍掉了一个$$\log$$。

### 四边形不等式DAG最短路问题

邮局 上环版

$$2.5\times 10^5$$，5s，构造方案。

爆力做法 : 枚举每一个村庄，从它破环成链，然后wqs二分，用Wilber优化dp可以做到$$O(n^2\log v)$$，同时常数巨大。

可是还要构造方案......这个问题我们放到最后讨论。

-----

**定理** 满足四边形不等式的DAG定长最短路的凸性

邮局 这个问题，观察dp方程，可以转化成DAG上定长最短路问题，同时这个边权是满足四边形不等式的。

呃具体怎么转化......就是如果$$i<j$$，那么$$i\rightarrow j$$的边权是$$w(i,j)$$，然后求从每个$$i$$到$$i+n-1$$，经过$$k$$条边的最短路，取$$\min$$就是答案。

啊当然另一种转化是直接分层图，它们是本质相同的，不过我觉得有些时候分层图更好理解，用到分层图来考虑的时候我会特别说明。

设$$f(k)$$表示长$$k$$的最短路长度，考虑$$f(k+1)-f(k)\geq f(k)-f(k-1)$$这个东西(就是凸性)，可以证一个更强的结论 : 对于$$s<r<t$$，有$$f(s)+f(t)\geq f(r)+f(s+t-r)$$，这个代入$$s=k-1,r=k,t=k+1$$就得到凸性。

考虑设$$f(s)$$的路径是$$p_0\rightsquigarrow p_s$$，$$t$$的当然是$$q_0\rightsquigarrow q_t$$。

我们设$$v=r-s$$，如果可以找到一个$$i$$使得$$p_i\leq q_{i+v}<q_{i+v+1}\leq p_{i+1}$$，那么构造$$p_0,...,p_i,q_{i+v+1},...,q_t$$作为$$f(s+t-r)$$的路径，$$q_0,...,q_{i+v},p_i,...,p_s$$作为$$f(r)$$，根据四边形不等式容易得到它不比调整之前差(这个也可以直观理解，就是调整之后一条变长一条变短，而四边形不等式也是一种凸性)。

呃这里可能不是很好理解，我们画个图来看看。这是$$s=5,r=7,t=9,v=2$$的一个可能情况，红色是$$f(s)$$，蓝色是$$f(t)$$，剩下的懂的都懂。

![路径的调整](/img/2021-05-19-apio-lesson/paths.png)

那么怎么说明一定可以找到这样的$$i$$?

你发现一开始$$p_0=q_0$$，最后$$p_s=q_t$$，而$$s<t$$，直观来看$$p$$的平均跨度应该比$$q$$要大。然后你发现$$r$$是任取的，所以看起来对于$$[1,t-s-1]$$中的所有$$v$$都应该可以找到这样的$$i$$。

诶你发现看着上面那个图就显得非常直观。如果不存在这样的$$i$$，那么最后显然就不满足$$p_s=q_t$$了，具体怎么说明，大家懂的都懂......嗯!

-----

路径单调性和路径不交性

容易证明，如果$$u_1<u_2,v_1<v_2$$，那么$$u_1\rightsquigarrow v_1$$和$$u_2\rightsquigarrow v_2$$的字典序最小的最短路一定不会相互穿过。证明方法就是调整一下不会变差，而字典序变小了(所以要求字典序最小)。

于是我们知道，要求的这$$n$$条路径互不穿过，这称为路径不交性。

然后就有一个想法，我们随便选一个点开始，用前面的算法求一条路径，假设它是$$p_0,...,p_k$$，那么剩下的所有路径$$q$$，都要满足$$q_i\in[p_i,p_{i+1}]$$，否则就不满足路径不交性。

注意到这些区间的长度和只有$$O(n+k)$$!

此时我们可以想到一个暴力做法，这些段里面一定有一段长度是$$\frac{n}{k}$$以内的，并且不管在哪条最短路里面，这一段里一定要选一个点。不妨把它转成第一段，然后直接枚举这个第一个点，每次可以爆力$$O(nk)$$计算，总枚举量是$$O(\frac{n}{k})$$，乘起来我们得到$$O(n^2)$$。

另一种想法是，考虑进行分治，同时维护所有$$k$$个点的可能区间，每次在第一个区间里面取中点作为第一个点，然后依次在剩下$$k-1$$个区间里跑SMAWK得到一条最短路，并把这些区间劈开递归下去。

看起来这很像$$O(n(\log n+\log v))$$，但是实际上不是，因为由于中点会同时递归到两边，每次劈开都会让总区间长度增加$$k$$，一共要劈开$$n-1$$次，最后一层的点数会变成$$O(nk)$$，就死掉了。

怎么解决这个问题?如果我们可以让递归层数少一点，也就是让第一段长度小一点......考虑把$$O(\frac{n}{k})$$那一段转到第一段来做，这样会劈开$$O(\frac{n}{k})$$次，每次增加$$k$$个点，最后一共增加$$O(n)$$个点，这样复杂度就正确了，变成了$$O(n(\log n+\log v))$$。

SMAWK太难写了，我们可以换成分治，于是得到了$$O(n\log n(\log n+\log v))$$做法，可以通过。

呃等等，我们还没构造方案呢!

-----

wqs二分在满足四边形不等式的DAG定长最短路问题中的快速构造方案

众所周知wqs二分的时候，如果遇到三点共线，那么各种奇技淫巧都难以搞到中间那个点，因此构造方案比较困难。。一个可行的方法是爆力枚举第一段怎么选然后wqs二分剩下的，但是这样会让复杂度变得很劣。

不过我们有了上面的定理，就可以做一些很有意思的事情。我们跑两遍，一遍尽可能往左切，一遍尽可能往右切，就可以得到共线的左右端点，不妨设它们分的段数分别是$$s,t$$，那么显然$$k<s<t$$(如果有相等可以直接输出)，于是我们可以采用刚才的定理构造出长$$k$$和$$s+t-k$$的路径。容易证明这条长$$k$$的路径就是长$$k$$的最优路径，所以我们就得到了答案。