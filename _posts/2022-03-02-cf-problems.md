---
layout: post
title: cf 2200~2600
subtitle: 咕
tags: 题选做
---

本来说要一天五场vp，结果没人陪我打/ll

那就换成高强度切题吧。

要的是速度。rush。

打开cf，选rating 2200~2600，通过人数降序。

-----

86D

21:08开始。

莫队。

13min。

-----

600E

21:22开始。

静态链分治。

20min wa on test 25。¿

想不到吧，要开long long。21min passed。

-----

52C

模板 线段树。

21:44开始，51写完。结果输入格式很阴间啊!还是却死吧。

-----

342E

6:48开始。

/xia这是点分树吗/xia

大概7:10写完，写的是cdq分治，点分治。开调。

7:18交了一发，然后T飞了。发现应该在虚树上点分治。那还是写动态点分治吧（

28写完了动态点分治，然后re了。我完全不知道哪里可以re。

然后自己造了一个，发现是找重心找错了。38过了。一个签到题用我50min/fn

-----

617E

7:39开始。

莫队。

7:46 wa on test 5¿

删除的时候写反了。47过了。

-----

438D

吉老师线段树。48开始。

58写完，然后wa on test 3。

然后发现是区间取模的时候写反了，应该先判直接return的情况。8:10过了。

-----

570D

11开始。

bfs序，压位一下就是查区间xor。

查了半天lower\_bound和upper\_bound怎么用，47写完了，一发过了。

-----

375D

静态链分治，BiT。50开始。

9:04一发过了。

-----

1400E

前年wa过。再来一遍/fn

把它画成一个柱状图这样的。然后我们考虑什么时候第一种操作才有用。

当且仅当它可以用$$k$$次操作清理超过$$k$$个位置。

考虑我们肯定是在操作2之前用所有的操作1，而操作1必然一直推到全局min。这会把序列分成若干段，每一段分别继续模拟即可。不知道啥复杂度，应该是$$O(n^2)$$吧。

9:11开冲。15写完了然后wa on test 4/yiw

这个小样例强度为0/fn，22过了。

-----

165E

模板 法嘛塔。23开冲。

29写完，直接过了。

-----

1537E2

考虑逐位贪心确定。每一位的结果只可能是第一个字符或者已经被copy到当前位置的字符，问题出在这两个字符相同时应该如何决策，也就是说我们是一直删到这个位置，再copy一遍，还是用之前copy的结果。二分hash判断哪个后面更优就行了。36开冲。

然后发现完全不需要这么麻烦。考虑我们找到重复之后字典序最小的前缀，然后不停重复这个前缀就行了。然后这个 重复之后字典序最小 看起来不是很容易。考虑有没有什么牛逼做法可以快速比较两个前缀重复之后的字典序。

容易想到hash。我们先求出每个前缀最多在原串中匹配多少次，然后就可以$$O(1)$$比较两个前缀。然后就做完了。

1e19以上第一个素数是1e19+51。不过我没有用到（

写了一年，10:45一发过了。串串还是不好写啊/fn

-----

1407D

直接dp。然后考虑如何优化。

单调栈。做完了。46~54，一发wa on test 1，然后是复制的时候有一个没改。然后wa on test 13。¿

注意这里是严格的，而可能有相同的数。所以需要试一试边界。11:12过了。

-----

558E

每个字符开一个线段树。

13开冲。38才过/ll，循环展开写错了。

-----

1333F

这个题结论还是比较牛逼。手玩一下可以感受到类似的性质，但是我并无法抽象出来。

考虑必然存在一个最优策略，满足如果选了一个数，那么选了它的所有因数。如果一个策略中，一个选了的数有因数没有选，那么把它换成这个因数，方案仍然合法。

于是一个数的贡献就是它的最大真因数。我们按照最大真因数从小到大枚举即可，而最大真因数可能可以线筛，不过至少可以$$O(n\log n)$$爆力。

21:01开冲，21:07过了。反复写错/fn

-----

1188B

容易想到上一个三次方程求根公式，但是那需要求解三次剩余。

然后就不会了。

然后这是套路数学题。我们希望把$$a_i,a_j$$独立开，可以乘上一个$$a_i-a_j$$，然后就得到$$a_i^4-a_j^4=k(a_i-a_j)$$，因为所有数互不相同，这是充要的，然后就做完了。

并不想写这道题，因为它实在是缺少营养，让人想起小学奥数。

-----

1438D

全局xor和是不变的。

如果$$n$$是奇数，那么全局xor和就是最后的每个数。先给每个数xor上全局xor和，然后问题是把每个数都搞成0。

容易想到用线性基把每个数凑出来，但是那样复杂度和操作数都爆了。

4号回来了。早上还是很有精神，每天早上都可以切掉一个遗留问题/se

考虑一个牛逼想法，我也不知道是怎么随到的。从左往右操作一遍，把相邻两个都搞成相同的，最后三个是相同的。那么由于相邻两个是相同的，xor一下全消掉了，而全局xor和是0，所以最后三个必然全是0。然后往回操作一遍，居然就全都变成0了。实在是非常的见鬼。

如果$$n$$是偶数，那么全局xor和必须是$$0$$。继续考虑刚才的牛逼想法，我们还是把这些数搞成两两相同的，但是最后会剩下一个位置。由于全局xor和是0，我们知道最后一个位置必然和倒数第二个相同，也就是说最后四个都是相同的。此时我们把所有数xor上最后四个，然后就感觉再扫回去就行了。7:17开冲，20写完。26过了。

-----

1474D

rnm，读错题/fn

34开始重读。

考虑最左边的，它只能和右边的老哥贴贴。然后右边的老哥会减少，变成$$a_2-a_1$$。

然后第三个老哥是$$a_3-a_2+a_1$$，第$$i$$个是$$\sum\limits_{j=1}^i(-1)^{i-j}a_j$$。如果它们全是正的，并且最后一个是$$0$$就行，否则就不行。

考虑这个交换有啥用。我们找到第一个负的位置，交换必然可以在它周围，尝试$$O(1)$$种情况即可。这里又读错题了，只能换相邻的啊/yun

如果没有负的位置，但是最后一个不是$$0$$，就换最后一个和倒数第二个。做完了。然后wa on test 2。看起来这个考虑的并不对，因为交换不一定在周围，可能出现在比较靠前的地方换了一手。

简单想法是直接线段树维护这个。看起来完全没有必要。

复杂想法是，注意到我们换的两个位置的差是确定的，因为最后一个必须是$$0$$。此时我们就知道交换的影响了，然后每个位置就知道一个可能进行的交换的区间，然后如果一个交换的差正确，并且在所有这些区间里，那就是彳亍的，否则不彳亍。感觉需要写一年，8:04开冲。

25写完，然后wa on test 2并且wa的不是很靠前，看不到数据。/fn

换个想法。刚才几乎已经指出了，我们可以直接知道一次操作的效果。然后枚举每次操作，直接看操作之后后面奇数位和偶数位分别的变化即可。这样也是线性并且更好写了。

然后发现这是交换相邻，所以直接前后缀和就行了。这也是线性并且更更好写了。8:49过了。

-----

628D

数位dp。50开冲。

读错题/yun，原来是偶数位必须总是d。

9:14写完，然后wa on test 29/xia，原来是特判a的时候没有判奇数位出现d。16过了。

-----

1110E

经典题。差分之后这个操作相当于交换相邻两项，对差分排序就行了。

17开冲。20过了。

-----

903D

模拟，对第一种情况特判即可。可以用map查三次。

21开冲。

25写完了，少了一个long long，wa了test 7，然后改完了又wa了29。原来这题答案可以爆long long/xia

然后用int128存，直接输出int128就行了。30过了。

-----

1406D

经典题。$$a$$中的下降完全由$$b$$贡献，上升完全由$$c$$贡献，也就是说在$$a$$的差分为正的地方，$$c$$的差分和$$a$$相同，$$b$$的差分为$$0$$；为负的时候反过来。

区间加只会改变两个差分。

剩下的问题完全是我们怎么安排这两个序列的第一项。$$b$$的最大值是$$b_1$$，$$c$$的最大值是$$c_n$$，假设所有正的差分之和是$$d$$，那么有$$c_n=c_1+d$$，同时有$$a_1=b_1+c_1$$。于是我们要最小化$$\max(b_1,c_1+d)$$，显然是取$$b_1=c_1+d=\frac{a_1+d}{2}$$。由于两个序列都需要是整数，所以上取整就好了。39开写，然后wa on test 6。>>1总是下取整，而/2是向零取整。58过了。

-----

551C

二分答案，然后每个人分一段。10:00开冲。

09写完了，然后感觉要挂。结果果然挂在了test 54/xia

改了一个更正常的双指针写法，18过了。

-----

1009F

模板 长链剖分

19开冲。32过了。

-----

598C

模板 极角排序。34开冲。

43终于写完了，忘了回去找到原来的下标，实在是太智障了/fn

然后还有一个地方写反了/fn

然后wa on test 118/yiw，改成long double之后48过了。

-----

1092D1

请注意这是Div.3 D/xia，讲道理这难度比较离奇。不过想到另一个做法是模拟，看起来也就可以理解了（

每个位置最多给左右各接一个横着的，所以先给每个位置膜$$2$$，注意如果膜完了是$$0$$要改成$$2$$。然后枚举是$$+1$$还是不，然后模拟即可。

读错题。这是经典问题，但是我没见过，不过我可以想起来joi open 2016 A. JOIRIS，然后它好像不是很一样。

我们可以用类似的方法考虑。先把它变成单增的，然后强行放就行了。然后这个也假了。

结论是，这相当于给每个数膜$$2$$，然后跑一个类似括号匹配的东西，让0和0匹配，1和1匹配。这看起来很可以理解，但是是怎么想到的呢?

-----

1092D2

实际上这题通过数没有那么多，但是看到了就一起写了吧。

不能放竖着的了，我们还是考虑抽象成括号匹配。新加入的必须要比之前的栈顶更低，不然就把之前的栈顶卡死了。然后如果最后没剩下或者剩下的是全局最大值那就可行，否则不可行。2min就写完了。

-----

1336C

20:47开始。

考虑一下这玩意怎么双向加字符。你发现它不行。

考虑这个串前一半是操作1出来的，后一半是操作2出来的，于是我们枚举这个分界的位置，或者说枚举第一个字符在哪。然后就可以$$O(n^3)$$了，也就是dp两边各放到哪了。

考虑换个方向。当需要枚举中间的时候，我们倒过来，从两边往中间做。此时问题变得简单起来。设$$dp(i,j)$$表示左边放了$$i$$个，右边放了$$j$$个，目前看起来合法的方案数，转移枚举哪边继续放就行了。

草，21:10写完了，然后读错题，原来不需要全放进去（

那看起来这个dp也修补不动了。

咕了一会，然后发现一个很要命的事情，也就是并不需要从两边往中间扫。刚才那个$$n^3$$做法中，我们并不需要知道左右各放了多少，只需要知道一共放了这么多，然后知道开始位置就行了。所以设$$dp(i,j)$$表示放了$$[i,i+j-1]$$这一段的方案数，然后就做完了。55开始写，58一发过了。

-----

1450C2

这题目十分的经典（

由于太经典就不多说了。22:04开冲，11过了。

-----

713C

给$$a_i$$减去$$i$$，问题变成把它变成非严格单增的。容易发现每个数必然会操作成原来在序列中就存在的数，离散化之后dp即可。

13开冲，22写完了，然后inf开小了wa了一发。

-----

11D

经典问题。状压dp。

24开冲。53好歹调出来了，然后wa on test3，原来压根没有判有没有边。54过了。

-----

587C

/xia

树剖线段树，每个点维护区间内的有序数组。复杂度是俩$$\log$$。

明天写。也可能后天（