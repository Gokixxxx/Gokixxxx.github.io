---
layout: post
title: 一些比赛的题解
subtitle: /ll
tags: 题解
---

因为没地方放就开了一个。

-----

联合省选2022

D1

A. 预处理器

模拟。

B. 填树

考虑枚举一条链，然后枚举最小值$$l$$，那么我们需要所有数都在$$[l,l+k]$$之中，并且有一个数$$=l$$。第二个限制可以用$$[l,l+k]-[l+1,l+k]$$差分掉，也就是我们拿$$k-1$$再跑一次。

考虑固定一个区间$$[l,r]$$之后，一个点的方案数分成五段，贡献也分成五段。

 - 如果$$r<l_i$$，方案数是$$0$$，贡献是$$0$$。

 - 如果$$l\leq l_i\leq r$$，方案数是$$r-l_i+1$$，是一个关于$$l$$的一次函数，贡献是$$s(l_i,r)$$，是一个关于$$l$$的二次函数，其中$$s$$是整数区间和。

 - 如果$$l_i\leq l\leq r\leq r_i$$，方案数是$$r-l+1$$，是一个常数，贡献是$$s(l,r)$$，是一个关于$$l$$的二次函数。

 - 如果$$l\leq r_i\leq r$$，方案数是$$r_i-l+1$$，是一个关于$$l$$的一次函数，贡献是$$s(l,r_i)$$，是一个关于$$l$$的二次函数。

 - 如果$$r_i<l$$，方案数是$$0$$，贡献是$$0$$。

每一个$$l$$的答案是所有点的贡献乘起来。

我们可以把这些分段函数直接乘起来，然后得到一个$$O(n)$$段的函数，每一段都是$$O(n)$$次，每一段求一个和就行了，可以用经典的线性拉插$$O(n)$$求一段。外层还有$$O(n^2)$$的枚举链，总复杂度$$O(n^4)$$。

优化看起来比较简单，我们改成外层枚举$$l$$，那么内层看起来是要求所有链的乘积的和，于是总复杂度$$O(n^3\log n)$$，其中$$\log$$是排序。

然后可以改成树形dp变成$$O(n)$$次合并$$O(n)$$段的$$O(n)$$次函数，于是总复杂度变成$$O(n^3)$$了。

C. 学术社区

不会。

容易想到一些图论做法。考虑这个问题看起来很像路径覆盖，然后发现特殊性质A确实是可以这么做的，也就是对于每条消息给楼上连到楼下，然后对于每个学术消息从一个虚点连到发消息的人，然后我们要把这些边划分成若干路径使得路径数最小。考虑网络流，我们给每个人拆成一个入点一个出点，然后，

D2

学校vp了这一套。

A. 卡牌

考虑给每个数按大素因数分类，然后小素因数fmt。看起来挺套路的（

为什么我写了一发直接挂了啊?

B. 序列变换

注意到$$x,y\leq 1$$，并且有个部分分是$$x=0,y=1$$，所以想到要对这个讨论。

考虑建立表达式树，那么这个操作1相当于合并一个点的两个相邻儿子，然后把右边那个的左括号作为一个单点扔到下一层。一个简单结论是，我们会从上往下操作每一层，因为操作下面不影响上面，而操作上面会合并下面，这样在操作每一层的时候拥有最大的自由度(操作2是任意重排所有儿子)。

考虑$$x=0,y=1$$怎么做。此时可以发现每一层只有一个左括号可以不付出代价，剩下的左括号都要付出代价并且进入下一层，于是我们肯定希望那个不付出代价的是最大的，用一个堆维护即可。

考虑$$x=1,y=0$$怎么做。此时合并树的每个右儿子都不会付出代价，于是容易想到一个简单策略，每一层让最小的左括号放在最左边，这样合并每个的时候都是最优的，但是问题是这个最小的无法进入下一层了，所以不一定最优。考虑先把全局最大的扔了，然后每层留下最大的，让它付出一次代价，而剩下的让最小的来进行合并。除了最后一层放了全局最大的以外，每个左括号都必须付出一次代价，所以这个策略必然不劣。

考虑$$x=1,y=1$$怎么做。此时每个点每一层都要付出代价，那么我们还是希望把最大的扔了，所以不扔全局最大，跑一个跟$$x=1,y=0$$类似的东西就行了。

考虑$$x=0,y=0$$怎么做。好难啊，不会/ll

为什么我写了一发直接挂了啊?看起来$$x=1,y=0$$的时候少了一些讨论。注意到我们为了把全局最大留到最后，如果此时只剩了两个数，可能会把一个很小的扔掉，这就很不好。注意到在树的深度内处理每一层时这一层的点数是不降的，于是只需要讨论一下对于一个极长的每层两个点的前缀，我们是保留其中的最大值还是最小值。

题目很有趣，但是不给大样例有点恶趣味了。

C. 最大权独立集问题

出题人来自fjoi吧/xia

考虑直接做看起来没法做，我们进行一个强力转化，注意到这个交换的结果就是每个权值走了一条路出来，于是猜测一个交换方案等价于从每个点出发选一条非空有向路径，使得每条边恰好被来回覆盖各一次。考虑证明，我们需要对这样一些路径找到一个操作方案，考虑只需要找到第一步然后递归下去，问题是证明第一步的存在性，也就是必然有两个点的第一步走到了同一条边，直接注意到有$$n$$个点$$n-1$$条边，所以根据鸽子原理确实是这样的。

然后感觉像是网络流，但是并不是，因为这个费用对于不同的起点是不同的。

感觉已经可以大力dp了!但是讨论太多脑子不太够用。

为什么我12分爆力看起来没挂啊?

然后这个转化也是没有必要的。

大概看了看正解，考虑设$$dp(u,v,w)$$表示$$u$$子树中，换出去的是$$v$$，进来的是$$w$$的答案，转移讨论一下怎么接，然后可以做到$$O(n^3)$$。为了优化，考虑一个牛逼状态，设$$dp(u,v,w)$$表示换出去的是$$v$$，换进来的点进来之后走到$$w$$，不计换进来的点的贡献的答案。有趣的事情是这个状态数是$$O(n^2)$$，因为$$v,w$$不能在同一棵子树，这个是树卷积。然后继续枚举怎么接。

-----

pjudge easy round 1

A. 捉迷藏

考虑从起点出发的最长简单路径，如果A不在这个方向上，那么B直接沿着这个走到头然后等死，显然是最优的。所以以center为根拎起来，A总是在上方，或者可能在center的另一棵子树里。

然后显然的策略是双方一起往上跳，什么时候再跳就要撞上了，就选择最长的子树走进去然后等死。但是如果B先走到了center，那么此时A会守在任何一棵足够长的子树中，所以我们需要ban掉一些点，这个可以预处理出来。

官方题解做法比较牛逼。考虑我们直接往直径端点走，如果接下来要撞上了，那么就选一个必然没有A的子树走(因为如果有A那么一步就撞上了)。对两个直径端点取$$\max$$即可。

B. 新问题

放卡笛尔树的括号序。

C. 括号序列

请注意这个不是括号序列，应该说是$$n$$种颜色的球，每种颜色有两个，每个球都可区分。

考虑这个限制相当于，第$$i$$个位置上放的不能跟$$i-m,i-2m,...$$相同。

考虑我们在这些$$\bmod{m}$$上扫描线。我们要计算，有若干个桶，往里放球使得每个桶都是满的，并且每个桶中没有颜色相同的两个球的方案数。设$$dp(i,j)$$表示放了前$$i$$个桶，有$$j$$个颜色被放没了，可以计算的个数的颜色被放了一次，剩下的颜色没有被放的方案数。转移枚举这个桶放了多少个没被放的，多少个放了一次的，然后组合数选一选。状态数是$$O(\frac{n^2}{m})$$，转移是$$O(m)$$，于是总复杂度$$O(n^2)$$。

官方题解是容斥，看起来很有道理。

D. 子序列

有点牛逼了。

等价于删掉尽可能少的数而ban掉所有lis。

考虑爆力怎么做。让人想起某个关于lis的网络流题，考虑我们要删掉一些位置使得没有一个lis被留下来，那么需要先构造一个网络使得$$s\rightsquigarrow t$$的所有路径是所有lis，然后最小割。考虑如果$$i\rightarrow j$$的转移存在于一个lis中，那么只要前面选的都是这样的转移，沿着这个转移走最后必然可以走到一个lis，于是连上所有这样的边就好了。然后拆点最小割。

考虑怎么快速算这个最小割。这个不是平面图，所以不能最短路。

另一个方向的对偶是最大流，它的意义是选尽可能多的不交的lis。

这个题是COCI2021-2022 R1 Volontiranje，可以在谷7931看到。

注意到根据我们一开始的建图，按照以每个位置结尾的lis长度，给所有点分成若干层，那么只有相邻两层之间有边。一个lis就是在每层选一个点，然后这些点之间存在一条路径。

先把不在任何lis中的点删掉。这个可以正反跑两遍BiT优化dp的lis算一下，或者看起来有别的方法。

虽然这不是平面图，但是注意到一个看起来可能有点像的性质，我们所选的这些lis必然可以不交。如果两个lis相交了，那么交的那一段长度必然相同，否则短的一边换上长的则得到更长的lis。于是我们交换这两段，它们就变得不交了。

考虑我们每次选择最左边的lis，也就是依次最小化在第一层选的点的编号，在第二层选的点的编号，......这样的。

一个解释是，如果我们没选最小的，那么再选最小的那个的时候，就会和当前选的这一个相交，根据前面的结论一定不优。

另一个解释是，我们在前面很小的时候，这一个应该也选小的，因为前面选了一个很大的编号的话，这一层的小的就没法选了。

这样就可以$$O(n^2)$$了。为了优化，注意到某一层的某个数在某一轮因为太大了不能选，那么在后面的轮就都不能选了。所以就线性了，瓶颈是一开始跑一遍lis的dp。

E. 平均分

想了一年$$O(2^n\operatorname{poly}(n))$$，然后飞了。

然而是折半。直接分成两半，分别爆搜，然后合并是一个三维偏序，搞一搞可以发现可以省掉一维，然后就$$O(3^{\frac{n}{2}}n)$$了。

讲道理这个题好像见过，但是已经忘了（

-----

sdoi2019

应该是这个顺序吧?

D1

A. 快速查询

模拟。

B. 染色

如果没有限制，直接dp即可。如果有限制的话，主要问题是限制的颜色是确定的，而dp的颜色不是。

直接做看起来比较困难。考虑了容斥发现也比较困难，总是需要记两个颜色。

考虑我们强行优化直接做。直接做就是设$$dp(i,j,k)$$表示第$$i$$列两个点颜色是$$j,k$$的方案数。转移是$$dp(i,j,k)=dp(i-1,j^\prime\neq j,k^\prime\neq k),dp(i,j,j)=0$$这样的。也就是说一个位置从所有位置减去一个十字转移而来，然后对角线上所有位置都是$$0$$。

考虑我们维护一个行的和和列的和，设$$s_x(i,j),s_y(i,j)$$是行和列的和，$$s_a(i)$$是总和，那么转移就是$$dp(i,j,k)=s_a(i-1)-s_x(i-1,j)-s_y(i-1,k)+dp(i-1,j,k),dp(i,j,j)=0$$。

考虑只处理行的和和列的和的转移。注意到每行每列都只有一个形如$$dp(i,j,j)$$的位置。

$$
\begin{aligned}
s_y(i,j)&=\sum_{k=1}^c dp(i,j,k)\\
&=\sum_{k=1,k\neq j}^c\left(s_a(i-1)-s_x(i-1,j)-s_y(i-1,k)+dp(i-1,j,k)\right)\\
&=(c-1)s_a(i-1)-(c-1)s_x(i-1,j)-s_a(i-1)+s_y(i-1,j)+s_y(i-1,j)\\
&=(c-2)s_a(i-1)-(c-1)s_x(i-1,j)+2s_y(i-1,j)\\
s_x(i,j)&=(c-2)s_a(i-1)-(c-1)s_y(i-1,j)+2s_x(i-1,j)
\end{aligned}
$$

于是我们就做到$$O(nc)$$了。考虑进一步优化，发现这个相当于全局$$\times 2$$，一个序列乘一个系数加到另一个序列上，全局加。注意到一个序列加到另一个序列上不好做，于是我们考虑$$s_x(i,j)+s_y(i,j)$$的转移。

$$
s_x(i,j)+s_y(i,j)&=(2c-4)s_a(i-1)-(c-3)(s_x(i-1,j)+s_y(i-1,j))
$$

然后就做完了。需要注意$$(2c-4)s_a(i-1)$$是全局和的$$c-2$$倍，因为每个位置已经被算了两次。套用A的数据结构即可，复杂度$$O(n\log n)$$。

C. 世界地图

倒过来的话，相当于每次问一个经度区间的mst。不过这个转化不是很好用，因为一个前缀拼一个后缀是个很好的结构。

考虑跑出每个前缀和每个后缀的mst，这个可以用lct搞定。

接下来问题是如何合并两边的mst。可以用严格lct支持可持久化，但是有没有更简单的做法?

注意到我们会加入$$n$$条边，而这些边连接的是左边第一个点和右边第一个点，左边第二个点和右边第二个点......这样的。先钦点加入其中最小的边，那么剩下的边可能可以进行一些替换。可以注意到它们可能替换的边必然是原来mst上第一次连通 左边某个点和左边某个点 的边，或者右边的这样的，也就是在kru重构树上左边/右边这些点两两的lca构成的集合。把这些边都拿出来就行了。

现在问题是怎么求每个前缀和后缀的kru重构树。一样做就行了，也就是我们新加入一列点的时候直接跟前面的虚树上的点对应的边一起重新跑kru重构树。复杂度$$O((m+q)n\log n)$$。

D2

A. 热闹的聚会与尴尬的聚会

限制等价于$$q(p+1)\geq n,p(q+1)\geq n$$。

样例没有无解，所以直接猜测必然有解。

我们可以不停删度数最小的点直到没有点来找到最大的$$p$$。接下来我们需要找到一个大小足够大的独立集。

考虑怎么才能凑出一个长的像$$pq$$这样的东西。

考虑一个离奇想法，注意到我们继续不停删掉度数$$=p$$的点，就不会剩下任何点了，那么按照删掉的顺序，我们每选一个点会ban掉后面不超过$$p$$个点，于是贪心即可。

B. 移动金币

考虑如何判定一个局面是先手必胜还是后手必胜。

一个前置知识是Staircase Nim。这个转化比较有趣，我们考虑空位的移动，发现它就是Staircase Nim。于是问题变成从右往左数第奇数个间隔的长度的xor和是$$0$$的方案数。

然后可以$$O(n^2m)$$状态的dp，这个看起来很困难。考虑如何优化，问题相当于选$$\frac{m}{2}$$个数，和不超过$$n-m$$，并且xor和为$$0$$的方案数，偶数位置的可以隔板一下。

考虑数位dp，设$$dp(i,j)$$表示前$$i$$位xor和都是$$0$$，并且总和是$$j$$的方案数。转移就是枚举这一位有多少个选了，看起来选的个数必须是偶数。复杂度$$O(nm\log n)$$。

C. 连续子序列

不可能会。

这个序列叫Thue-Morse序列。

一个经典结论是，以下几种方法都定义了这个序列 : 

 - $$a_{2n}=a_n,a_{2n+1}=1-a_n$$

 - 从$$0$$开始，每次把$$0$$变成$$01$$，$$1$$变成$$10$$

 - $$a_n$$是$$n$$的popcnt的奇偶性

 - 从$$0$$开始，不断把整个序列取反之后的结果接在序列后面

。

考虑如何判定一个串是不是thue-morse序列的子串。使用第二个定义的话，我们只需要知道开头是奇数位还是偶数位，就可以直接这么操作把它操作回去。进一步地，如果串长至少是$$5$$，那么必然存在两个相邻的相同字符，不从这里断开则必然不合法。于是我们可以$$O(n)$$检查一个长$$n$$的串，但是这个有啥用啊（

注意到对于串长至少是$$5$$的串，其中必然包含两个连续的相同数字，所以划分直到串长$$\leq 4$$的方案是唯一的。设$$dp(s,i)$$表示串$$s$$后面接了$$i$$个字符的答案，那么如果$$\vert s\vert+i\leq 4$$则爆力，否则递归两种划分方案。当$$\vert s\vert\geq 5$$的时候只有一种方案，而当$$\vert s\vert\leq 4$$的时候只有$$O(1)$$种$$s$$，于是状态数是$$O(s+\log k)$$。用map记搜即可。

-----

十二省联考

D1

A. 异或粽子

也就是求前$$k$$大区间xor和。拆成前缀和，开一个trie，然后开一个堆维护包含每个元素的当前答案，每次取出最大的，在trie上找到下一个，复杂度$$O((n+k)\log v)$$。

B. 字符串问题

题意有点复杂了。可以转化成这么一个过程 : 选一个A串，然后选一个它支配的B串，然后再选一个包含这个B串作为前缀的A串，一直这样选下去，求所选A串的长度和的最大值，或者判定这个过程可能一直进行下去。

考虑我们从每个A串连向它支配的B串，从每个B串连向包含它作为前缀的A串，那么问题变成dag带权最长路。问题是第二种边的数量可能很多。

考虑利用后缀树优化建图。我们建立前缀树，那么一个点子树内的所有子串就是它后面加一些字符能得到的所有子串。在这上面优化建图即可。

但是有一个问题，也就是如果一个A串和一个B串在前缀树上对应的点相同，但是这个B串更长，那么B串会连到A串上，但是它不应该连上；如果B串更短，那么确实应该连上。对每个点开一个前缀和优化建图即可。

C. 骗分过样例

不必多说了（

D2

A. 皮配

看起来是，有ABCD四个集合，然后有若干组(城市)元素(学校)，一个组要么全给AB要么全给CD，有一些元素不能分配进某一个集合。最后对A+B A+C C+D B+D都有限制。

爆力就是设$$dp(i,a,b,c,d,0/1)$$表示懂的都懂。注意到$$a+b+c+d$$是固定的，所以省去一维。

注意到即使限制C+D=0，也是需要背包的。所以我们必须背包。

注意到只有对$$a+b,a+c$$的限制，而没有对$$a$$的限制，所以我们可以只记录$$a+b,a+c$$。所以又省去一维。

注意到这个相当于有两个维度，每个元素可以在两维上选择是否贡献。如果$$k=0$$，两维是独立的，所以我们可以分开dp，所以就$$O(nm)$$了。

考虑如果$$k>0$$怎么做。刚才我们的做法基于两维独立，所以方案数是在两维上选择的方案数乘起来。现在考虑把这些元素分成三种 : 

 - 有限制的 : 只能爆力。

 - 没有限制，但是同组有限制的 : 两维是独立的，但是第一维的选择会影响到同组的那个有限制的。

 - 没有限制，同组也没有限制的 : 完全随意。

一个直接的想法是，把第一类和 第二类的第一维 一起做，然后和第二类的第二维以及第三类卷起来。

注意到第一类只有$$k$$个，并且每个的大小只有$$s\leq 10$$，所以如果只dp它们的话总和只有$$O(ks)$$；但是第二类可能有很多。

考虑设$$dp(i,j,k,0/1)$$表示考虑一二类的前$$i$$个，第一维的和是$$j$$，第一类在第二维的和是$$k$$，当前这一组在第一维选了AB/CD的方案数，这个是$$O(nmks)$$的，看起来没了。

一个想法是把$$i$$一维的大小从$$n$$砍成$$k$$。注意到这个背包可以一次加入一组，因为没有限制的元素只对第一维的和有影响，而这个影响只和组选AB还是CD有关；有限制的元素可以爆力。于是设$$dp(i,j,k)$$表示考虑有限制的前$$i$$组，第一维的和是$$j$$，第一类元素在第二维的和是$$k$$的方案数，转移枚举下一组加入AB还是CD，然后对于其中第二类元素只需要知道总和，对于第一类元素进去爆力转移。这样总复杂度是$$O(mk^2s)$$。

接下来设$$f(i,j),g(i,j)$$分别表示第三类第一维的方案数和二三类第二维的方案数即可，这两个是$$O(nm)$$的。然后需要合并，我们枚举$$dp$$的一个状态查对应的$$f,g$$的前缀和，复杂度$$O(m^2)$$。

B. 春节十二响

看起来是，把点划分成若干个集合，每个集合内部没有祖先-后代关系，求所有集合max的和的最小值。

看一眼部分分，考虑链怎么做，发现链必须是每个点在一个集合。

?，这个链不一定以1为根。于是它实际上是两条以1为根的链。考虑这个怎么做，发现我们必然是把两边按最大值排序之后合并对应的。注意到合并之后树也等价于一条链，于是就结束了。每次合并都会少一个点，用堆维护，复杂度$$O(n\log n)$$。

C. 希望

不必多说了（

