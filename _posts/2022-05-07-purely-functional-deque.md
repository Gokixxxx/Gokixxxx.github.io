---
layout: post
title: 纯粹的功能，实时的德克与卡廷化
subtitle: /se
tags: 数据结构
---

实际上是，支持合并的纯函数式deque。这个翻译是deepl给出的。

大家都知道单链表是可以简单可持久化的，但是双链表不行。大家都会用单链表均摊地实现双端队列。那么如何可持久化双端队列呢?今天小编就带大家来看一看 https://dl.acm.org/doi/pdf/10.1145/324133.324139 这篇论文。

这个可持久化deque是严格$$O(1)$$，而不是均摊$$O(1)$$。

-----

不支持合并的严格可持久化双端队列

-----

Clancy-Knuth表示法

用来表示一个数，并且在$$\pm 1$$的时候变化量是严格$$O(1)$$。

我们允许一个二进制数中出现$$2$$，这称为redundant binary representation，这样的东西简称为数。显然一个数值对应的数一般不唯一。

定义一个数是好的，当且仅当忽略掉所有$$1$$之后，不存在两个相邻的$$2$$，并且最低的非$$1$$位不是$$2$$。

我们在对好数做$$+1$$的时候，由于最低的非$$1$$位不是$$2$$，所以可以直接$$+1$$，但是这可能让它变得不好。我们找到最低的非$$1$$位，如果它是$$0$$则啥事没有，否则我们把这一位置为$$0$$，把下一位增加$$1$$。这样变化量就是严格$$O(1)$$。

-----

我们用满二叉树来索引元素。定义一个级别为$$k$$的buffer是不超过$$5$$棵高度为$$k$$的满二叉树的集合，我们将这样的树称为 元素。一个deque由一个三元组表示 : 前缀buffer，后缀buffer，和剥掉这两个buffer之后的deque，这个deque称为它的儿子。一个deque和它的儿子和它的儿子的儿子......统称为它的子deque，根据语境直接简称为deque。

现在两个简单的操作就是，我们可以把$$k$$层的一个元素拆成两个元素扔到$$k-1$$层，也可以把$$k-1$$层的两个元素合并起来扔到$$k$$层。所以这个就是某种很redundant的二进制表示。使用类似于刚才的Clancy-Knuth表示法的方法，称一个buffer是红色(对应于2)的，当且仅当它有$$0$$或$$5$$个元素，黄色(1)是$$1,4$$，绿色(0)是$$2,3$$。定义一个deque的颜色是它前后buffer颜色中更危险的或者说更大的那个，特别地，如果最后一层的deque的buffer之一是空的，我们定义它的颜色是它非空buffer的颜色。

定义一个deque是semiregular的，当且仅当把它和所有儿子的颜色拿出来排成一排(它自己排在第一个)，把所有黄色忽略掉之后，不存在相邻的两个红色，而regular的deque还要求这个序列中第一个黄色之外的颜色是绿色。如果一个deque是regular的，那么它的顶层必然不是红色，所以我们可以直接在顶层加/删点来做到$$O(1)$$。

在一次操作之后，regular的性质可能被破坏。我们还是找到最浅的红/绿deque，如果它是绿色，那么啥事没有。如果它是红色，我们就希望调整一下。

第一个问题是如何找到最浅的红/绿deque。我们把这些点表示成若干条链，每条链是一个红/绿deque和它后面跟着的极长黄点，然后这些链之间再用一个单链表串起来。接下来可以看到，一次操作最多访问前三条链，并且最多访问每条链的前两个点，而它带来的链划分的变化是容易处理的。

我们描述一个方法把任意semiregular的deque调整为regular的deque。考虑设这个deque里最浅的红deque是$$i$$，它的儿子是$$i+1$$，$$p_i,p_{i+1}$$是它们的前缀buffer，$$s_i,s_{i+1}$$是后缀buffer。

$$i+1$$不可能是红的。如果$$i+1$$是最后一层，它的buffer可能有一个是空的，否则$$p_{i+1},s_{i+1}$$都不可能是空的，因为semiregular的deque里面没有两个红deque相邻。

接下来有以下两种情况 : 

 - 如果$$i+1$$层的buffer总大小$$\geq 2$$，或者$$i+1$$层的buffer总大小$$\leq 1$$并且$$i$$层的至少一个buffer大小$$\geq 2$$。如果$$i$$层的一个buffer大小$$\geq 4$$，从它里面拿两个接起来移动到$$i+1$$层，由于$$i+1$$层不是红的，这必然可行。如果$$i$$层的一个buffer大小$$\leq 1$$，从$$i+1$$层拆一个移动到它。如果此时$$i+1$$层空了，删掉它。此时$$i$$必然是绿色。

 - 如果$$i+1$$层的buffer总大小$$\leq 1$$，并且$$i$$层的两个buffer大小都$$\leq 1$$。此时我们把这些元素拆出来，最多有三个$$i$$级的元素，爆力重构即可。

-----

合并太复杂啦，先咕咕咕。