---
layout: post
title: 润和琳墩串
subtitle: /dk
tags: 字符串
---

对于一个串$$s$$，定义它的一个run(顶天立地串)是它的一个子串$$s_{l,...,r}$$和这个子串的一个周期$$p$$的二元组(一般记作$$(l,r,p)$$)，满足$$2p\leq r-l+1$$，并且这个子串是极长的具有周期$$p$$的子串。定义它的指数是$$\frac{r-l+1}{p}$$。一个串的runs是所有run的集合。

显然每个包含非平凡整周期的子串都属于一个run，一会会在重串的部分讨论这些。

**结论(the runs theorem)** 一个串的run的个数不到$$n$$，它们的指数和最多是$$3n-3$$。

**证明** 很复杂。略。

-----

lyndon串定义为字典序小于任何一个自己之外的后缀的串。显然等价于严格小于任何一个自己之外的循环同构的串。注意全是a的串不是lyndon串，因为它的后缀都比它小。具有非平凡周期的串总不是lyndon串。

lyndon串的作用是

**定理1(lyndon串的拼接)** 对于lyndon串$$a,b$$，如果$$a<b$$，那么$$ab$$也是一个lyndon串。

**证明** 显然。

lyndon分解指的是把一个串分成若干lyndon串，并且这些lyndon串的字典序递减。duval算法用于做这个。

先写几个结论。

**定理2** 对于任意串，lyndon分解存在且唯一。

**证明** 存在 : ~~赵神赢0531。~~考虑先让分解的每一部分都是单字符，然后每次合并字典序不对的两个，归纳可以知道每部分还是lyndon串，并且只能合并有限次。

唯一 : 如果存在两种方案，找到其中第一个不同的部分，那么其中一个是另一个的前缀，而另一个多出来的部分就无了。

于是我们知道，根据这个存在性的方式，不管按照什么顺序合并，都可以得到唯一的lyndon分解。

**定理3** lyndon分解中，第一部分是最长的lyndon前缀，最后一部分是最长的lyndon后缀。

**证明** 如果它不是最长的，那么可以继续接。

**定理4** lyndon分解的最后一部分是字符串的最小后缀。

**证明** 如果它不是，那么设它位于第$$i$$部分$$w_i$$中，则它比$$w_i$$要大，而根据lyndon分解的定义，$$w_i$$比最后一部分要大。

对于一个串，定义它的lyndon数组$$\mathrm{LA}$$，其中$$\mathrm{LA}_i$$是后缀$$i$$的最长lyndon前缀长度。

-----

接下来我们描述求一个串的lyndon分解的dvual算法，以及求lyndon数组的算法。

-----

duval算法通过不断求出串的最长lyndon前缀来求出lyndon分解。

**引理1** 设$$w=u^ku^\prime a$$，其中$$u$$是lyndon串，$$a$$是一个字符，$$u^\prime$$是$$u$$的极长前缀(可能为空)，也就是向后加入$$a$$的话则不再是$$u$$的前缀。设$$u$$中$$u^\prime$$之后的字符是$$c=u_{\vert u^\prime+1}$$。则

 - 如果$$a>c$$，那么$$w$$是一个lyndon串。

 - 如果$$a<c$$，那么以$$w$$为前缀的串的最长lyndon前缀必然是$$u$$。

**证明** 很直接。

 - 如果$$a>c$$，那么显然。

 - 如果$$a<c$$，那么显然。

duval算法的过程是，初始化$$u^k:=u^\prime:=\epsilon$$，每次向$$u$$的最后添加一个字符$$a$$，最后加入一个比任何字符小的结束字符。接下来讨论 : 

 - 如果$$a=c$$，那么扩展一步，也就是把$$a$$加入$$u^\prime$$的最后，如果此时$$\vert u^\prime\vert=\vert u\vert$$则$$k:=k+1,u:=\epsilon$$。

 - 如果$$a>c$$，那么我们做$$u:=u^ku^\prime a$$。

 - 如果$$a<c$$，那么我们往lyndon分解中放$$k$$个$$u$$，并跳到$$u^\prime$$的开头处重新开始。

每次往前跳的长度不超过这一次处理掉的部分的长度，所以复杂度是线性。

-----

然后是求lyndon数组的算法，我不是很知道它是否有一个名字。

我们从后往前扫，维护当前后缀的lyndon分解，每次插入一个字符，并爆力尝试向后合并。合并只会发生$$n-1$$次，于是我们将问题转化为$$O(n)$$次比较两个子串，使用sa-is可以做到线性，简单做法是二分hash。

一个结论是，两个相邻lyndon子串的字典序可以直接比它们的后缀，因为$$a<b\Leftrightarrow ab<b$$。这可以让代码变得更简单。

如果你不喜欢duval算法，可以直接用这个多$$\log$$算lyndon分解。看起来它至少比sa快。

-----

一个run $$(l,r,p)$$中任意一个长$$p$$的子串被称为它的一个root。我们找到一个root $$s_{l,...,r}$$之后，就可以求$$s_{l,...},s_{r+1,...}$$的lcp找到这个run的右端点，同理可以找到这个run的左端点，这可以用sa-is做到线性，当然简单做法是二分hash。

一个run的root，如果同时是lyndon串，那么它称为这个串的lyndon root。显然lyndon root存在且唯一。lyndon root的性质在于它们的数量很少，并且我们可以快速找到它们，从而快速找到包含它们的runs。

一般的字典序$$<_0$$是$$a<b,b<c,c<d$$这样的，定义反的字典序$$<_1$$是$$a>b,b>c$$这样的，并且用于标记结束的那个字符是最大的。设正反字典序下的lyndon数组分别是$$\mathrm{LA}_0,\mathrm{LA}_1$$。

**定理5** 对于每个$$i$$，正反字典序意义下的正反lyndon数组$$\mathrm{LA}_{0,i},\mathrm{LA}_{1,i}$$中恰有一个是$$1$$。

**证明** 考虑从$$i$$开始的极长的全是相同字符的段，设这一段后面的字符是$$s_j$$，那么如果$$s_i<_0 s_j$$，则根据duval算法那里的引理1，我们知道$$\mathrm{LA}_{0,i}=1$$，而$$\mathrm{LA}_{1,i}\geq 2$$。反之亦然。

**定理6** 对于一个run $$(l,r,p)$$，设$$f$$满足$$s_{r+1}<_f s_{r+1-p}$$，那么它的lyndon root由$$\mathrm{LA}_{f,l}$$给出。

**证明** 还是根据duval算法那里的引理1直接可得。

也就是说，所有的lyndon root都是某个lyndon数组中给出的非平凡lyndon串。于是根据前面的东西，我们可以$$O(n\log n)$$求出runs。

-----

根据lyndon串的拼接，我们定义一个lyndon串$$w$$的标准分解是$$w=uv$$，其中$$v$$是$$w$$字典序最小的真后缀，容易证明$$u,v$$都是lyndon串。

一个lyndon串的标准分解和它的标准分解的分解和......构成了一棵树，称为lyndon树。

咕。

-----

平方串定义为存在一个周期是长度的一半的串。

本原平方串定义为最小周期恰好是长度一半的串。所以它的子串都不是平方串。

**引理2** 如果$$u,v,w$$满足$$uu$$是$$vv$$的前缀，$$vv$$是$$ww$$的前缀，且$$uu$$是本原平方串，那么$$\vert u\vert+\vert v\vert\leq\vert w\vert$$。

**证明** 不会。

**结论** 本原平方串只有$$O(n\log n)$$个。

**证明** 根据引理2，对于每个左端点，本原平方串的长度从小到大排序之后，增长速度至少是fib数列。

**结论** 本质不同的本原平方串数量是$$O(n)$$。

**证明** 我们在每个本原平方串的最右一次出现处统计它。对于每个左端点，如果有三个本原平方串$$uu,vv,ww$$，那么$$uu$$在$$ww$$中出现了两次，所以只有最长的两个可能是最右的出现。

为了找到所有本原平方串，可以先计算runs，对于每个run $$(l,r,p)$$，$$s_{l,...,r}$$中长$$2p$$的串都是本原平方串。根据本原平方串的数量，我们知道

$$
\sum_{(l,r,p)}(r-l+1-2p+1)=O(n\log n)
$$

。