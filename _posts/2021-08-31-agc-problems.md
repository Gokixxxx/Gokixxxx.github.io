---
layout: post
title: AGC选㗅
subtitle: fuck
tags: 题选做 atc
show: true
---

远古ARC(058~103)做完了，咕咕咕结束了，原坑 AGC数数题，但是反正要刷穿不如直接全做了。

打开AGC，从上往下做。简单题可能略过。

-----

AGC001B : 你发现这是一个类似于辗转相除的过程，所以就除就行了。存在直接用gcd算答案的方法，不过我不会推。

-----

AGC001C : 看起来好像有点好玩。首先直径上的点是一定要被删的，但是我们删哪一边呢?

不知道，但是我们可以连一条边表示两个点不共存。所以做法就是直接求出到一个点距离$$>k$$的点，爆力连边然后跑最大独立集。

最大独立集显然不行，如何优化?

这个是不是二分图?看起来不是。

这个有啥性质?你发现没有传递性，那还能有啥呢/yun

补图?最大独立集可以转为补图最大团，然后补图就是每个点连到一个邻域，这个有啥性质啊......算了吧，换个想法。

直径总是跟center相关，我们可以枚举一个center，然后保留到它距离不超过$$\frac{k}{2}$$的点，做完了。笑死我了。

-----

AGC001D : 考虑那个回文的条件说的是什么。我不知道（

考虑实际上说的就是我们根据这些回文的条件可以获得一组全部相等的条件，而回文的条件就是若干个 某两个字符相同。

考虑一个简单想法(反正我没想到)，你发现一个回文串和它shift一位拼起来会发生好玩的事情，比如说我知道$$[1,4]$$是回文，知道$$[2,5]$$是回文，那么就有$$1=4=3=2=5$$。所以说我们可以构造一个，$$b$$的第一项是$$a$$的第一项$$-1$$，最后一项则是$$+1$$，中间是一样的。

诶我们还没考虑奇回文。如果$$[1,5],[2,6]$$是回文，那就有$$1=5=3$$，诶推不动了/yun

这是为什么?从本质上来说，一共有六个数，但是长为五的回文串只确定两个等价关系，所以一共只有四个等价关系，连不起来。

那么也就是说奇数必须跟偶数贴在一起，比如$$[1,5],[1,4]$$是回文，那就有$$5=1=4=2=3$$，$$5$$是可以和后面接起来的。所以如果奇数不超过两个，我们就把一个奇数放在最前面，另一个奇数(或者某个偶数)放在最后面，然后按照上面的方法构造即可。

-----

AGC001E : 来好玩的了。数数题，虽然不够数数。

先变成有序对并且可以相同，最后减去自己和自己再除一个$$2$$即可。

你发现值域很小，直觉是复杂度是$$O(n\log n+v^2)$$。

考虑那个式子是什么，它就是$$\frac{(a_i+a_j+b_i+b_j)!}{(a_i+a_j)!(b_i+b_j)!}$$，所以我们枚举$$a_i+a_j$$和$$b_i+b_j$$，目标就变成算有多少对满足$$a_i+a_j=x,b_i+b_j=y$$。这个看起来也很困难/jk

算多少对满足$$a_i+a_j=x$$是简单的，只需要法法塔就好了。这样的话这个就是二维卷积，虽然可以转化成普通卷积，但是4e6的范围还是受不太了。

还是来点神仙做法吧。考虑怎么分离$$i,j$$，可以使用范德蒙德卷积，看起来更好的方法是使用它的一个对称的变形$$\binom{a+b}{c+d}=\sum\limits_{i=0}^k\binom{a}{c+i}\binom{b}{d-i}$$，于是我们得到

$$
\sum_{k=0}^{v}\left(\sum_{i=1}^n\binom{a_i+b_i}{a_i+k}\right)\left(\sum_{j=1}^n\binom{a_j+b_j}{a_j-k}\right)
$$

那么问题变成怎么对$$k$$从$$-v$$到$$v$$，求$$f(k)=\sum_{i=1}^n\binom{a_i+b_i}{a_i+k}$$。

考虑$$a_i+b_i$$和$$a_i+k$$都很小，于是我们考虑每个$$i$$对哪些$$f$$有怎样的贡献。容易发现每个$$i$$的贡献从$$b_i$$开始，可以认为一直延伸到无穷处(因为正的下指标不需要边界，但是负的需要)。

为了使用OGF，我们先给$$f$$ shift $$v$$位，这样就避免负的下标了。

考虑$$\binom{a_i+b_i}{a_i+k}$$在$$k=-a_i,-a_i+1,...$$处的值的OGF(当然也shift $$v$$位)，它就是$$z^{v-a_i}(1+z)^{a_i+b_i}$$，所以答案的OGF即为

$$
A(z)=\sum_{i=1}^nz^{v-a_i}(1+z)^{a_i+b_i}
$$

。注意到乘$$(1+z)^{a_i+b_i}$$是容易的，所以我们枚举$$a_i+b_i$$，此时对应的所有$$z^{v-a_i}$$加起来得到一个多项式(这也是为什么我们不枚举$$v-a_i$$，因为$$(1+z)^k$$们加起来得到的多项式不容易快速计算)，可以爆力求出它在$$0,...,2v$$的点值，然后爆力卷上$$(1+z)^{a_i+b_i}$$加入答案即可。

啊你问怎么卷?卷$$1+z$$就是前缀和，卷$$(1+z)^k$$就是$$k$$阶前缀和，直接组合数算出每个数被前面每个数贡献多少次，然后拆一下递推即可。

另一个做法是这个式子具有非常明确的组合意义，也就是从$$(0,0)$$走到$$(a_i+a_j,b_i+b_j)$$的方案数。注意到它等价于从$$(-a_i,-b_i)$$走到$$(a_j,b_j)$$的方案数，所以我们就完成了分离，并且可以用一个dp直接统计答案。

-----

AGC001F : 好复杂。

先看看逆排列上这个操作是否有更加简单的形式，你发现它变成了，对于两个相邻的数，如果差至少是$$k$$就可以交换。看起来确实更简单了?

考虑此时最小化字典序变成了什么。最小化第一位，等价于最小化逆排列的$$1$$的位置。

所以我们要尽可能把$$1$$往前换。如果换着换着遇到了一个$$k$$以内的数，也就是不能和$$1$$换的数，那么我们只能尝试把这个数往前换，尽可能换到靠前的位置再回来处理$$1$$，这样贪心的正确性在于操作可逆。

注意到这个过程中可能进行一共$$n^2$$次交换，所以我们需要一个数据结构来维护交换的过程，平衡树即可。

存在进一步转化的更简单做法。考虑如果满足 不能换的都没换 这个限制，就一定合法，而不能换的就是差$$\leq k$$的。所以我们给差$$\leq k$$的对，小的向大的连有向边，表示顺序，然后问题变成求一个拓扑序，先最小化$$1$$的位置，再最小化$$2$$的位置......

这个看起来好复杂啊，考虑一个递推，我们设$$dp(i)$$表示$$i$$最小出现在哪，那么实际上$$dp(i)=1+\max\limits_{j\rightarrow i}$$，可以用线段树维护。不过这是错的，因为我们需要把别的点也插进来/jy

这条路看起来不是很能走通，不过我们可以换个方向。注意到最小字典序拓扑序是容易的，于是我们考虑把图从逆排列转化回原排列，也就是对图的编号取逆排列得到原排列，这样问题就变成最小字典序拓扑序了。

吗?没有，想一想你发现并不能这么做。

考虑一个普及组贪心想法，这等价于最大化这个拓扑序反过来的字典序。感性理解一下，这个正确性在于，我们需要尽可能把大的放在后面，这样它们就不会把小的憋在后面。

所以我们只需要取反图，然后就变成最小字典序拓扑序了。用线段树支持找出所有$$0$$并赋为inf，这里全是正的所以维护最小值即可；堆支持查询最大的点。

-----

AGC002C : 想了五分钟，发现时间倒流就做完了。

-----

AGC002D : 二分一波，然后就变成可以走到Kru重构树上的两棵子树，这个可以倍增搞掉。可以走到的点数就看两棵子树是不交还是包含来算即可。

可以把二分换成倍增砍去一个$$\log$$。

-----

AGC002E : 注意题意是吃最后一个糖的人输了。不过实际上没啥区别（

考虑从大到小排序，那么操作一就是砍去左边，操作二就是砍所有的，你发现如果看成平面上的一排柱子，第$$i$$个高度是$$a_i$$，那么就好像可以选择把$$x,y$$轴向右/上移动，谁移了一步恰好把整个图形移出第一象限，谁就赢了。

考虑两轴的交点，你发现等价于可以把这个交点向右/上移动，移到边界上就输了。

考虑这个点在不同的地方的胜负情况。第一层(最外一层)当然是先手必胜，然后第二层所有向外凸出的拐角处的那些点是先手必败的，因为只能转移到先手必胜的位置。这些点左边和下边是先手必胜的，依此类推。

画一画，你发现两个性质 : 

 - 一个位于第二层点的胜负只和它到右/上边界距离的奇偶性相关

 - 一个位于第二层的点的胜负和它左下方一条线上所有点的胜负相同

。第二个的证明是容易的，假如它是先手必败的，那么它左边和下边是先手必胜的，那么它左下就是先手必败的。假如它是先手必胜的，意味着它左边或者上边是先手必败的，那么这个先手必败的左下方都是先手必败，所以这个先手必胜左下方也都是先手必胜。

所以我们只需要考虑$$(0,0)$$右上方位于第二层那个点，到右/上边界距离的奇偶性。排序扫即可。

存在线性做法。考虑即使没有排序，只要找到了那个点在哪一列，到右/上边界的距离都是可以简单地线性完成的，所以问题是找那一列，也就是$$\mathrm{rank}(a_i)+1>\mathrm{suc}(a_i)$$的第一列，这里的$$\mathrm{rank}$$是从大到小排的，$$\mathrm{suc}(a_i)$$是序列中不比$$a_i$$大的最小的数。当然为了避免数值相同，我们一律以下标为第二关键字即可。

二分这个$$i$$的$$\mathrm{rank}$$，使用`nth_element`求出它的$$\mathrm{suc}$$也就是$$\mathrm{kth}(mid+1)$$，然后判断即可。`nth_element`会自动帮我们进行划分，再求的时候容易减半，于是复杂度是线性。更好的方法是直接把这个二分和`nth_element`的划分过程结合起来，这需要自己实现一个，但是它并不复杂只是比较麻烦。我不理解严格线性kth，不知道它能否这样使用。

-----

AGC002F : 真正的AGC数数题，终于见面了（

如果没有染白大家都会算!

如果有染白，一种最终的序列就可以对应多种排列了。如何去重?

先考虑两个排列什么时候会算重。如果它们除了最后被染白的部分都相同，只有染白了的部分做了某些交换，那就会算重交换的方案次。注意到这个方案是难以计算的，所以这条路走不通。

考虑判定什么样的序列是可以搞出来的。容易发现这是一个类似括号匹配的过程，它要求每个颜色的球第一次出现的时候，前面都有充足的白球作为这个颜色失去的真正的第一次出现。

那么我们给每种颜色第一次出现赋权值$$-1$$，白球赋权值$$1$$，问题变成所有的前缀和都为正。容易想到一个dp，设$$dp(i,j,k)$$表示填了$$i$$个位置，已经有$$j$$个颜色出现了一次......你发现转移需要记这些颜色分别还剩多少球，因为题目要求每种颜色恰好$$k-1$$个。这个也行不通了。

换个决策顺序，我们每次往序列里填一个颜色的所有$$k-1$$个球。设$$dp(i,j)$$表示已经填了$$i$$个白球和$$j$$个别的颜色的球的方案数，那么每次可以选择 : 

 - 填一个白球，这会使得......草?你发现这需要记一车东西，所以我们并不能这么决策。考虑一些别的决策方法。

考虑左边第一个空位放什么。如果放白球，那么啥事没有；如果放别的颜色的球，我们就组合数选出剩下的位置即可。有$$dp(i,j)=dp(i-1,j)+\binom{nk-i-(j-1)(k-1)-1}{j-2}dp(i,j-1)$$。

-----

AGC003B : 容易想到网络流，但是这个题的限制并不能用网络流表述。

考虑了一下神仙做法线性规划对偶定理，发现不行。

那还是老老实实贪心吧（

考虑硬贪，我们先把每个自己跟自己搞到$$2$$以内，然后从左往右直接进行相邻的配对。注意到这样可能出小问题(但是样例卡不掉，毒瘤出题人)，也就是像1 2 1这样的会被搞成1 0 1你就没了。所以我们需要还是从左往右扫，不过先贪心配相邻的，再膜$$2$$。

-----

AGC003C : 草?

你发现这跟ARC102F几乎一致，这个操作2的性质就是它可以给奇数位置排序，偶数位置排序，但是并不能交换奇数和偶数位置。排好之后算逆序对即可。

呃好像不是。考虑每次操作1可以把一个奇数搞到偶数位，一个偶数搞到奇数位，那么我们先用若干次操作1换这些，剩下的可以直接用操作2排，这就对了。

-----

AGC003D : 如果分解了就好说了，我们只需要次数膜$$3$$分成若干等价类，然后$$3$$进制$$\mathrm{xor}$$意义下相反的等价类不能共存，取大小更大的即可。

但是全分解是困难的。考虑我们先给每个质因子次数膜一个$$3$$，这个复杂度是$$O(n\sqrt[3]{n}/\log n)$$，还挺快。然后直接分等价类，问题是怎么找相反的。

不会找/yun，我们再分解一下吧。拿$$\sqrt[3]{v}$$以内的质数进行分解，复杂度还是$$O(n\sqrt[3]{n}/\log n)$$，接下来每个数还剩不超过两个质因子没有被找到。考虑我们如果把数分成剩下$$1,p,pq,p^2$$的四类，那么$$pq$$那一类必然没有贡献，$$p$$可能和$$p^2$$配对，$$1$$内部可能配对。第一类可以用MR和开根搞定，第二类已经分解完了可以直接找。做完了。

-----

AGC003E : 可 持 久 化 平 衡 树

注意到数组长度可以缩小，而如果不考虑缩小的话......问题也很复杂。fuck。

不管怎么样还是考虑避免缩小吧。先增大后缩小的话，显然等价于直接增大到缩小后的长度，所以用栈筛去无用的增大，也就是后面被缩掉了的增大即可。

然后问题变得简单起来。考虑我们每次加入的部分是什么，你发现我们可以递归下去，问题会变成查询每次操作之前的整个串和一个前缀每个字符的出现次数。

整个串就是我们要求的东西，问题是怎么把一个前缀做掉。你发现一个前缀会变成若干个之前的整个串和之前的一个前缀，这个影响还是取膜，所以每层会增加一个查询。

注意到取膜具有非常好的性质 : 如果膜掉了，被膜的数至少减半。所以每个前缀的查询只会被膜$$\log$$次，所以我们可以通过某种方法，比如线段树找到所有这样的查询爆力给它们膜。这部分是俩$$\log$$，可以使用高效堆做到一个$$\log$$。

然后问题是怎么往上推，我们只需要把这个过程倒过来就好了。

一个更好写的做法是，我们根本不需要倒过来，只需要把贡献一起扔下去。可以想象最后得到若干个前缀加(呃大概是?)，差分-前缀和即可。

-----

AGC003F : 考虑两个一级分形拼起来会发生什么事情。

~~优质解答 : 我不知道~~ 考虑如果只有一条横线会发生什么。你发现只有左边和右边都是黑色，接起来才可能减少连通块数。

考虑对于一般的图，我们计算一级分形横着重复两次会少几个连通块(也就是比起一级分形连通块数的两倍少多少)，记为$$c_1$$，竖着类似计算$$c_2$$。记一级分形黑格数为$$t$$。

注意到题目保证了一级分形的连通性，这说明$$c_1,c_2$$都只可能是$$0,1$$，并且给出了两个特殊情况 : $$c_1=c_2=0$$，此时答案就是$$t^{k-1}$$；$$c_1=c_2=1$$，此时答案就是$$1$$。

于是我们只需要考虑横着连起来减少的连通块，也就是$$c_1=1,c_2=0$$的情况，竖着连起来是一样的。问题看起来简单多了。

考虑一级分形横着重复三次会减少多少个连通块，你发现实在就是$$2$$。也就是说有多少对横向相邻的黑格，就减去多少，也就是说最后的答案就是把每个一级分形看成一个黑格之后，$$t^{k-1}$$减去横向相邻的黑格的对数。

两个分形横着拼起来会增加一些横向相邻的黑格，也只有这种方式会增加横向相邻的黑格。

我们求出两个一级分形横着拼起来增加的对数$$r_1$$(实际上这个强转bool等于$$s_1$$)，设一级分形里面横向相邻黑格的对数是$$s_1$$，那么容易知道$$s_2=ts_1+s_1r_1$$，同时容易知道$$s_n=ts_{n-1}+s_1r_{n-1},r_n=r_1^n$$。矩阵快速幂即可。

-----

AGC004A : 尝试从每一维中间切开。

-----

AGC004B : 考虑我们可以在shift的时候在不同的时刻加入那些要shift不同次数的，所以枚举shift多少次，问题变成若干个区间$$\min$$加起来。单调队列就做完了。

-----

AGC004C : 正叔给了一个不依赖边界为空性质的，但是那个太复杂，考虑我们奇数行在第一个涂黑，偶数行在第二个涂黑，第一个涂黑左边，第二个涂黑右边，这样就赢麻了。

-----

AGC004D : 内向基环树。

考虑解的结构。如果$$1$$不在环上，那就没救了。如果环长度不是$$1$$，那也没救了，因为环转一圈还是环。于是我们知道，环必然是$$1$$的自环，并且树的高度不超过$$k$$。

现在如果$$1$$在环上，我们把$$1$$连向自己，直接得到一棵树，于是可以直接做。

怎么直接做?问题相当于我们要选若干个点连到$$1$$，要求深度足够小，于是可以直接能不连就不连来贪心。

-----

AGC004E : 看起来比较复杂/jk

考虑这个东西只跟两维上移动距离的最大值和最小值有关，所以我们枚举这四个值，就得到一个$$O(n^5)$$做法。

考虑优化，你发现我们不一定非要$$O(n)$$判，可以用前缀和预处理然后$$O(1)$$判，所以你就$$O(n^4)$$了，注意空间不大需要开short。极限过题?实际上并没有，还挺快的。

-----

AGC004F : 看起来非常简单，但完全不简单/jk

首先奇数肯定无解，因为这个操作不改变异或和。

考虑树怎么做，是不是我们随便取一个根，然后自底向上做。一个点可能有些儿子没有被搞成白的，那么我们就先操作一个儿子和它......遇到了僵局。

考虑这个操作是操作相邻的一对，于是我们黑白染色。这个对于偶环树是可行的，但是奇环树是不行的，不过我们先不管这些，毕竟可以先猜一个奇环树压根不行（

我们用一个经典的网络流trick，认为黑点一开始都是黑的，白点一开始都是白的，目标是把白点变成黑的，黑点变成白的，每次操作就变成了交换两个相邻的点的颜色。这个的好处是去掉了相同才能操作的限制。

所以我们知道，如果黑白点个数不相等，那就无解了。除此之外猜测一定有解。

树的话，考虑还是自底向上做，假设一个点是黑点，那么儿子都是白点。现在有一些儿子是白色的，那么就需要把它们换上来，然后留下一个，剩下的换给父亲往上走。当然也可能出现子树里有些黑点不是黑的，那我们就把一棵子树多出来的换到另一棵子树里。所以最后答案就是每个点子树内黑白点个数差之和，因为你一定要换这么多次换出子树或者换入子树。

偶环树的话，考虑这是一个环上的移动问题，可能有人见过，这是 均分纸牌 的环版本。结论很经典，我们这里来推导一下。

考虑我们只需要随便断一条边，枚举上面有多少黑色过去就好了，当然这个次数可以是负的表示反向通过。由于最优解上这条边一定有一个通过的量，所以随便断一条是正确的。

序列的均分纸牌是容易的，因为我们从一边开始做，就只有不得不换了。最终答案是每一个点子树内黑白点个数差之和。

考虑总代价，假设这些子树内黑白点个数差分别是$$a_1,...,a_k$$，你在$$1,n$$之间移动了$$x$$个，那么贡献会是

$$
\vert a_1-x\vert+\vert a_2+a_1-x\vert+\vert a_3+a_2+a_1-x\vert+...+\vert a_k+...+a_1\vert
$$

你发现这好像是说，我们求前缀和，然后只考虑前$$k-1$$项，那么贡献是$$x$$在数轴上到这些点的距离和(再加上最后一项，不过它是$$0$$所以没关系)，易知取中位数最优。

那么问题是如何证明奇环树无解。你画了一个奇环树，发现它有解/fad

如果对奇环树也黑白染色，环上会有一条边端点同色。你发现如果我们对这条边操作，效果会变成如果它们同色，同时改变这两个点的颜色，不同色则不能操作，于是我们可以用这个来改变黑白色的数量，如果黑白之差是偶数就可以这么调。同时它没有交换的作用，于是我们也不用破环成链了，直接按照树做就好了。

题解的偶环树做法好像和我略有不同，不过没什么关系，我相信我的正确性，虽然我没写。

-----

AGC005A : 中文题面搞什么（

用栈维护串即可。

-----

AGC005B : 考虑每个数的贡献，是一个矩形，单调栈即可。

-----

AGC005C : 考虑最大的一定是直径端点，这个值是直径长度，最小的一定是center(只有一个)或者center所在边的端点(有两个)。

考虑如果直径唯一，也就是直径端点只有两个，那么我们把直径搞出来，所有的贡献一定在直径上取到，而直径上的$$a$$值就是从center出发递增。

如果我们可以搞出直径，剩下的点就一定可以了，因为它们总能挂在直径上某一个位置。判断是否足以搞出直径即可。

-----

AGC005D : 这种排列计数看起来很不可做/fad

容斥一波，然后钦定若干个位置满足$$p_i=i\pm k$$，剩下的随便排了。

现在问题是有多少种方法选出这些被钦定的$$p_i$$，因为$$i\pm k$$们可能是会重复的。

给下标按照膜$$2k$$分组，那么每组相邻的两项都钦定了就会重复，而组之间是独立的。

对于每一组分开dp，设$$dp(i,j,0/1)$$表示考虑前$$i$$个，钦定了$$j$$个，第$$i-1$$个没有/有钦定的方案数，最后把所有的$$dp$$卷起来(分治的话复杂度应该很对)，就得到全局选出被钦定的$$p_i$$的方案数。做完了。

看起来非常正确，但是跟题解做法好像不太一样/ll

-----

AGC005E : 感觉思维难度远高于F/jy

考虑什么情况下会永远进行，如果一条红边的端点在蓝树上距离至少是$$3$$，那么当Bob冲过来的时候，Alice只要反复横跳就好了。

如果没有这种情况，每条红边要么和蓝边重合，要么和两条蓝边构成一个三角形。

这说明什么?如果Bob想把Alice摁在一棵蓝子树里，Alice不管怎么借助红边跑，Bob都可以向上一步截住Alice，所以Bob就可以把Alice摁死。

现在Alice只能选择往哪棵子树走了。以Bob的起点为根把树拎起来，那么Alice先尽可能向上走，然后如果可以走到一个 无 限 之 环 那就冲过去，否则走向最深的儿子即可。

足够厉害/fad

-----

AGC005F : 不得不想到法法塔（

为了叙述简便，定义一个选点方案的权值是包含它的最小连通块大小，也就是它的斯坦呐树大小。

考虑简单dp，设$$dp(u,i)$$表示在$$u$$子树里选了$$i$$个点，并且强制选$$u$$的所有方案权值之和，那么合并两棵子树就是笛卡尔积，但是这里不是乘而是加!

怎么办呢，我们可以取一个$$\exp$$，然后就做完了。

吗?2e5可还行，不过这里是卷积，我们可以考虑优化。

然而这是树卷积，好像很难优化/cy

考虑换个做法，我们统计每个点在多少种方案里，这个用$$2^n$$减去只选在每个子树里的方案数之和即可。

然而这里有一个点数，导致复杂度还是很高，写个式子?

$$
ans_k=\sum_u\left(2^n-\sum_{u\text{的子树}i}\binom{s_i}{k}\right)
$$

这个能否法法塔?化一下 : 

$$
\begin{aligned}
ans_k&=n2^n-\sum_{\text{任意点的子树}i}\binom{s_i}{k}\\
\sum_{\text{任意点的子树}i}\binom{s_i}{k}&=\sum_{\text{任意点的子树}i}\frac{s_i!}{k!(s_i-k)!}
\end{aligned}
$$

考虑设$$c_i$$为$$s_j=i$$的$$j$$个数，那么就变成

$$
\sum_ic_i\frac{i!}{k!(i-k)!}
$$

忽略$$k!$$，即为差卷积。

注意这题要呐塔塔的话，据说原根是$$5$$。

-----

AGC006B : 看到中位数，想到转01，于是问题变成有若干-1,0,1，要求最后剩下一个0。

然后呢?考虑一个非常扯的事情，我们只要填一发-1,0,1，就可以保证最上面得到0，因为这样一来左边永远$$\leq 0$$，右边永远$$\geq 0$$。

-----

AGC006C : 非常经典。对称点是线性的，根据期望的线性性，我们可以把它拆开，于是就变成一类cf上做奇怪操作的题，差分一下就做完了。

-----

AGC006D : 经典再现。二分转01，然后连续段会一步一步侵蚀交替段，看哪个连续段离的最近即可。这个比那个经典题要弱?

呃考虑如果有两个不同色的连续段离的一样近怎么办，你发现这就没救了，但是这种情况不可能出现，因为中间交替段长度也是奇数。

-----

AGC006E : 看起来好鬼。

注意到操作是隔一个的，于是还是对列黑白染色。如果出现把黑色换到白色，那就是不可能的。

每一列是什么不会变，只会变上下的顺序，所以如果一列里的数不对就没救了。把每一列压成一个数，那么可以认为这个操作是把相邻三列取负，并交换两边的位置。

现在问题变成，有一个带符号的排列，每次可以把相邻三个数取负，并交换两边，问能不能排序成全正的。

考虑还是拿必要凑充分。交换两边是经典的，如果只考虑黑色，那么每次要么减少一对逆序对，要么增加一对，并且会给白色的符号取反。所以一个必要条件是，逆序对数的奇偶性和白色的符号对应。猜测这是充要的。

写了一发你发现过了。感觉这个题完全弱于ARC102F。

-----

AGC006F : 看起来更鬼了。

你发现这个像是某种 两个维度之间的传递性，听起来很离谱。

如果我们把两个维度拍成一个维度，也就是说经典的建图是建两排点，现在我们建一排点，而把$$(x,y)$$看成$$x\rightarrow y$$的有向边，那么这个就变得好像很简单了。

考虑一个弱连通块怎么做。这个非常神。

看到有向图三元环，想到三染色。我们要求每条边都是$$\text R\right\text G,\text G\right\text B,\text B\right\text R$$之一，那么如果可以这么染色，就可以把所有剩下的$$\text R\right\text G,\text G\right\text B,\text B\right\text R$$这样的边加进去。

如果不能这么染色呢?考虑如果点$$u$$被同时搞了两种颜色，那么$$u$$就可以自己连自己了，于是它又被搞第三种颜色，于是剩下的点不管是什么颜色都可以和$$u$$连边，这样每个点都可以是任意颜色，于是必然可以连成完全图。

做完了。足够厉害。

-----

AGC007A : 挑 战 哈 密 顿

搜就是了（

诶，好像可以直接走的啊（

-----

