---
layout: post
title: AGC选㗅
subtitle: fuck
tags: 题选做 atc
---

远古ARC(058~103)做完了，咕咕咕结束了，原坑 AGC数数题，但是反正要刷穿不如直接全做了。

打开AGC，从上往下做。简单题可能略过。

-----

AGC001B : 你发现这是一个类似于辗转相除的过程，所以就除就行了。存在直接用gcd算答案的方法，不过我不会推。

-----

AGC001C : 看起来好像有点好玩。首先直径上的点是一定要被删的，但是我们删哪一边呢?

不知道，但是我们可以连一条边表示两个点不共存。所以做法就是直接求出到一个点距离$$>k$$的点，爆力连边然后跑最大独立集。

最大独立集显然不行，如何优化?

这个是不是二分图?看起来不是。

这个有啥性质?你发现没有传递性，那还能有啥呢/yun

补图?最大独立集可以转为补图最大团，然后补图就是每个点连到一个邻域，这个有啥性质啊......算了吧，换个想法。

直径总是跟center相关，我们可以枚举一个center，然后保留到它距离不超过$$\frac{k}{2}$$的点，做完了。笑死我了。

-----

AGC001D : 考虑那个回文的条件说的是什么。我不知道（

考虑实际上说的就是我们根据这些回文的条件可以获得一组全部相等的条件，而回文的条件就是若干个 某两个字符相同。

考虑一个简单想法(反正我没想到)，你发现一个回文串和它shift一位拼起来会发生好玩的事情，比如说我知道$$[1,4]$$是回文，知道$$[2,5]$$是回文，那么就有$$1=4=3=2=5$$。所以说我们可以构造一个，$$b$$的第一项是$$a$$的第一项$$-1$$，最后一项则是$$+1$$，中间是一样的。

诶我们还没考虑奇回文。如果$$[1,5],[2,6]$$是回文，那就有$$1=5=3$$，诶推不动了/yun

这是为什么?从本质上来说，一共有六个数，但是长为五的回文串只确定两个等价关系，所以一共只有四个等价关系，连不起来。

那么也就是说奇数必须跟偶数贴在一起，比如$$[1,5],[1,4]$$是回文，那就有$$5=1=4=2=3$$，$$5$$是可以和后面接起来的。所以如果奇数不超过两个，我们就把一个奇数放在最前面，另一个奇数(或者某个偶数)放在最后面，然后按照上面的方法构造即可。

-----

AGC001E : 来好玩的了。数数题，虽然不够数数。

先变成有序对并且可以相同，最后减去自己和自己再除一个$$2$$即可。

你发现值域很小，直觉是复杂度是$$O(n\log n+v^2)$$。

考虑那个式子是什么，它就是$$\frac{(a_i+a_j+b_i+b_j)!}{(a_i+a_j)!(b_i+b_j)!}$$，所以我们枚举$$a_i+a_j$$和$$b_i+b_j$$，目标就变成算有多少对满足$$a_i+a_j=x,b_i+b_j=y$$。这个看起来也很困难/jk

算多少对满足$$a_i+a_j=x$$是简单的，只需要法法塔就好了。这样的话这个就是二维卷积，虽然可以转化成普通卷积，但是4e6的范围还是受不太了。

还是来点神仙做法吧。考虑怎么分离$$i,j$$，可以使用范德蒙德卷积，看起来更好的方法是使用它的一个对称的变形$$\binom{a+b}{c+d}=\sum\limits_{i=0}^k\binom{a}{c+i}\binom{b}{d-i}$$，于是我们得到

$$
\sum_{k=0}^{v}\left(\sum_{i=1}^n\binom{a_i+b_i}{a_i+k}\right)\left(\sum_{j=1}^n\binom{a_j+b_j}{a_j-k}\right)
$$

那么问题变成怎么对$$k$$从$$-v$$到$$v$$，求$$f(k)=\sum_{i=1}^n\binom{a_i+b_i}{a_i+k}$$。

考虑$$a_i+b_i$$和$$a_i+k$$都很小，于是我们考虑每个$$i$$对哪些$$f$$有怎样的贡献。容易发现每个$$i$$的贡献从$$b_i$$开始，可以认为一直延伸到无穷处(因为正的下指标不需要边界，但是负的需要)。

为了使用OGF，我们先给$$f$$ shift $$v$$位，这样就避免负的下标了。

考虑$$\binom{a_i+b_i}{a_i+k}$$在$$k=-a_i,-a_i+1,...$$处的值的OGF(当然也shift $$v$$位)，它就是$$z^{v-a_i}(1+z)^{a_i+b_i}$$，所以答案的OGF即为

$$
A(z)=\sum_{i=1}^nz^{v-a_i}(1+z)^{a_i+b_i}
$$

。注意到乘$$(1+z)^{a_i+b_i}$$是容易的，所以我们枚举$$a_i+b_i$$，此时对应的所有$$z^{v-a_i}$$加起来得到一个多项式(这也是为什么我们不枚举$$v-a_i$$，因为$$(1+z)^k$$们加起来得到的多项式不容易快速计算)，可以爆力求出它在$$0,...,2v$$的点值，然后爆力卷上$$(1+z)^{a_i+b_i}$$加入答案即可。

啊你问怎么卷?卷$$1+z$$就是前缀和，卷$$(1+z)^k$$就是$$k$$阶前缀和，直接组合数算出每个数被前面每个数贡献多少次，然后拆一下递推即可。

另一个做法是这个式子具有非常明确的组合意义，也就是从$$(0,0)$$走到$$(a_i+a_j,b_i+b_j)$$的方案数。注意到它等价于从$$(-a_i,-b_i)$$走到$$(a_j,b_j)$$的方案数，所以我们就完成了分离，并且可以用一个dp直接统计答案。

-----

AGC001F : 好复杂。

先看看逆排列上这个操作是否有更加简单的形式，你发现它变成了，对于两个相邻的数，如果差至少是$$k$$就可以交换。看起来确实更简单了?

考虑此时最小化字典序变成了什么。最小化第一位，等价于最小化逆排列的$$1$$的位置。

所以我们要尽可能把$$1$$往前换。如果换着换着遇到了一个$$k$$以内的数，也就是不能和$$1$$换的数，那么我们只能尝试把这个数往前换，尽可能换到靠前的位置再回来处理$$1$$，这样贪心的正确性在于操作可逆。

注意到这个过程中可能进行一共$$n^2$$次交换，所以我们需要一个数据结构来维护交换的过程，平衡树即可。

存在进一步转化的更简单做法。考虑如果满足 不能换的都没换 这个限制，就一定合法，而不能换的就是差$$\leq k$$的。所以我们给差$$\leq k$$的对，小的向大的连有向边，表示顺序，然后问题变成求一个拓扑序，先最小化$$1$$的位置，再最小化$$2$$的位置......

这个看起来好复杂啊，考虑一个递推，我们设$$dp(i)$$表示$$i$$最小出现在哪，那么实际上$$dp(i)=1+\max\limits_{j\rightarrow i}$$，可以用线段树维护。不过这是错的，因为我们需要把别的点也插进来/jy

这条路看起来不是很能走通，不过我们可以换个方向。注意到最小字典序拓扑序是容易的，于是我们考虑把图从逆排列转化回原排列，也就是对图的编号取逆排列得到原排列，这样问题就变成最小字典序拓扑序了。

吗?没有，想一想你发现并不能这么做。

考虑一个普及组贪心想法，这等价于最大化这个拓扑序反过来的字典序。感性理解一下，这个正确性在于，我们需要尽可能把大的放在后面，这样它们就不会把小的憋在后面。

所以我们只需要取反图，然后就变成最小字典序拓扑序了。用线段树支持找出所有$$0$$并赋为inf，这里全是正的所以维护最小值即可；堆支持查询最大的点。

-----

AGC002C : 想了五分钟，发现时间倒流就做完了。

-----

AGC002D : 二分一波，然后就变成可以走到Kru重构树上的两棵子树，这个可以倍增搞掉。可以走到的点数就看两棵子树是不交还是包含来算即可。

可以把二分换成倍增砍去一个$$\log$$。

-----

AGC002E : 注意题意是吃最后一个糖的人输了。不过实际上没啥区别（

考虑从大到小排序，那么操作一就是砍去左边，操作二就是砍所有的，你发现如果看成平面上的一排柱子，第$$i$$个高度是$$a_i$$，那么就好像可以选择把$$x,y$$轴向右/上移动，谁移了一步恰好把整个图形移出第一象限，谁就赢了。

考虑两轴的交点，你发现等价于可以把这个交点向右/上移动，移到边界上就输了。

考虑这个点在不同的地方的胜负情况。第一层(最外一层)当然是先手必胜，然后第二层所有向外凸出的拐角处的那些点是先手必败的，因为只能转移到先手必胜的位置。这些点左边和下边是先手必胜的，依此类推。

画一画，你发现两个性质 : 

 - 一个位于第二层点的胜负只和它到右/上边界距离的奇偶性相关

 - 一个位于第二层的点的胜负和它左下方一条线上所有点的胜负相同

。第二个的证明是容易的，假如它是先手必败的，那么它左边和下边是先手必胜的，那么它左下就是先手必败的。假如它是先手必胜的，意味着它左边或者上边是先手必败的，那么这个先手必败的左下方都是先手必败，所以这个先手必胜左下方也都是先手必胜。

所以我们只需要考虑$$(0,0)$$右上方位于第二层那个点，到右/上边界距离的奇偶性。排序扫即可。

存在线性做法。考虑即使没有排序，只要找到了那个点在哪一列，到右/上边界的距离都是可以简单地线性完成的，所以问题是找那一列，也就是$$\mathrm{rank}(a_i)+1>\mathrm{suc}(a_i)$$的第一列，这里的$$\mathrm{rank}$$是从大到小排的，$$\mathrm{suc}(a_i)$$是序列中不比$$a_i$$大的最小的数。当然为了避免数值相同，我们一律以下标为第二关键字即可。

二分这个$$i$$的$$\mathrm{rank}$$，使用`nth_element`求出它的$$\mathrm{suc}$$也就是$$\mathrm{kth}(mid+1)$$，然后判断即可。`nth_element`会自动帮我们进行划分，再求的时候容易减半，于是复杂度是线性。更好的方法是直接把这个二分和`nth_element`的划分过程结合起来，这需要自己实现一个，但是它并不复杂只是比较麻烦。我不理解严格线性kth，不知道它能否这样使用。

-----

AGC002F : 真正的AGC数数题，终于见面了（

如果没有染白大家都会算!

如果有染白，一种最终的序列就可以对应多种排列了。如何去重?

先考虑两个排列什么时候会算重。如果它们除了最后被染白的部分都相同，只有染白了的部分做了某些交换，那就会算重交换的方案次。注意到这个方案是难以计算的，所以这条路走不通。

考虑判定什么样的序列是可以搞出来的。容易发现这是一个类似括号匹配的过程，它要求每个颜色的球第一次出现的时候，前面都有充足的白球作为这个颜色失去的真正的第一次出现。

那么我们给每种颜色第一次出现赋权值$$-1$$，白球赋权值$$1$$，问题变成所有的前缀和都为正。容易想到一个dp，设$$dp(i,j,k)$$表示填了$$i$$个位置，已经有$$j$$个颜色出现了一次......你发现转移需要记这些颜色分别还剩多少球，因为题目要求每种颜色恰好$$k-1$$个。这个也行不通了。

换个决策顺序，我们每次往序列里填一个颜色的所有$$k-1$$个球。设$$dp(i,j)$$表示已经填了$$i$$个白球和$$j$$个别的颜色的球的方案数，那么每次可以选择 : 

 - 填一个白球，这会使得......草?你发现这需要记一车东西，所以我们并不能这么决策。考虑一些别的决策方法。

考虑左边第一个空位放什么。如果放白球，那么啥事没有；如果放别的颜色的球，我们就组合数选出剩下的位置即可。有$$dp(i,j)=dp(i-1,j)+\binom{nk-i-(j-1)(k-1)-1}{j-2}dp(i,j-1)$$。

-----

AGC003B : 容易想到网络流，但是这个题的限制并不能用网络流表述。

考虑了一下神仙做法线性规划对偶定理，发现不行。

那还是老老实实贪心吧（

考虑硬贪，我们先把每个自己跟自己搞到$$2$$以内，然后从左往右直接进行相邻的配对。注意到这样可能出小问题(但是样例卡不掉，毒瘤出题人)，也就是像1 2 1这样的会被搞成1 0 1你就没了。所以我们需要还是从左往右扫，不过先贪心配相邻的，再膜$$2$$。

-----

AGC003C : 草?

你发现这跟ARC102F几乎一致，这个操作2的性质就是它可以给奇数位置排序，偶数位置排序，但是并不能交换奇数和偶数位置。排好之后算逆序对即可。

呃好像不是。考虑每次操作1可以把一个奇数搞到偶数位，一个偶数搞到奇数位，那么我们先用若干次操作1换这些，剩下的可以直接用操作2排，这就对了。

-----

AGC003D : 如果分解了就好说了，我们只需要次数膜$$3$$分成若干等价类，然后$$3$$进制$$\mathrm{xor}$$意义下相反的等价类不能共存，取大小更大的即可。

但是全分解是困难的。考虑我们先给每个质因子次数膜一个$$3$$，这个复杂度是$$O(n\sqrt[3]{n}/\log n)$$，还挺快。然后直接分等价类，问题是怎么找相反的。

不会找/yun，我们再分解一下吧。拿$$\sqrt[3]{v}$$以内的质数进行分解，复杂度还是$$O(n\sqrt[3]{n}/\log n)$$，接下来每个数还剩不超过两个质因子没有被找到。考虑我们如果把数分成剩下$$1,p,pq,p^2$$的四类，那么$$pq$$那一类必然没有贡献，$$p$$可能和$$p^2$$配对，$$1$$内部可能配对。第一类可以用MR和开根搞定，第二类已经分解完了可以直接找。做完了。

-----

AGC003E : 可 持 久 化 平 衡 树

注意到数组长度可以缩小，而如果不考虑缩小的话......问题也很复杂。fuck。

不管怎么样还是考虑避免缩小吧。先增大后缩小的话，显然等价于直接增大到缩小后的长度，所以用栈筛去无用的增大，也就是后面被缩掉了的增大即可。

然后问题变得简单起来。考虑我们每次加入的部分是什么，你发现我们可以递归下去，问题会变成查询每次操作之前的整个串和一个前缀每个字符的出现次数。

整个串就是我们要求的东西，问题是怎么把一个前缀做掉。你发现一个前缀会变成若干个之前的整个串和之前的一个前缀，这个影响还是取膜，所以每层会增加一个查询。

注意到取膜具有非常好的性质 : 如果膜掉了，被膜的数至少减半。所以每个前缀的查询只会被膜$$\log$$次，所以我们可以通过某种方法，比如线段树找到所有这样的查询爆力给它们膜。这部分是俩$$\log$$，可以使用高效堆做到一个$$\log$$。

然后问题是怎么往上推，我们只需要把这个过程倒过来就好了。

一个更好写的做法是，我们根本不需要倒过来，只需要把贡献一起扔下去。可以想象最后得到若干个前缀加(呃大概是?)，差分-前缀和即可。

-----

AGC003F : 考虑两个一级分形拼起来会发生什么事情。

~~优质解答 : 我不知道~~ 考虑如果只有一条横线会发生什么。你发现只有左边和右边都是黑色，接起来才可能减少连通块数。

考虑对于一般的图，我们计算一级分形横着重复两次会少几个连通块(也就是比起一级分形连通块数的两倍少多少)，记为$$c_1$$，竖着类似计算$$c_2$$。记一级分形黑格数为$$t$$。

注意到题目保证了一级分形的连通性，这说明$$c_1,c_2$$都只可能是$$0,1$$，并且给出了两个特殊情况 : $$c_1=c_2=0$$，此时答案就是$$t^{k-1}$$；$$c_1=c_2=1$$，此时答案就是$$1$$。

于是我们只需要考虑横着连起来减少的连通块，也就是$$c_1=1,c_2=0$$的情况，竖着连起来是一样的。问题看起来简单多了。

考虑一级分形横着重复三次会减少多少个连通块，你发现实在就是$$2$$。也就是说有多少对横向相邻的黑格，就减去多少，也就是说最后的答案就是把每个一级分形看成一个黑格之后，$$t^{k-1}$$减去横向相邻的黑格的对数。

两个分形横着拼起来会增加一些横向相邻的黑格，也只有这种方式会增加横向相邻的黑格。

我们求出两个一级分形横着拼起来增加的对数$$r_1$$(实际上这个强转bool等于$$s_1$$)，设一级分形里面横向相邻黑格的对数是$$s_1$$，那么容易知道$$s_2=ts_1+s_1r_1$$，同时容易知道$$s_n=ts_{n-1}+s_1r_{n-1},r_n=r_1^n$$。矩阵快速幂即可。

-----

AGC004A : 尝试从每一维中间切开。

-----

AGC004B : 考虑我们可以在shift的时候在不同的时刻加入那些要shift不同次数的，所以枚举shift多少次，问题变成若干个区间$$\min$$加起来。单调队列就做完了。

-----

AGC004C : 正叔给了一个不依赖边界为空性质的，但是那个太复杂，考虑我们奇数行在第一个涂黑，偶数行在第二个涂黑，第一个涂黑左边，第二个涂黑右边，这样就赢麻了。

-----

AGC004D : 内向基环树。

考虑解的结构。如果$$1$$不在环上，那就没救了。如果环长度不是$$1$$，那也没救了，因为环转一圈还是环。于是我们知道，环必然是$$1$$的自环，并且树的高度不超过$$k$$。

现在如果$$1$$在环上，我们把$$1$$连向自己，直接得到一棵树，于是可以直接做。

怎么直接做?问题相当于我们要选若干个点连到$$1$$，要求深度足够小，于是可以直接能不连就不连来贪心。

-----

AGC004E : 看起来比较复杂/jk

考虑这个东西只跟两维上移动距离的最大值和最小值有关，所以我们枚举这四个值，就得到一个$$O(n^5)$$做法。

考虑优化，你发现我们不一定非要$$O(n)$$判，可以用前缀和预处理然后$$O(1)$$判，所以你就$$O(n^4)$$了，注意空间不大需要开short。极限过题?实际上并没有，还挺快的。

-----

AGC004F : 看起来非常简单，但完全不简单/jk

首先奇数肯定无解，因为这个操作不改变异或和。

考虑树怎么做，是不是我们随便取一个根，然后自底向上做。一个点可能有些儿子没有被搞成白的，那么我们就先操作一个儿子和它......遇到了僵局。

考虑这个操作是操作相邻的一对，于是我们黑白染色。这个对于偶环树是可行的，但是奇环树是不行的，不过我们先不管这些，毕竟可以先猜一个奇环树压根不行（

我们用一个经典的网络流trick，认为黑点一开始都是黑的，白点一开始都是白的，目标是把白点变成黑的，黑点变成白的，每次操作就变成了交换两个相邻的点的颜色。这个的好处是去掉了相同才能操作的限制。

所以我们知道，如果黑白点个数不相等，那就无解了。除此之外猜测一定有解。

树的话，考虑还是自底向上做，假设一个点是黑点，那么儿子都是白点。现在有一些儿子是白色的，那么就需要把它们换上来，然后留下一个，剩下的换给父亲往上走。当然也可能出现子树里有些黑点不是黑的，那我们就把一棵子树多出来的换到另一棵子树里。所以最后答案就是每个点子树内黑白点个数差之和，因为你一定要换这么多次换出子树或者换入子树。

偶环树的话，考虑我们随便断掉一条边仍然有解，问题就是哪一条边最优。考虑每一棵子树换出来的点数(比如你可以认为黑色是正的白色是负的)，

那么问题是如何证明奇环树无解。你画了一个奇环树，发现它有解/fad