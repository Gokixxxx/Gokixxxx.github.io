---
layout: post
title: atc选做
subtitle: /jy
tags: 题选做
---

突然又想起来做atc了。之前阅读了arc058~103和agc001~022D，但是今天我不关心比赛，我只想钦点难度，这就不得不说 https://kenkoooo.com/atcoder/ 。

-----

选择了2000~3199。

-----

arc150d

考虑一个点$u$被染的期望次数，只考虑它到根的链上发生的操作，注意到在这条链全黑之前$u$总是坏点，所以我们可以把只染坏点改成可以染所有点，这不会改变$u$被染次数的期望。问题变成有$l$个数，每次随机选一个，求全选过至少一次之后，第一个数期望被选了多少次，经典地，答案是调和数。

-----

arc149d

直接平衡树，复杂度是$O(n\log^2 n)$的，看起来不是很能过。

先填成满点集。然后每次平移之后，发现原点左右短的那一段中每个点的答案都是它的对称点反过来，所以短的一段就不需要处理了，复杂度线性。是不是其实挺套路的，但是我不会啊（

-----

arc149e

感觉很离奇。

等价于窗口是一个集合，然后窗口之外的部分，每次拿第一个加进窗口，然后把窗口的最小值扔进外面的最后。

设窗口和外面大小分别是$m_1,m_2$。注意到如果$k$很大，那么$m_2$轮之后，窗口里面必然是前$m_1$大的数，因为它们不可能被弹掉，并且总会进去。所以此时不管拿什么加进去，都会立刻把它拿出来，所以我们只需要做$m_2$轮，之后窗口外面只是在转转转，感觉这个是重要观察。如果$k$很小，没加入过的部分啥用没有，所以全都归结为$k=m_2$的情况。

考虑对于最终的外面的部分，我们把每个数分成加进去立刻弹出来得到的，或者弹出一个之前的东西得到的。容易发现第二类数是单增的，而第一类数在初始序列和最终序列中是相同的。如果一个数不是前缀最大值，那么它必然是第二类数，所以现在可能是第一类数的数是单增的。窗口里面的数和这些数最后会被排序，按操作顺序考虑，第一个弹掉的数可以是窗口中的一个数或者外面的第一个数，第二个弹掉的数还可以是外面第二个数，但是不能和第一个弹掉的重复，这样每个数都有$m_1+1$种可能的位置。分配完位置之后，容易发现它必然也可以构造一个合法的操作序列。由于窗口一开始可以是乱的，所以还要乘上$m_1!$。

-----

abc271h

考虑讨论一下，我们可能用一种横着的一种斜着的，两种横着的，或者两种斜着的。猜测不可能用超过两种操作。所以求个直线交就赢了。

然后发现有问题。由于黑白染色之后斜着的只能走到同色点，所以我们可能会先用一个横着的改变颜色，然后用两种斜着的。枚举第一步怎么走，然后还是求直线交即可。

另一个做法是大力数位dp。感觉很阴间。

-----

abc271g

终于有一个黄色的题。

考虑设$dp(i,j)$表示第$i$次访问在$j$时刻的概率，那么转移就比较简单，两边零散部分胡乱算，中间几何分布，然后矩阵快速幂，好像就结束了。复杂度$O(24^3\log n)$。

-----

abc270h

看起来我们需要转化它一个。

排序不亏。考虑结束的瓶颈是离目标差最大的那个数，所以倒过来变成给每个数$-1$，然后把一个数置为$a_i$。考虑所有数的最大值$x$，我们知道每次操作之后$x:=\max(x-1,a_i)$，其中$i$是随机选择的那个数。

于是考虑随机游走，如果我们现在在$x$，有$\frac{1}{n}$的概率走到每一个满足$a_i>x-1$的$a_i$，剩下的情况则走到$x-1$。只考虑各$a_i$，可以直接考虑它们之间的转移，然后现在我们就会消一消$O(n^3)$了。

考虑怎么线性。注意到我们要解什么$Ax=x$，而这个$A$看起来是一个上海森堡矩阵，所以我们只需要消$n$次。并且第$i$行的后$i$个数是相同的(除了$i=1$)，所以消的时候也保持了这个性质，直接维护即可。但是由于需要快速幂，还是带$\log$。

-----

abc270g

这是一阶常系数非齐次线性递推，所以循环节长度显然不超过$p$。它还是可以矩阵快速幂算，给向量补一个$1$即可。

bsgs。需要特判$a=0$，此时没有逆。

-----

abc269h

也就是偏序是树，求每个长度的反链数量。

看时限，猜测根号。考虑根号分治，感觉长的不是很会做。

猜测法法塔，$n^2$ dp是显然的，所以直接链分治，对轻儿子建huffman树，法法塔合并即可。复杂度$O(n\log^2 n)$。

-----

abc269g

让人想起某个图论题。

先全都选小的。翻卡相当于加一个数，那么这是一个背包，重量的和不超过$m$，要用最小的花费凑出一个重量。如果没有最小花费，大家都会合并两个重量相同的直到只有根号个物品，但是这里有最小花费，我们就不是很知道应该怎么合并了。

考虑一个强行做法，重量还是只有根号种，那么每种跑一个单调队列优化多重背包就赢了。复杂度$O(m\sqrt{m})$。

考虑一个简单做法，我们直接二进制拆分，注意到个数超过$2^k$的重量只有$\sqrt{\frac{m}{2^k}}$种，所以拆出来的总个数还是$O(\sqrt{m})$。所以那个合并的好像只是常数优秀啊?

-----

arc148d

感觉上只有每个数都出现偶数次，bob才能赢。如果有一个数出现奇数次，那么有两个数出现奇数次，那么alice上来选其中一个，接下来bob选什么alice选什么，最后bob不得不选另一个出现奇数次的数，alice就赢了。但是这要求这两个数的和不能是$0$。更一般地，如果$m$是奇数，那么bob能赢当且仅当每个数都出现偶数次。考虑找到一个最大匹配，如果bob选了最大匹配中的数，那么alice跟着选，否则选最大匹配外的数。注意到如果最大匹配外只剩下两个数$x,y$，那么$x-y,y-x$必然不同，而按照上面的策略最后必然会只剩下两个数，所以不管前面怎么选，alice先选$x,y$中某一个，必然可以把差调成非$0$的。

对于$m$是偶数的情况，如果我们同时给相差$\frac{m}{2}$的数连边(称为 第二类边)，然后存在使用偶数条第二类边的完美匹配，bob按照这个完美匹配选也赢了。现在证明除此之外都是alice赢。考虑找到一个最大匹配(不一定使用偶数条第二类边)，然后按照刚才的策略选，那么匹配外只剩下两个数$x,y$的时候，$x-y,y-x$必然不同，所以alice就赢了。

为了算这个完美匹配，每一类内部匹配必然不劣这样的。

-----

arc148e

恐怖故事，这里排列是本质不同的。哦好像其实只差除每个重数的阶乘。

考虑怎么才能让这些位置独立一点，不知道干什么的时候你就容斥一下，但是好像比较的输。

考虑这个大概是阈值图有向哈密顿路计数，于是考虑某个阈值图上的方向，我们每次删一个完全点或者一个单点。如果删了完全点，图会分裂成若干个单点和一个连通块，我们可以在这个连通块里面选任意多不交且并是所有点的有向链，然后以任意顺序串起来，挂一个单点也是简单的，然后就可以$O(n^2)$ dp了。

考虑如何优化，挂一个单点是$dp(i,j)=dp(i-1,j-1)$这样的，看起来就是$F_i=zF_{i-1}$，挂一个完全点可以选择它合并两条链，接到一条链的一端，或者自己作为一条链，是$dp(i,j)=j(j-1)dp(i-1,j)+2jdp(i-1,j)+dp(i-1,j-1)$，看起来就是$F_i=z(1+2\mathrm{D}+z\mathrm{D}^2)F_{i-1}$。但是并不是很会处理导数。

考虑换个想法，我们不要维护若干链，而是直接维护一个排列，可以在任意位置插入。一个完全点可以随便插，而一个单点不能插，需要放在旁边等一会，记录还剩多少个单点，可以得到另一个$O(n^2)$ dp。

考虑倒过来，我们从外往里考虑，称一个可以插入剩下的任何一个东西的间隔是一个槽，那么随着扫描线移动槽还是槽，加入一个完全点可以增加一个槽，加入一个单点需要占一个槽。然后就选出增加的槽和占的槽的位置就好了。

-----

abc268h

贪心，在acam上不停走直到出现一个匹配，然后把这次匹配之前的部分分一段。

-----

abc268g

先插个trie，然后一个点的排名相当于dfs序中前面点的个数，拆成每一层前面的点的个数，这个可以用期望的线性性拆开，然后每一层的期望是好算的。

-----

arc147d

读错题了。麻。

也就是从左往右每一步，我们可以加入一个元素或者删除一个元素。这个贡献让我们觉得应该扫值域，但是扫值域好像不是很好，但是扫序列更不好。

完全不会。我们先枚举每个间隔中变化了的那个数，那么再确定第一个集合，就确定了整个序列。注意到设如果第一个集合包含第$i$个元素，$i$的出现次数是$c$，那么不包含的情况下$i$的出现次数就是$n-c$，所以不管第一个集合是啥，总贡献总是$\prod (c+n-c)=n^m$。这个变化了的数的方案数是$m^{n-1}$，乘起来就得到答案。

-----

arc147e

考虑所有没过的人首先要进去，然后需要一些人进去调剂一下。可以感觉到问题相当于我们要选一个尽可能小的子集，使得外面的人都过了，并且里面的人排序之后都过了。

考虑先把线最高的老哥干了，我们需要一个线比他低并且分比他的线高的老哥来跟他换，不然啥用没有。找到分比他的线高的人中线最低的，把他加进来，交换他们的分数，然后把刚才那个老哥删掉。从大到小枚举线，用堆维护分比当前的线高的人中线最低的。

感觉比D简单。

-----

abc267h

很遗憾，相同的数是有区别的，所以我们不得不法了。看起来就是把$10$个东西卷起来，记录一个奇偶性，然后直接卷即可。

-----

abc267g

也就是求一个序列有$k$个严格上升的重排数量。

考虑欧拉数是怎么算的，我们把最大的数插进去，它可能插在一个上升或者一个下降，而必然造成一个上升一个下降。

从小到大排序然后dp，注意到可能有重复的数，也就是说现在考虑$a_i$，我们插入到另一个$a_i$后面不会产生上升。所以设$dp(i,j,k)$表示前$i$个，有$j$个严格上升的方案数，那么插入到一个左边是$a_i$的间隔不影响严格上升数，插入到一个严格上升不影响严格上升数，插入到一个左边不是$a_i$的下降或者平的间隔使得严格上升数增加$1$。复杂度$O(n^2)$。

-----

abc266h

先染色，把不能走到的都杀了。然后看起来比较像是一个lis，分治BiT即可。

-----

abc266g

太智障了，我上来就写了个三元gf。注意到没有两个rg相交，所以我们直接放rg就赢了。但是可能有放r和g的时候产生的rg，所以容斥一下就赢了。

还是考虑一下怎么三元gf!发现三元gf和直接计数区别不大，那么就不考虑了!

-----

abc265f

容易想到转转成切比雪夫，但是想了想发现三维的曼哈顿画出来一个八面体而不是正方体，所以转不动的。

再看看，发现$d$很小，直接大力dp，前缀和优化即可。离奇。

-----

abc265g

值很少，逆序对数可以直接在线段树上合并。

-----

arc146c

也就是偶数大小的子集xor和不为$0$。考虑给每个数补一个$n+1$位，那么只有偶数大小的子集xor和可能为$0$了。为了不线性相关，前面$i$个数，选择奇数个的话，张出$2^{i-1}$个数，第$i+1$个数不能选在这里面，然后就结束了。

这里是集合，所以我们还需要除一个阶乘。

-----

arc146d

看起来这是一个基环树森林。

考虑简单想法是全填$1$，但是如果$x,y$中有一个$1$我们就死了，所以考虑此时把那一个换大，然后这就会导致更多的问题。注意到全取$m+1$是合法的(但是爆了上限)，所以这个过程必然结束。复杂度也许是$O(nm)$。

然后发现std居然就是这个。注意到每条边最多贡献一次调整，所以复杂度是线性。

-----

arc146e

考虑从下往上扫值域，那么如果我们现在扫到$i$，如果一个间隔左右都是$i$，那么它是一个槽，接下来这里会继续插入得到一个峰，否则这里就确定了。接下来插入$i+1$，对于每个槽可以选择放俩，或者放一个直接得到一个峰，然后剩下的$i+1$可以插在槽中间获得一个新的槽。然后就可以开始dp了，设$dp(i,j)$表示前$i$个数，有$j$个槽的方案数(好像边上需要特殊处理?)，然后注意到一个灵异事件，我们先全都放一个，那么剩下的每放一个都会得到一个新的槽，所以槽的数量是确定的，组合数选一选乘起来就赢了。

-----

agc058b

最后每个数会扩展出一段，然后要求这一段里面没有更大的数。dp，设$dp(i,j)$表示前$i$个数，最后一段结束于$i$，值是$j$的方案数，前缀和优化一下即可。

或者感觉官方题解更为简洁。

-----

agc058c

让人不得不想起一个2-sat题，但是我们先不管这些。$1$只能连$2$，$2$可以连$1,3$，这样的，考虑如果两个数相邻并且可以连边，那么直接连上必然不劣，但是问题是可能还有这两个点到外面的边，这些边有可能交叉。

再想想，注意到如果有相邻两个相同的，那么它们必然可以连一样的边。如果我们连了相邻的$1,2$，那么$1$必然没用了，因为如果它又连了一个$2$，那么那个$2$和之前那个$2$可以连一样的边。所以现在任意两个相邻的数都是不同的，并且$1,4$分别不和$2,3$相邻。

注意到如果只剩下$2,3$那么直接构造就赢了，猜测如果剩下$1,4$则必然无解，但是很遗憾这个不对。考虑合并相邻的$2,3$，并强行钦点其中一个删掉，比如删掉了一个$2$，那么$2$的另一边可能是$3,4$之一，如果是$3$我们就合并两个$3$，否则合并一个$3$一个$4$，再下一个是$2$或者$1$，我们还需要继续决策。也就是说如果存在一个$2$，它的一边是$3$一边是$4$，则可以删掉$2,4$，如果两边都是$3$，则可以删掉$2,3$。同样的，如果存在一个$3$，它的一边是$2$一边是$1$，则可以删掉$3,1$。考虑极长的$2,3$交替段，边界上一定可以删掉$2,4$或者$3,1$，那么如果$2$不比$4$少，$3$不比$1$少，则必然可以把$1,4$删完。为了证明必要性，注意到每棵树都存在一条边连接相邻的两个点，并且其中一个点是叶子，所以钦点删掉一个等价于钦点一个是叶子，所以这个操作可以生成所有树。

-----

agc058d

看起来很复杂。不知道干什么你就容斥一下，发现相当于钦点若干个区间是abcabcabc...的子串，这样的区间称为 连续段，剩下的部分随意。直接写gf失败了，因为我们不能保证极长。可以考虑写成dp，但是看起来太困难了。类似于 顺子 那个题，考虑一个长$l$的极长连续段的容斥系数应该是$[l\leq 2]$，这样所有极长连续段的系数乘起来就得到答案。然后我们设任意连续段容斥系数的ogf是$T$，则有$\frac{1}{1-T}=1+z+z^2$，解得$T=\frac{z-z^3}{1-z^3}$，它的系数是$0,1,0,-1,1,0,-1,1,0,-1,...$这样的。然后就每次钦点一个任意长度的段了。

注意到这个容斥系数相当于不能选长度$\bmod{3}=2$的段，$\bmod{3}=1$的段让某个字符多出现了一次，$\bmod{3}=0$的段中各字符出现次数相同。一个$\bmod{3}=1$的段是$(xyz)^k(x+y+z)$，$\bmod{3}=0$的段是$3(xyz)^k$，所以答案就是$\frac{1}{1-\frac{x+y+z-3xyz}{1-xyz}}=\frac{1-xyz}{1-x-y-z+2xyz}$，考虑如何展开$\frac{1}{1-x-y-z+2xyz}$，直接大力展，结果看起来是什么

$$
\sum_i\sum_{j=0}^i\binom{i}{j}2^j(-1)^{i-j}(xyz)^j\sum_{u+v+w=i-j}\binom{i-j}{u,v,w}x^uy^vz^w
$$

，枚举$j$，然后因为要提取$[x^ay^bz^c]$，$u,v,w,i$都确定了，复杂度$O(n)$。

常数元gf还是可以尝试处理的!

-----

abc264h

dp，设$dp(u,d)$表示$u$子树，高度为$d$的答案，那么$dp(u,d)=[d=1]+\left(\sum\limits_{v}dp(v,d-1)\right)-\sum\limits_{v}dp^2(v,d-1)$。挂一个叶子的时候，它只可能向上更新$\log$个点，维护儿子们的dp值的和和平方和即可。复杂度$O(n\log^2 n)$。

-----

abc264g

猜测我们要么在很少的步数内停止，要么重复一个很短的循环节。建个acam先，那么相当于我们从根出发走一条路径，那么如果有一个正环我们就走上去，否则走一条最长路，spfa即可，复杂度$O(\Sigma^7)$。好像过不了啊?

注意到一个点的转移只跟最后两个字符有关，所以状态数是$O(\Sigma^2)$的了，边数不超过输入的串的数量，复杂度$O(\Sigma^5)$，看起来就赢了。

-----

abc263h

感觉很眼熟。二分答案，相当于画了一个圆，现在每条直线是一条弦，那么拿个数据结构扫一扫就可以求出交点的数量。复杂度$O(n\log v)$。

-----

abc263f

dp，设$dp(u,i)$表示$u$子树最终的胜者是$i$的答案，转移比较直接。

-----

abc263g

一般图最大匹配。我们当然希望把它变成二分图，注意到奇数和偶数，或者$1$和$1$的和才可能是素数，那么我们枚举$1$自己凑了多少，剩下的dinic即可。

但是很遗憾这个不太行，可以三分$1$凑了多少，或者注意到我们把一个$1$扔进去要么最大流增加$1$要么不变，所以二分$1$最少用了多少，然后剩下的自己拼。

好像还有只需要跑$O(1)$遍的做法。考虑随着我们增加自己凑的$1$的数量，答案的变化是$+1,+1,+1,...,+1,0,...,0,-1,-1,...,-1$，那么注意到这个东西只要知道了最左边和最右边的值，正中间的位置就确定了，而正中间必然是一个最大值，所以删光$1$跑一遍，加满$1$跑一遍，就得到了多少个$1$最优。看起来还是很有趣。

-----

abc262h

考虑了容斥，感觉不太行。

考虑每个数最大的可能值，发现它顶到这个上界的时候才可能作为某个区间的最大值，所以把相同的$x$分为一类，每个数只可能在一类中有贡献。

对每一类分开做，设当前处理的是$x$，直接dp，设$dp(i)$表示确定了前$i$个，第$i$个是$x$的方案数，枚举上一个，要求中间不能跨过一个区间，复杂度线性。总共是$O(n\log n)$，瓶颈是排序。

-----

abc262f

考虑爆力怎么做，注意到所有操作必然用完，因为删最后一个字符就可以让答案变小，所以我们枚举转了多少次，问题是求一个转$t$下之后最小的长$k-t$的子序列。枚举转到前面去的部分从哪里开始，然后就先尽可能选择a，然后往后尽可能选择b，然后往后尽可能选择c，直到个数用完结束。注意如果选了一个之后后面不够选了，那么就不能选它，大概是求一个区间$\min$之类的。

如果允许转转的话，也就是我们可以选完了一些再回到开头继续选，但是每选一个字符需要多付出$1$的代价。感觉一下发现我们必然会从一个最小的字符开始选，妈的，怎么是排列啊?那么就结束了，从这两个位置分别模拟即可。

注意到这个区间$\min$是可以用单调队列维护的。

-----

abc262g

考虑什么样的序列可以用一个栈搞成上升的，经典结论是，如果存在$i<j<k$满足$a_k<a_i<a_j$，那么不可能搞成上升的，否则必然可以。

容易想到找到选的的最大值。区间dp，设$dp(l,r,i,j)$表示区间$[l,r]$，选的值在$[i,j]$中的答案，转移枚举最大值也就是那个$a_j$，然后递归两边，复杂度$O(n^6)$。注意到枚举最大值可以前缀和优化掉，复杂度$O(n^5)$。

-----

arc145d

这里固定了总和，所以看起来还是很恐怖的，我们可以平移一下做到$n$以内的差距，那么需要一个数调节一下。

先考虑没有总和怎么做。wiki一下，发现我们可以选择若干个三进制表示不包含$2$的数。好像就结束了。

-----

abc261h

首先所有没有出度的点是确定的。然后从它们开始传播，先手会希望走到一个已经确定的点，而后手希望走到一个还未确定的点。类似dij做即可。

-----

abc261g

注意到每个字符经过若干次替换变成了一个串，考虑如果可以判断一个串由一个字符操作得到的最小代价，就可以直接dp了。dp，设$dp(c,l,r)$表示字符$c$最少经过多少次操作可以变得和$t_l,...,t_r$相同，转移枚举一个操作，然后直接dp，复杂度$O(n^4\Sigma)$，认为$n,k$同阶。

-----

abc260g

考虑如果直角边相等是怎么做的，发现可以大力差分成两个三角形一个矩形。这里看起来是一样的。

-----

arc144d

看起来很眼熟啊。猜测它必然是每一位的一个函数的和，考虑如果我们确定了$f(0)$和各$f(2^k)$，那么$f(S)=\sum\limits_{i\in S}f(2^i)-f(0)(\operatorname{popcnt}(S)-1)$。那么问题变成，数一个序列$f$和一个数$x$，要求$f-x$的任意子集和$\geq -x,\leq k-x$。显然我们把负的加起来$\geq -x$，正的加起来$\leq k-x$就赢了，所以考虑枚举一个$x$，枚举有$t$个负的，$s$个$0$，组合数选出来，然后把$-x$插板进去，这里经典的可以直接插进$t+1$个变量表示$\geq -x$。正的部分是一样的。写出来大概是

$$
\sum_{s=0}^{n}\binom{n}{s}\sum_{t=0}^{n-s}\binom{n-s}{t}\sum_{x=0}^k\binom{x+t}{t}\binom{k-x+n-t-s}{n-t-s}
$$

右边两个组合数，可以写成gf，它们是$\frac{1}{(1-z)^{t+1}},\frac{1}{(1-z)^{n-t-s+1}}$，所以右边一共就是$\binom{k+n-s+1}{n-s+1}$，所以它和$t$是无关的。就线性了。

让我想到高阶差分的trick是否和这个有些关系，但是不是很懂。

-----

abc259h

让人想起某个agc题。

但是完全不是。根号分治，出现次数多的颜色可以直接dp，少的爆力枚举一对，复杂度$O(n^3)$。

-----

abc259g

让人想到网络流。最小割，但是这个边权可能是负数。经典地，先选择所有正的值，然后如果一个正的的行和列都没选，要把它割掉，如果负的的行和列选了恰好一个，要把它割掉，如果负的的行和列选了两个，要割一个inf。

所以直接建，每行每列建一个点，源连行而列连汇，割表示选。考虑怎么表示都选了，发现就从列到行连一个inf就好了。选了恰好一个的部分直接放进行和列的贡献里。使用dinic，复杂度$O(n^4)$。

-----

abc258h

妈的，原来是选任意多个啊。

记选的上一个数的奇偶性，前缀和优化，矩阵快速幂。

-----

abc258f

直接走过去，或者找到上下左右第一个main road上的点，然后沿main road直接走过去。

-----

arc143d

也就是说我们要让尽可能少的边不在环里。

注意到我们选的所有的环必然是交替走前$m$条边和后$n$条边(称为 第一类 和 第二类)，因为如果连续走了第一类边，可以转一下多走两条第二类边。

于是猜测我们直接只建$n$个点，把边看成$a_i$连到$b_i$，跑割边就赢了。感觉这个题目给的图就好像改成了有向边。众所周知e-dcc直接dfs可以定向成scc，那么每条边都在一个环上。如果一个e-dcc是一个单点，那么它的那条第二类边也是割边。

-----

arc143e

考虑什么时候是有解的。猜测如果一个连通块不全是B，那么就有解，但是这个假了，比如两个W就是无解的。

完全不会啊。考虑一个叶子，发现它和它的父亲的顺序是确定的，如果它是白色，那么删掉父亲之前必须删它，所以可以把它挂到父亲上，在删掉父亲之前/之后恰好一个把它删掉。那么父亲的颜色就会先改变白色的儿子数量次，然后考虑它的父亲这样的。如果考虑完子树之后一个点最终是白色的，那么也就是它和它的儿子中有奇数个白色，那么根是白色当且仅当整棵树有奇数个白色。

然后这个东西就连连边，开个堆toposort一下就好了。

-----

abc257g

dp，设$dp(i)$表示后缀$i$的答案，转移是一个区间，z algo一下然后线段树。

或者设$dp(i)$表示前缀$i$的答案，注意到如果$dp(i)$不是inf，$dp(i)\geq dp(i-1)$，并且$dp(i)\leq dp(i-1)+1$。那么只需要尽可能往前转移，还是一个z algo就赢了。

-----

arc142d

注意到如果能操作一步，第二步再操作回来必然是可行的，所以这个就是那个唯一的$S$。

一个 可以移动一步 的方案和选若干非平凡链，然后给每条链定向的方案是双射。

注意到如果一个点不在任何一条链中，那么就不合法了，因为一个棋子可以移动到这上面来，也可以在它的链上移动。如果两条链相对，那么也是不合法的。如果一条链的中间向外发出另一条链，那么也是不合法的。

猜测，如果两个链头或两个链尾相邻，或者一个链头/链尾和另一条链的中间相邻，则不合法。然后开始大力dp，设$dp(u,0/1,0/1)$表示$u$子树，$u$的链的方向是从下往上/从上往下，$u$不是/是最高的点的方案数，$g(u)$表示$u$的链从一棵子树到另一棵子树的方案数。转移考虑

 - $dp(u,0,0)$ : 如果$u$是链上最低的点，那么儿子们可以选$dp(v,0,1)$，否则一个儿子选$dp(v,0,0)$，剩下的都选$g(v)$。$dp(u,1,0)$是类似的。

 - $dp(u,0,1)$ : 一个儿子选$dp(v,0,0)$，剩下的儿子选$dp(v,1,1)$。$dp(u,1,1)$是类似的。

 - $g(u)$ : 两个儿子分别选$dp(v,0,0),dp(v,1,0)$，剩下的选$g(v)$。

可以注意到$dp(u,0,...)$和$dp(u,1,...)$好像是一样的，那么就只剩下三个状态了。

-----

abc256h

线段树。如果一个区间的值都相同了，那么直接打推平标记，否则爆力递归下去，每个连续段会付出$\log$的代价减少$1$的势能，复杂度$O(n\log^2 n)$。

-----

abc256f

$a_i$对$d_j$的贡献系数是$\binom{j-i+2}{2}$。爆力展开它，然后维护$i^2a_i,ia_i,a_i$的和就好了。

-----

abc256g

考虑顶点上怎么放，接下来内部就比较简单了。枚举最后每条边放了多少，然后枚举第一个顶点放没放，矩阵快速幂优化dp。

-----

abc255h

注意到这个是推平，set维护上一次推平时间的连续段即可。

-----

abc255g

每一堆等价于一个nimber，设$f(i)$表示大小为$i$的堆对应的nimber，那么有$f(i)=\operatorname{mex}\limits_{j<i,(i,i-j)\notin(x,y)}f(j)$，注意到只有很少位置的转移被影响了，继续考虑第一个被影响的位置的$f$就是它的转移中被挖掉的位置中最小的那个，没被影响的位置是在填补前面的空缺，但是没有什么会产生空缺，所以没被影响的位置是前面的$\max+1$。考虑一下，对于任意一个被影响的位置，维护每个$f$的出现次数，把它的被挖掉的转移指向的$f$的出现次数$-1$，然后如果出现了$0$那就找到最小的那个，否则就是$\max+1$。为了简单维护这个，把$=\max+1$的位置拿出来，它们组成$1,2,...,\max$，剩下的位置必然是被影响了的，只需要在一个map里存它们就行了。复杂度$O(n\log n)$。

-----

abc254h

每个数必然是先除若干次然后乘若干次。先考虑一个多项式复杂度的做法，$a$中每个数枚举除和乘各多少次，然后跑一个最小权完美匹配，复杂度$O(n^3)$。

考虑给$b$中每个数不停整除$2$，每除一次扔进一个hash table里面，然后给$a$中每个数不停除$2$，每除一次去hash table里面查一下，这样可以得到一个$n\log n$点和边的图，可以尝试network simplex或者zkw费用流冲一下。

考虑点正常做法。定义一个数的核是它不停整除$2$之后得到的数，把每个数挂到它的核上，从大到小枚举一个核，尝试给上面挂着的$a,b$找一个配对，然后如果$b$多了那就没救了，如果$a$多则除一个$2$递归下去。如果我们要配对$a,b$，它们分别进行了$c_a,c_b$次整除(而$a$没有进行下取整除)，那么我们可以省掉$\min(c_a,c_b)$次。如果一个$a$在第一个核处没有用到，接下来就永远不能省了，所以我们匹配的时候一定是先匹配整除次数最多的。复杂度$O(n\log v)$。

-----

abc254g

如果最后要往上走，我们必然是，(往上走到顶，走到某个楼，)*往上走到目标高度，(走到目标楼)?，这样的。这是一个正则表达式。如果要往下走，swap一下。

考虑在楼间走的话，肯定会走到一个往上延伸的最长的电梯，求出这个之后倍增一下就好了。复杂度$O(n\log n)$。

-----

arc141c

考虑$p$字典序最小这个条件看起来非常强，发现如果我们交换两个左括号，序列还是合法的，但是字典序变化了，所以这要求所有左括号的编号是递增的，所有右括号的编号是递增的，否则一换就更小了。也就是说$p$必须可以分成两个上升子序列，一个全放左括号，另一个全放右括号。

看样例可以猜测各种结论，但是好像不是很容易猜到。

完全不会。考虑如果我们确定了一个$s$，应该怎么找字典序最小和最大的重排。对于字典序最小，发现如果前缀和是$0$，我们必然贪心选择最左的左括号，否则选择最左的括号。那么可以知道如果$p_i>p_{i+1}$，说明$p_i$这里前缀和是$0$，选了一个靠后的左括号，而$p_{i+1}$必然是右括号。然而这个不是充要的，最左的左括号可能就是最左的括号。对于字典序最大，如果和是$0$，我们贪心选择最右的右括号，否则选择最右的括号。

然后就比较奇妙了。考虑直接把$s$画成折线，那么在选最小的字典序的时候，对于$x$轴下方的部分，我们会轮流选左括号和右括号，而$x$轴上方的部分我们会一串选过去。注意到$p_i>p_{i+1}$的部分就确定了$x$轴下方的部分，同理$q_i<q_{i+1}$确定了$x$轴上方的部分，所以我们就得到了整个括号序列。如果有位置没有确定那么必然不合法，然后再check一下这俩序列是不是字典序最小和最大的就结束了。

-----

arc141d

也就是一个可比图的大小$\geq m$的独立集。但是好像没找到可比图怎么求独立集啊。

妈的，为什么我一个arc都不会。强行构造，把每个数分解成$a\times 2^b$，那么每个$a$最多选一个数，一共有$m$个不同的$a$，所以每个必须选一个数。假设选了一个$b$的序列，那么如果$a_1\mid a_2$，我们知道必须有$b_1>b_2$，并且这个是充要的，所以给每个$a$求出可能选的最小的$b$和最大的$b$即可。复杂度是调和数。

-----

arc141e

先按$(x-y)\bmod{n}$分组，那么每次就是有一个偏移量地在两个组之间连边。

如果只有一个组，连通块数是$\gcd(n,a,b,c,...)$这样的，其中$a,b,c,...$是每次连的偏移量。

考虑把每组看成一个点，随便找一棵生成树，钦点这个生成树上的偏移量都是$0$，那么也就是我可以在一个连通块的组之间编号相同的点上自由移动。那么此时它就变成了一个组。合并的时候直接合并。

刚才说我一个arc都不会。现在看来我会的都在后面/jy

-----

abc253h

状态数是bell数，预处理两个子集之间的边数，复杂度是$O(B_n)$的。然而看起来dfs并过不了。

考虑点牛逼做法，我们直接生成森林计数就赢了啊/yiw，大概是对每个子集矩阵树一下，然后枚举数量自己卷自己若干次，这里卷是子集卷积。复杂度$O(2^nn^3)$。

-----

abc253g

注意一下这些操作都是啥，每轮大概是把一个数跟若干个数换了一遍，发现这相当于把这个数移动到某个位置，而一个区间的数往前移动，直接用pbds的平衡树维护即可。或者你可以继续考虑，发现除了第一次和最后一次，剩下的操作都非常简单，可以用链表维护。

-----

abc252h

原来 out of ..., choose ... 是 从中选出 的意思/jy

也就是从每个集合选一个，求$k$大xor和。如果没有这个颜色的限制，那么我们都会线性基。考虑为什么$n$这么小，发现大小为$1$的颜色是没有用的，于是只剩下$35$种颜色，算一算发现此时只有1e11种方案。

考虑折一半，我们尽可能让两边方案数相同，然后分别搜出所有方案。最坏情况下大的一边大概是$3^{12}$，看起来很阳间。然后一边插个trie，另一边所有数同时在trie上二分，复杂度$O(3^{\frac{n}{6}}\log v)$。

-----

abc252g

经典问题。区间dp，设$dp(l,r)$表示$[l,r]$对应的树的数量，$g(l,r)$表示$[l,r]$对应的从左往右根编号递增的森林数量，复杂度$O(n^3)$。

-----

arc140d

也就是每个点有一条边，确定了若干条，剩下的随便连，求连通块数之和。

注意到连通块数就是环的个数，问题变成算环的总数。考虑先把已经有的边缩起来，如果一个连通块已经有一个环，那么这个环贡献剩下的随便选的方案数，否则它上面有恰好一个点还要向外连边，而剩下的点连到这个点的时候方案数是它缩之前的大小。

于是我们好像就比较会了。枚举一个环，环上每个点贡献它的大小，环外每个点贡献$n-1$，那么直接分治法法塔卷出每个环大小的方案数即可，复杂度$O(n\log^2 n)$。

-----

arc140e

也就是任意一个$2\times 2$的子矩阵不是全部相同的。

让我们想起fjoi2022 D2 B的构造，考虑取$23$，并转转$23$次，就赢了。具体写起来看起来官方题解比较简单。

这个构造的解释收录在 如果我不知道把一些东西放在哪里，那就放在这里吧。

-----

abc251h

$(n,i)$处的一个数，对$(k,j)$的贡献是$\binom{n-k}{i-j}$。那么一个前缀的贡献是$\sum\limits_{i=0}^r\binom{n-k}{i-j}=\sum\limits_{i=0}^{r-j}\binom{n-k}{i}$，那么求一个也就是求一行组合数的若干个前缀和。只求一个看起来也较为恐怖，但是注意到有一个$\bmod{7}$，那么我们lucas一下，设$t=n-k$，有

$$
\begin{aligned}
S(t,l)=&\sum_{i=0}^l\binom{t}{i}
=&\sum_{i=0}^l\binom{\lfloor t/7\rfloor}{\lfloor i/7\rfloor}\binom{t\bmod{7}}{i\bmod{7}}
=&\sum_{7i\leq l}\sum_{j=0}^7\binom{\lfloor t/7\rfloor}{i}\binom{t\bmod{7}}{j}+\sum_{i=0}^{l\bmod{7}}\binom{t}{l-i}
=&S(\lfloor\frac{t}{7}\rfloor,\lfloor\frac{l}{7}\rfloor)2^{t\bmod{7}}+\sum_{i=0}^{l\bmod{7}}\binom{t}{l-i}
\end{aligned}
$$

后面可以lucas，前面递归下去，复杂度是俩$\log$。注意到实际上后面只跟$t,l$的$7$进制表示有关，所以预处理一些东西可以做到一个$\log$。然后我们得到了一个$O(km\log n)$。

注意到求出$j=k$之后，剩下的每次就是每个加了一个$\binom{n-k}{r-j}$，可以算一个之后递推出所有的，每次修改$7$进制表示的均摊$O(1)$位，复杂度$O(km+m\log n)$。模拟$7$进制$+1$听起来有点阴间，不过应该并不难写。

-----

abc251g

考虑直接求出这个半平面交，那么我们给每个方向的半平面求一个限制最强的，然后这里也不需要真的求，只要爆力检查每个查询点就行了。复杂度$O(n(m+q))$。

-----

abc250h

当然按$t$从小到大扫，我们需要求出房子的连通性。如果没有边权，我们从每个点出发bfs $\frac{t}{2}$的距离，如果bfs到了同一个点则合并。但是现在有边权，上个堆先，然后每条边上的相遇时间还需要再开一个堆，听起来就很困难。不过可以注意到，对每个点求出端点到最近的房子的距离$d$，那么边$(u,v,w)$会在$\frac{d_u+d_v+w}{2}$时刻被扫到(从第二个堆中弹出)，求$d$听起来就好写多了，然后按这个排序，搞个并查集即可。如果要在线，可以跑个kru重构树。

-----

abc250f

一块可以差分成两个前缀和和一个三角形。双指针。

-----

abc250g

这是一个经典模拟费用流题来着。容易建一个匹配，发现这上面你甚至不需要反悔。线段树维护最大的$p_j-p_i(i<j)$即可。

好像也可以slope trick。也可以直接从左往右加边，加入一个点时可以换前面的一个，也可以连前面的一个没连的，维护两个堆就好了。甚至可以维护一个堆。所以有没有可能单向链上的费用流天然支持slope trick。

-----

arc139c

直接画到平面上，相当于有一个网格，每条线上只能选一个点。直接猜测它是一个削了一些的棋盘，那么直接选对角线就赢了，但是看一眼样例觉得并不对。画一画，发现这些点不都是连通的，消一手hermite标准型，再画一画，发现它有八个连通块。那么每部分相当于一个削了一些的棋盘，画一画你就懂了!

我的做法大概是，假设$n\geq m$，那么枚举一个起点，然后贪心地沿着下边界线走即可。代码我随机调整出来了，可以看看 https://atcoder.jp/contests/arc139/submissions/35605206 。

-----

arc139d

发现最后剩下的数肯定是所有数里面前$x-1$小和后$n-x+1$大，因为它们不可能被删，而必然被加入。

注意到两个好像是对称的，所以只考虑前$x-1$小。dp，设$dp(i,j)$表示前$i$个选了$j$个的方案数，转移枚举这一个选了多少，设$i$出现$c_i$次，看起来是$dp(i,j)=\sum \frac{(j-k-c_i)i}{(j-k-c_i)!}dp(i-1,k)$，最后要乘一个$k!$。直接做是$O(n^2m)$的，可以法法塔做到$O(nm\log n)$，感觉应该可过吧。好像先求值最后插值就$O(nm)$了。

考虑一个简单点的做法，枚举一个什么东西，直接算它的贡献。想了想，如果枚举一个值，算它在前$x-1$小的方案数，那么我们需要考虑它的出现次数，这里一个想法是钦点大小相同的数前面的更小然后枚举位置，另一个想法是枚举一个排名，尝试一下发现前者比较恶心，所以考虑后者。

如果我们钦点排名为$r$的数是$t$，一开始$<t$的数有$pc_t$个，$>t$的数有$sc_t$个，那么要求后面有不超过$r-1-pc_t$个数$<t$，不超过$n+k-r-sc_t$个数$>t$，剩下的$=t$。大力枚举一下，可以得到

$$
\sum_{r=0}^{x-1}\sum_{t=1}^mt\sum_{i=0}^{r-1-pc_t}\binom{k}{i}(t-1)^i\sum_{j=0}^{n+k-r-sc_t}\binom{k-i}{j}(m-t)^j
$$

看了一眼，能且只能把$r$往后换，换完之后搞一搞它就变成$g(i,j,t)=\sum\limits_{r=pc_t+1+i}^{n+k-sc_t-j}[r\leq x-1]$了，可以$O(1)$算，于是得到

$$
\sum_{t=1}^mt\sum_{i=0}^k\binom{k}{i}(t-1)^i\sum_{j=0}^{k-i}\binom{k-i}{j}(m-t)^jg(i,j,t)
$$

固定$t$，从大到小枚举$i$，后面那个$\sum$可以递推出来，复杂度$O(mk)$。

-----

abc249g

最大xor和不得不使用线性基，先处理$\leq k$的限制，枚举这个xor和在哪一位开始和$k$不同，前面我们在线性基上表示出来，这得到了一个xor和，剩下的低位可以随便选，而线性基外的数也可以随便选，对这些数(当然是尝试消了之后的)再建一个线性基求最大xor和，精细实现一下，复杂度$O(n\log v+\log^2 v)$。

然后好像不是很深刻。大概是注意到我们给一个xor上另一个不改变张成的空间，所以可以把两部分拼在一起消一消，消成上三角之后就赢了。

-----

abc248h

注意到这个题看起来很经典。直接卡笛尔树，扔到平面上得到$O(n)$次矩形加减，查询$\leq y-x+k$的位置个数。扫$y$，分块维护$x$，$y$右移是全局$+1$，直接每一块开个有序的vector，查询的时候二分，修改的时候归并就行了。复杂度$O(n\sqrt{n\log n})$。

等会啊，题解怎么俩$\log$啊¿

分治，考虑如果$\min,\max$在同一边，那么把值域看成一维，另一边是一个二维偏序。如果$\min,\max$不在同一边，那么是一个三维偏序。但是继续注意到到中点的$\min/\max$是单调的，所以又变成序列上位置的限制了，然后就只剩两维了。

数点的时候单调性还是很重要。

-----

abc248g

这位更是。枚举一个$\gcd$，然后带一个$\varphi$的容斥系数，搜出每个连通块并dp。复杂度$O(nd(n))$。

-----

abc247h

看错题大师。也就是最终序列一个颜色内部可以任意重排，考虑什么情况下可以换出来，注意到每个环上的颜色都是一样的所以比较好做，猜测如果环数$\geq n-k$并且和$k$奇偶性相同就行，因为我们每操作一次环数的奇偶性都会变化，如果操作不同的两个环则会把环连起来，否则会分裂一个环。

然后就比较简单，枚举一个个数，每一类内部是斯特林子集数，求出来之后分治法法塔即可。或者直接写个dp然后分治法法塔。

-----

abc247g

从小到大扫学校，枚举前两个人的学科，设$dp(i,0/1/2)$表示前$i$个学校，选了前$0/1/2$个人的最大能力和。复杂度$O(v^4+n)$。

为了优化，前缀和一下，好像就$O(v^3)$了。

然后好像我比较智障啊!这个就直接，每个学校和每个学科匹配最多一个人，跑费用流即可。

------

arc138d

这个看起来是，$k$-格雷码之类的东西。wiki了一下好像没有找到啊。

那就强行构造。如果$k$是偶数，那么必然无解，因为popcnt的奇偶性是不变的。如果$k$是奇数，那么popcnt是奇数和偶数的部分是交替进行的。

然而还是不是很会。考虑我们每次是xor上一个popcnt为$k$的数，那么随便跑一个基，如果不满秩则没救，如果满秩，那么每次xor上基中一个数原来的值(而不是基中的值)就可以得到所有数。跑一个格雷码表示每个数是否要xor上即可。

据说直接搜就过了。并且是洛谷原题7949。看起来是分很低的原因。

-----

abc246h

如果没有?，子序列自动机。但是现在有，考虑一个经典dp，设$dp(i,j)$表示前$i$个位置以$j$结尾的本质不同子序列数量，转移是$dp(i,s_i)=\sum dp(i-1,j)-dp(i-1,s_i)$，也就是前面所有子序列都可以接一个$s_i$，但是其中有$dp(i-1,s_i)$个已经出现过了。注意到转移是线性变换，维护一个后缀和就好了。复杂度是线性。

-----

abc246g

二分答案，问题转化为xix open cup gp of peterhof G. Game On Tree。

好像一直忘了认为最小/最大化的博弈论问题可以二分转化成直接的输赢。见到这种问题就先二分即可。

-----

abc245h

如果是和，那么大家都会做。如果$m$有原根，那么我们找到一个原根，大家还是都会做。

考虑先都除一个$g=\gcd(n,m)$，现在各$a_i$也必须和$m$互素(把$g$那部分也都除掉了)。互素就构成乘法群，猜测如果$g=1$，凑出每个数的方案数是相等的，因为不管前面怎么选，由于逆元存在且唯一，最后一个数总有恰好一种方案把它调成对的，也就是说答案就是$\varphi(m)^{k-1}$。

考虑$g>1$。分解$g$，然后我们知道只要确定了包含分解的各部分的数都是啥，剩下的数的变化就只是每个数选的时候方案数多乘一个$g$。枚举多少个数包含这些，然后dp，设$dp(i,j,k)$表示前$i$个数，上一个选了$j$，当前乘积是$k$的方案数，那么这一次选择若干个$>j$的数，然后它们还可以乘上一个$\perp m$的数，如果选了$d$那么有$\frac{g}{d}\varphi(m)$个这样的数，如果这次选的这些里面有乘的数相等的，重排的时候就要除一个阶乘，复杂度毛估估是$O(d^3(n)\log n)$。并过不了。

考虑直接在序列上做，而不是把数插回去。设$dp(i,j)$表示前$i$个数，当前乘积是$j$的方案数，转移直接枚举选啥。也可以做到$O(d^3(n)\log n)$。

看起来我们需要注意到一点什么。注意到刚才说 然后它们还可以乘上一个$\perp m$的数，如果选了$d$那么有$\frac{g}{d}\varphi(m)$个这样的数，发现所有$d$的乘积就是$g$啊?所以矩阵快速幂的时候所有的系数都可以是$1$了。

看起来我们还需要注意到一点什么。每个素因数是独立的，所以可以分开矩阵快速幂，现在只需要记一个次数了，就赢了。

还是要记得独立啊/oh，所以这个真的是直接做题啊。

-----

abc245g

也就是求一个到不同颜色的关键点的最短路。考虑如果我们从每个关键点开始跑dij，那么这会形成若干个块，每个块是到某个关键点距离最近的点，定义一个块的颜色是这个关键点的颜色。如果一个点所在的块和它的颜色相同，那么它必然希望寻找一个和这个块邻接的块。首先从它出发需要走到一个块边界上的点，然后沿着一条块间的边走到另一块，然后走到那一块的关键点。所以我们对每个点计算它走一条边能走到的不同块的点中，到那个块的关键点的最短距离，然后对每个块建一个源，到每个点连这个最短距离，跑dij即可。由于每条边只会被两边的块枚举各一次，复杂度$O(n\log n+m)$。

-----

abc244h

动~态~凸~包~

经典的，$a_ix+b_iy=a(x+\frac{b_i}{a_i}y)$。每个点看成一条直线$x+yz$，李超树维护即可。这里是需要注意精度的。也可以对时间分治，归并排序就可以做到一个$\log$了。

-----

abc244g

也就是钦点了每个点经过奇数还是偶数次。随便找一条路径，然后如果一个数出现次数不对，那就让它走到下一个再回来，这样它和下一个的出现次数都$+1$，到最后一个的时候如果它不对，就让它走到任意一个邻接点，走回来，再走过去。这样dfs会生成$2n-2$条边，总共不超过$4n$。

-----

arc137c

读错题大师。没看见最大的想了一年。

这个看起来就比较厉害。发现相当于数轴上有一些棋子，然后你可以把最右边的往左移动，当然想起staircase nim，考虑空位的变化，相当于选择一堆，拿走一个并把它分成相邻的两堆，然后把最后一堆扔掉。每一堆都可以是空的。

还是考虑staircase nim吧。但是完全不行。那还有啥方向啊。

可以尝试考虑一个胜负确定的无限集合。注意到先手可以每次把最后一堆搞成空，后手就只能拿一个，所以如果总个数是奇数那么先手赢了。如果总个数是偶数，如果最后一堆是空的，先手只能拿$1$个，此时后手就赢了。如果最后一堆是奇数个，他可以拿倒数第二堆的最后一个，这样就少了偶数个，并且此时最后一堆是空；如果最后一堆是偶数个，他可以拿最后一堆的最后一个。所以只有最后一堆是空的，并且总个数是偶数的时候后手才能赢。

-----

arc137d

看错题了/oh

我们知道答案是各

$$
\sum_{i\leq n}\binom{n-i+k-1}{k-1}a_i
$$

。kummer定理，注意到$\binom{n-i+k-1}{k-1}=1$当且仅当$n-i$和$k-1$的$1$位不交，法嘛塔算补集子集的xor和即可。

-----

arc137e

让人想起 志愿者招募。

一眼网络流。但是不是很懂怎么处理这个$\min(x_j,a_j)$。

哦好像还是好处理的，只要给$i$天的入点到出点连一个费用为$d$，容量为$a_i$的，一个费用为$0$，容量为$\infty$的。然后每个人还是表示成一个环。最大费用循环流。

需要考虑背一个network simplex/oh

-----

abc243f

大力dp，设$dp(i,j,k)$表示前$i$个，抽了$j$次，抽出了其中$k$个，那么枚举第$i$个抽到多少次，把这些次抽到乘上概率和前面的任意归并。复杂度$O(n^4)$。

-----

abc243g

也就是$dp(1)=1,dp(i)=\sum\limits_{j^2\leq i} dp(j)$。发现这玩意只有$\log\log$层，我们展开两层好像就赢了，所以写一写

$$
\sum_{i^2\leq n}\sum_{j^2\leq i}dp(j)=\sum_{j^2\leq n}dp(j)\sum_{j^2\leq i^2\leq n}i
$$

然后就赢了。复杂度$O(\sqrt[4]{n})$。

-----

abc242h

考虑球说的是每个操作有一个选到的概率，然后这个分母$\leq 400$。容易想到min-max容斥，考虑对格子min-max容斥，有

$$
\sum_T(-1)^{\vert T\vert}\frac{s}{f(T)}
$$

其中$s$是权值和，$f(T)$是包含$T$中至少一个位置的区间的权值和。然后我尝试推了推，但是困难并且没有必要，我们直接对$T$ dp，注意到每个包含$T$中至少一个位置的区间，包含的是$T$中位置的一个区间，考虑在它包含的第一个元素处统计，设$dp(i,j)$表示选了$i$，$f(T)=j$的方案数，转移枚举下一个选$k$，然后所有包含$k$而不包含$i$的区间就要加到$j$上。复杂度$O(n^3)$。

有些时候失败是因为你尝试的技术太普遍了，比如这个题是区间，如果是任意集合就不好做，如果你用在任意集合上也适用的技术，就要考虑一下是不是转化的复杂了。

-----

abc242f

也就是每一行每一列要么没有黑车，要么没有白车。

考虑枚举哪些行，哪些列属于黑色，这些行和这些列的笛卡尔积中黑色随便放，剩下的行和剩下的列的笛卡尔积中白色随便放。但是可能有若干行/列并没放黑车，再钦点这个的数量进行容斥。复杂度$O(n^4)$。

-----

arc136c

环形积木大赛。

找到最小值，先操作那么多次，然后就变成链了。遗憾的，第一个样例就把我卡了。

考虑为什么它是错的，一个选择最小值并操作的证明是，$\sum [a_{i+1}>a_i](a_{i+1}-a_i)$每次最多减少$1$，并且在最后$=0$，而选择$\min$进行操作确实让它减少$1$。但是这里它不一定减少$1$了，比如操作一圈它就并不减少。但是发现还是存在操作让它减少$1$的，因为我们只需要让操作的右端点是一个下降的左侧，而这是一个环，下降必然和上升相伴出现，所以必然也可以选一个左端点。

但是比如有且只有一个1e9的时候你就死了，考虑一下发现$\sum [a_{i+1}>a_i](a_{i+1}-a_i)=0$的时候也可能是所有数全都相同，我们跟最大值取一个$\max$就赢了。

-----

arc136e

请注意是在原图，而不是$s$的导出子图中不可达。

考虑这是它的闭包上的一个可比图最大权独立集，也就是最大权反链，关于最大权反链，好像我们只知道可以网络流跑，但是边数是$n^2$的，并且增广次数很大不好优化。

考虑这个偏序是在说啥。$i\leq_G j$，当且仅当可以选择一个开头是$i$，结尾是$j$的递增序列，使得相邻两项不互素。感觉这个条件达到的不是很困难，考虑$i,j$的任意两个素因数$p,q$，如果有一个$pq$的倍数在$i+1,...,j-1$之中，那么选择它就赢了。考虑搞一个充要的条件，发现任意这个序列等价于选择一个素数序列作为不互素的部分，注意到$i$是$i$的任何素因数的倍数，那么我们选的第一个素数必然是$i$的最小素因数，这里$i$跟$0$在某种意义上很像。同理，选的最后一个素数必然是$j$的最小素因数。我们可以在中间再放一个数，但是想了想发现最多只有一个，因为放多个只会比放一个难，看起来我们必然选择$2$。所以，如果$i,j$都是奇数，我们选的必然是$i,i+\operatorname{minp}(i),j-\operatorname{minp}(j),j$(因为是奇数，所以$>i$的第一个$\operatorname{minp}(i)$的倍数必然是$i+\operatorname{minp}(i)$)，那么$i\leq_G j$当且仅当$i<j,i+\operatorname{minp}(i)\leq j-\operatorname{minp}(j)$；而偶数最多选一个。容易感觉到已经不可能比这个条件更优秀了。注意到$i+\operatorname{minp}(i)\leq j-\operatorname{minp}(j)\Rightarrow i<j$，所以只剩下一维了。

现在可以$O(n^2)$。枚举选择哪个偶数，然后算一个最大权反链，扫$i$，每个位置相当于一个区间$[i-\operatorname{minp}(i)+1,i+\operatorname{minp}(i)]$，如果两个区间不交则不合法，差分算覆盖每个位置的区间个数即可。需要进一步考虑偶数，注意到如果$i$是偶数，限制直接变成$i\leq j-\operatorname{minp}(j)$就好了，反过来也是一样的。所以就线性了。

妈的，这个题好有趣。

-----

abc241h

大概就是什么

$$
[z^m]\prod_i\frac{1-(a_iz)^{b_i+1}}{1-a_iz}
$$

感觉以前跟空的大概说过这个怎么做。分子分母分别乘起来，分子只有$O(n)$项，分母有$O(2^n)$项。考虑怎么求逆的远处系数，看了一眼发现它是线性递推。需要先做一次取膜，线性递推可以爆力乘法，复杂度$O(2^nn+n^2\log m)$。

一个简单一点的做法是，注意到我们知道所有根，所以可以直接部分分式掉，就不需要法法塔做取膜了。使用线性逆元，复杂度$O(2^nn)$。

-----

abc241g

这是一个经典网络流问题。对每个人，让他剩下的比赛全赢，剩下的人不能赢更多次，然后一场比赛可以选择流到哪个人，每个比赛建一个点，每个人建一个点即可。复杂度大概是$O(n^4)$。

-----

abc240h

怎么还有串串呢。注意到不会有长度超过$\Theta(\sqrt{n})$的串，因为每个串的长度最多是上一个$+1$。然后对这些串排个序，求lis即可。

-----

abc240g

枚举每一维上走了多少步，如果走了$n$步，最后走出了$k$的距离，方案数是$\binom{n}{\frac{n-k}{2}}$，如果$2\not\mid n-k$则是$0$。然后就是三个东西卷起来，化一化发现是三个超几何函数卷起来提取$z^{\frac{n-x-y-z}{2}}$次项，它是d-finite的，贺个ode自动机即可。

-----

