---
layout: post
title: 未归类问题
subtitle: /kk
tags: 问题集
show: true
---

标题五个字/cf

-----

spoj CARD - Cardsharper

来自fajne zadania。

考虑每个元素会如何移动。在$a$上沿着一个环走，在$b$上同样沿着一个环走。

我们想起来一个经典问题，好像来自atc，说的是如果你能够转整个序列，或者转前三个元素，就可以排序。显然还有很多类似的东西。猜测我们总是可以生成绝大多数的排列。

事实证明确实是这样，在几乎所有情况下我们可以生成所有排列。但是我没有证明，并打算咕咕。

-----

cf1578l

这个题是牛逼老哥给我看的啊。

跑个mst先。二分答案先。

时间倒流。然后在kru重构树上往上走即可。

于是也不需要二分答案了。

-----

agc061a

先打表。观察小的感觉偶数的形式很好，这里给出16~30的偶数。

```
16
2 1 4 3 6 5 8 7 10 9 12 11 14 13 16 15 
18
2 1 3 4 5 6 7 8 9 10 11 12 13 14 15 16 18 17 
20
2 1(4 3)5 6 7 8 9 10 11 12 13 14 15 16 18 17 20 19 
22
2 1 3 4(6 5)7 8 9 10 11 12 13 14 15 16 18 17 19 20 22 21  
24
2 1(4 3)(6 5)(8 7)9 10 11 12 13 14 15 16 18 17 20 19 22 21 24 23 
26
2 1 3 4 5 6 7 8(10 9)11 12 13 14 15 16 18 17 19 20 21 22 23 24 26 25 
28
2 1(4 3)5 6 7 8(10 9)(12 11)13 14 15 16 18 17 20 19 21 22 23 24 26 25 28 27 
30
2 1 3 4(6 5)7 8(10 9)11 12(14 13)15 16 18 17 19 20 22 21 23 24 26 25 27 28 30 29 

```

可以注意到只可能是每对$2i-1,2i$交换，这是因为$\mathrm{shuffle}(1,n)=\mathrm{shuffle}(1,n-2),\mathrm{shuffle}(2,n-1),\mathrm{shuffle}(2,n-1),\mathrm{shuffle}(3,n)$，中间抵消了，然后归纳即可。括号标记的是除$n=16$之外，左半边非两头的交换了的位置。

$\mathrm{shuffle}(1,n-2),\mathrm{shuffle}(3,n)$，实际上就是把自己和自己平移一位之后每两个内部是否交换的状态$\operatorname{xor}$一下。于是我们看看$x\leftarrow x\operatorname{xor}(x\operatorname{shift}1)$是什么，把$\operatorname{xor}$看成加法膜$2$我们知道它是$F\leftarrow (1+z)F$，于是当我们想要一个位置的时候，提取出来是一个二项式系数膜$2$，可以用lucas定理算出它那里换没换。如果$n$是偶数那么做完了，如果$n$是奇数那么递归一层即可。

-----

cf717a

求$\sum\limits_{i=l}^r\binom{f_i}{k}$，其中$f$是fib数。

看起来很是不好做。考虑下降幂转普通幂，我们算$\sum\limits_{i=l}^rf_i^k$。尝试塞通项$c(a^n+b^n)$然后二项式定理，它就是$\sum\limits_{j=0}^k\binom{k}{j}\sum\limits_{i=l}^r(a^jb^{k-j})^i=\sum\limits_{j=0}^k\binom{k}{j}\frac{(a^jb^{k-j})^l-(a^jb^{k-j})^{r+1}}{1-a^jb^{k-j}}$，这里需要特判$a^jb^{k-j}=1$的情况。复杂度$O(k^2\log v)$，可以预处理一些东西然后线性求逆做到$O(k^2)$。

洛谷讨论区的题

$f$是$a,b$-fib数，也就是$f_i=af_{i-1}+bf_{i-2}$。

那么问题就是怎么求通项了。$F=azF+bz^2F+f_0+z(f_1-f_0)$，设后面是$p+zq$，那么$F=\frac{p+zq}{1-az-bz^2}$。那么我们知道上面的$a,b$这里就是$1-az-bz^2$的两个根，剩下的东西就乱算一通!

-----

cco2020 Shopping Plans

从xxiii poi stage 1 korale过来的。

首先每种买上最小的$x_j$个。然后第$k$小的钱数$d$，尝试搜出所有方案，我们要调整当前这个颜色到任意一个方案，可以通过在最右一个右边加入一个，或者把一个连续的后缀右移一位。

那么需要保证不能有重复的方案。为了做到这一点，考虑我们依次处理每个种类，也就是可以选择这个颜色的两种操作，或者移动到下一个颜色。我们需要保证移动到下一个颜色时能操作，所以按$2$和$1$位的差从大到小排，二分出可以到哪个后缀去。复杂度$O(n\log^2 n)$。

然后这东西也适用于那个扩展的想法，并且这样我们只需要二分$k$次。复杂度$O(n\log n)$。

-----

loj6500 雅礼集训18 D2 操作

牛逼群友给我看的。

考虑最左边那个数，它确定了最左边的区间是不是需要操作，如此往右递推就是$O(nm)$。

注意到如果我们操作了$[l,l+k)$之后其中还有$1$，必然继续操作下去，但是这个复合有点困难。

还是考虑差分吧!那么操作就是把$s_i,s_{i+k}$同时$\operatorname{xor}$上$1$。于是每个膜$k$等价类中的$1$需要两两配对，答案就是这个距离和，那么处理每个等价类中奇数位置和偶数位置的前缀和，查询的时候差分一下扫描线扫过去就好了。还需要判断是否可行，也就是两边在各等价类状态的奇偶性是否相同，hash一下即可。

-----

loj6736 最小连通块

这个题有一个牛逼做法啊。考虑我们可以$O(c(1+\log\frac{n}{c}))$地在$n$个点的树中找到一棵大小为$c$的子树中的所有点，然后我们还知道随机一个根和一个点，得到的子树大小期望是$<\frac{n}{2}$的，所以就$O(n\log n)$了。

-----

tjoi2017 城市

有趣题。首先我们必然断直径上的一条边，然后我们会连两边的直径中点，那么问题是怎么求两边的直径中点，随便取一个直径端点为根做一边的，考虑直径中点总是在到任何一个点距离最大的点上，那么dp求出直径长度，长链剖分，从重儿子到父亲直径端点会沿长链向上shift若干步，总移动量是线性。

-----

cf1776G

虽然反对出这种题，但是还是很厉害!

-----

An Optimal Algorithm for Calculating the Profit in the Coins in a Row Game

pa2010 Termites/hnoi2010 取石头游戏

题意是若干个序列，每个序列可能有一端是锚定的或者没有。两个人每次选一个序列，取走一端，如果是锚定的则只能最后取走，都希望自己获得的总和尽可能大。求最终A获得的减去B获得的。

或者说锚定一端的是栈，没有的是deque。

显然每个人选的个数是确定的。

翻译一下论文。

定义一个策略是状态到选择的映射。定义$\operatorname{val}(a,b)$是A采用策略$a$，B采用策略$b$得到的结果。

如果A固定使用策略$a$，那么结果就是$\min\limits_b\operatorname{val}(a,b)$。为了证明$a_1$不比$a_2$优，我们可以对于每个$b_2$，找到一个$b_1$使得结果不会更大。这里$a_2,b_1$都是我们自己选择的。也就是说我们把证明一个策略不优转化成了一个博弈问题。阅读定理1获得更好的体验。

设最大值是$m$。

**定理1** 如果某个$m$可以选，那么必然选它。

**证明** 使用上面那个方法，我们同时进行两个博弈，不妨称为$M_A$和$M_B$。在$M_B$中我们操纵B，而A先手选择了某个序列的某端$t$上的数$x_t$。在$M_A$中我们操纵A，我们让A先手选择一个$m$。根据上面的结论，我们就是要找到一个策略，使得$M_A$的结果总是不比$M_B$小。

首先操纵B在$M_B$中选择$m$。这也是为什么命名为$M$。

接下来进行若干轮，保持$M_B$比$M_A$多进行一步。每轮让对手在两个游戏中各走一步，然后我们反过来走，也就是说如果对手操纵B在$M_A$中选一个数，我们就操纵B在$M_B$中选同一个这样的。

对手选择了$t$的时候我们没法模仿了，因为两个博弈在$t$这里是不同的。不过可以修补一下 : 

 - 如果对手在$M_B$中操纵A选择$t$。我们也在$M_A$中操纵A选择$t$，尽管这两个元素不同。这样两个博弈在$t$上总是只差一个元素。

 - 如果对手在$M_A$中操纵B选择$t$(只考虑$t$上这个元素被选，而不一定是在$t$这一端选，也就是这个元素的另一端空了而选到它也算)。此时两个游戏的状态就相同了。那么算一算发现两个游戏的差距在于$M_A$中你选了$m$丢了$t$上最后一个元素。那么由于$m$最大，$M_A$是不劣的。

第二个case总会出现，否则$t$所在的序列永远不会选完。这就结束了。

**引理2** 如果$m$不能选，它的两边分别是$x,y$，那么如果一个人，不妨设为A，选了$x$，根据定理1，B必然选$m$，引理2断言接下来A必然选$y$。

**证明** 如法炮制。现在博弈$M_B$中A选择了$x$，我们操纵B选择了$m$。

和上面一样进行若干轮模仿。还是考虑何时不能模仿了。

 - 如果对手在$M_A$中操纵B选择$x$。那么我们操纵A选择$m$。由于$m$是最大的，$M_A$不劣。

 - 如果对手在$M_A$中操纵B选择$m$。这说明之前某个时刻有人在$M_A$中选择了$y$。那么我们考虑有人在$M_A$中选择$y$的时候应该怎么办。

   - 如果对手在$M_B$中操纵A选择了$y$(如果一直模仿，我们会模仿他在$M_A$中选择$y$)。如果$x$还没有被选，我们在$M_A$中操纵A选择$x$，那么对手必然跟着选$m$。不管$x$有没有被选，此时我们选择$y$。此时两个游戏完全一样了。

   - 如果对手在$M_A$中操纵B选择了$y$(此时$x$没被选，否则是case 1)。我们在$M_A$中选择$m$。归纳，那么对手必然在$M_A$中选择$x$。于是我们在$M_B$中选择$x$。此时两个游戏又完全一样了。

于是我们知道如果最大值是$m$且不能选，可以把它和两边的$x,y$合并成$x+y-m$。

那么现在我们已经可以解决没有锚定的情况了，也就是每次找到最大值做这样的。

**引理3** 如果$m$两侧是$x,y$，且$x,y$中某一个锚定，可以把它们合并成锚定的$x+y-m$。

**证明** 在引理2的证明中去掉case 2。

**引理4** 如果$m$是锚定的，它和$x$相邻，并且目前还剩$n$个数，可以把它们合并成锚定的$(-1)^n(x-m)$。

证明留作练习。

那么现在我们已经完全会做啦!开个堆就是$O(n\log n)$了。

考虑一些更强力的结论。

**定理2** 现在$m$不一定是$\max$。如果$m$没有锚定，左右是$x,y$，且$m>x,y$，那么可以把$x,m,y$合并成$x+y-m$，它锚定当且仅当$x,y$中有一个锚定。如果$m$锚定了，一侧是$x$，且$m>x$，那么可以把$x,m$合并成锚定的$(-1)^n(x-m)$。

**证明** 没太看懂。懒了。

所以我们只需要开个栈，每次拿出前三个看看能不能这么合并，然后就会把每个栈变成单调的，每个deque变成双调的。然后排序即可。

-----

icpc22 xi'an I. Square Grid

vp做到的。

考虑如果我们要横向移动$a$，纵向移动$b$，不妨认为$a,b\geq 0$，那么设往左$i$步，往下$j$步，则往右$i+a$步，往上$j+b$步。

如果$a+b$和$t$奇偶性不同，没救。

那么现在我们就是要求$\sum\limits_{2i+2j+a+b=t}\frac{t!}{i!(i+a)!j!(j+b)!}$。也就是$t![z^{t-a-b}]\left(\sum\frac{z^{2i}}{i!(i+a)!}\right)\left(\sum\frac{z^{2i}}{i!(i+b)!}\right)$。现在这是两个超几何函数，已经d-finite啦，所以我们会了$O(q\sqrt{t}\log t)$。

这时候就体现我的智障。考虑把$\frac{1}{i!j!}$扔进一个组合数，$\frac{1}{(i+a)!(j+b)!}$扔进一个组合数，这样就范德蒙德卷积了。分段打表一个$t!$和$\left(\frac{t}{2}\right)!$就结束了。所以为啥这个题过的这么少?

std好像不是分段打表而是快速阶乘捏。

-----

cf1461f

空跌给的。

感觉让人比较智障。

只有一种符号显然。$+,-$全填$+$。$\times,-$填$\times$直到第一个$0$，在这里填一个$-$，后面的全填$\times$。

$\times,+$。$0$两侧必然是$+$。考虑如果一些数的乘积$>nv$，这里$v$是$9$，那么我们必然是乘起来，不过如果两边有$1$我们会改成$+$。否则容易想到一个dp，求出前缀积然后李超树优化，但是这里斜率居然只有$\log(nv)$种，所以直接每个斜率维护最大的截距即可。复杂度$O(n\log(nv))$。

-----

thupc2021 鬼街

据说很经典!

感觉比较厉害啊。根据第一篇题解，考虑如果是有一个$>y$就触发，那就直接每个素数开个堆维护$y$最小的监控器。但是是和$>y$才触发，我们每个素数开个堆维护$\lceil\frac{y}{\omega(x)}\rceil$最小的监控器，那么一个监控器每弹一次，二分一下求出它是不是真的触发了，如果没触发，$y$必然已经减小到原来的$\frac{\omega(x)-1}{\omega(x)}$以下了，此时我们直接remake一下它。复杂度$n\omega(n)\log_{\frac{\omega(n)}{\omega(n)-1}}n\log n$。这里$\omega(n)=6$。

icpc19~20 hong kong I. Incoming Asteroids

一样的trick捏。

-----

xxii open cup gp of Yuquan G. Dynamic Reachability

时间分治。然后发现bitset的时候好像会影响很多点啊。

时间分块。每$K$个分一块，但是一个问题是怎么做到$qK$啊。发现我们好像不是很容易做到。考虑$\frac{qK^2}{w}$是简单的，我们只需要找到所有端点然后把它们之间的连通块拿出来跑一个bitset优化的bfs就好了。复杂度$O(\frac{n^\frac{4}{3}m}{w})$，这里认为$m,q$同阶。算量2e9，不多不少。

-----

ccpc2021 Weihai L. shake hands

考虑这个图有啥性质。发现如果$i,j$有边，$(i,j)$中每个点到$i,j$之一都有边。并且如果其中$k$到$i$有边，$l$到$j$有边，$i<j,k>l$，那么$k,l$必然有边。之类的东西。

这个东西好像没见过。考虑它的补有啥性质。如果原图中$i<j<k$，$i,j$没有边，$j,k$没有边，那么$i,k$也没有边。也就是说这个补是一个可比图。

可比图的最大独立集也就是最长反链。考虑经典的网络流建图，每个点拆成入点和出点跑最大匹配，那么这里只有$O(m)$条边不存在。这就没法用经典网络流算法了。不过有牛逼做法，考虑如果这个图很满我们就必然有完美匹配了，看看它需要有多满，hall定理，如果有$n$个点，我们选了一个大小为$k$的集合，那么每个点要删至少$n-k+1$条邻边，那取$k=n$就爆炸啦。注意到此时对面必然有一个度数非常大的点。考虑我们把删的度数$>K$的点都特殊处理，现在所有点删的度数$\leq K$，那么我们选大小$>K$的集合，邻接的必然是另一部所有点。此时每个点还是至少要删$n-K+1$条邻边，也就是说$K<n-K+1$就赢啦。

那么我们就把两边一起按删的度数从大到小排序，设为$d$，找到第一个$i$满足$d_i<n-i-d_i+1$。显然当$n$足够大，比如$n>\Theta(\sqrt{m})$，这样的点在$O(\frac{m}{n})$处就出现了；否则我们爆力dinic就是$O(n^\frac{5}{2})$。取根号分治的阈值为$\Theta(m^\frac{4}{7})$，对$i$和前面的这些点进行爆力匈牙利，每个点是$O(m)$的，复杂度$O(m^\frac{10}{7})$。现在左右都剩下至少$n-i$个点，而每个点删的度数都满足$d<n-i-d+1$，于是必然存在完美匹配。

如果要构造方案，好像我们还不会快速找到这个完美匹配。

**引理1** 如果每个点的度数$\geq\frac{n}{2}$，且现在不是完美匹配，则必然存在一条长$\leq 3$的增广路。

**证明** 考虑现在左部点$u$和右部点$v$还没匹配。如果有边$u\leftrightarrow v$，那就赢了。

如果到处都没有这么一条边。那么$u$的所有邻接点都匹配了，$v$的所有邻接点都匹配了。由于每个点的度数足够大，必然存在一个$u$的邻接点$x$和一个$v$的邻接点$y$匹配。这就找到了长$3$的增广路。

上面那个条件$d<n-d+1$就等价于每个点删剩下的度数$\geq\frac{n}{2}$。考虑如何利用这东西。先处理所有长$1$的增广路，让每条边的至少一个端点在匹配中。然后枚举长$3$增广路的中间那条边，在两侧各找一个未匹配点。关键的观察是这样产生的新的匹配边不会再出现在长$3$的增广路中，因为在第一步中，它的端点的邻接点都已经是匹配点了。复杂度线性。

-----

loj3657 集训队胡策2021 挑战分解质因数

考虑$pq$怎么做。也就是我们知道$pq$和$(p-1)(q-1)=pq-p-q+1$。那么我们就知道$p+q$。那么就可以用韦达定理构造一下了。

考虑无平方因数怎么做。感觉不好做啊。

感觉比较厉害。考虑一个类似于mr的想法，我们知道如果$a\perp n$，那么$a^{\varphi(n)}\bmod{n}=1$。设$\varphi(n)=2^km$，那么把$1$移过来并平方差，我们又有了$(a^m-1)\prod\limits_{i=0}^{k-1}(a^{2^im}+1)=0$。如果这些项中有一个$0$，那就不好，否则由于它们都不是$0$而乘积是$0$，我们都和$n$取一下gcd就找到了$n$的一个因数。

看一眼[二次探测定理的证明](https://shanlunjiajian.github.io/2021/11/03/primes/#miller-rabin)，发现它确实说明成功的概率是$\frac{3}{4}$。

-----

usaco23feb Pt A. Hungry Cow

看起来是单侧递归线段树例题。以前是管它叫类楼房重建的，从今天开始我要改叫单侧递归了。

看起来我们需要考虑一个点左边留下的非$0$的情况。考虑左儿子区间中有多少个$0$，如果左边来的比这些要多，那么左儿子就被填满了，只需要递归右儿子。否则左儿子留下的是固定的，每个点维护此时右儿子的情况即可。

-----

icpc2020 Shenyang L. Forged in the Barrens

dag定长最短路。很遗憾这东西显然并不四边形不等式。

考虑极差有啥性质。想起最大化极差的一个经典做法是改成任意两个数的差，然后就可以费用流了，这里需要拆点保证包含每个点的区间只有一个。那么我们知道答案是凸的。然后可以写个dp，分治闵和，或者直接模拟费用流。这里只可能在有东西的一段或空的一段中间选或者在相邻的 有东西的一段和空的一段 之间选，线段树支持查询区间左边选一个贡献负，右边选一个贡献正，或者反过来的最大值，然后开个堆模拟即可。

-----

cco2018 Boring Lectures

时间分治。插入一个数，找到附近的$\max$并尝试更新答案即可。一开始先用单调队列扫个答案出来，复杂度$O(n+q\log^2 n)$。

多头给了一个牛逼做法。考虑按$k$大小分块，那么我们断言答案中两个数在其所在块中必然是最大或次大。对于同一块的情况显然正确，对于不同块的情况，如果我们选择了$x,y$，两块的最大值分别是$a,b$，那么选择$a,x$或$b,y$必然不劣，否则我们知道$a<y,b<x,x<a,y<b$，这就成环啦。

<<<<<<< Updated upstream
=======
-----

slyzoj485 未知来源题

简化之后是，仙人掌，每条边都在至少一个简单环上，求所有点对间最小割的和。

那我们必然割环，割环的话必然割最小的那条边，所以把它先割掉，把它的边权加到同一环的所有边上，然后按树做。树是经典的。

-----

区间平面最近点对

大家都会平面最近点对。考虑按$d$大小把平面分成若干$d\times d$的矩形，那么如果一个矩形中有两个点，就给出一个$\leq \sqrt{2}d$的方案。取$d$为各$\lfloor\sqrt{2}2^k\rfloor$，从大到小枚举一个$d$看是否存在一个矩形中有两个点，那么对每个矩形排序之后，只有每两个序列上位置相邻的点需要贡献，BiT数数就好啦。现在每个矩形中有最多一个点，可以看到的是每个矩形最多和周围$5\times 5$并挖掉四角的矩形产生贡献，并且由于每个矩形中有最多一个点，我们现在处理矩形$A$中的$a$和矩形$B$，只有$B$中出现位置离$a$最近的两个点有用，更远的如果和$a$贡献，就说明$B$中不止一个点。复杂度$O(n\log^2 n)$，但是常数太大，多叉树或者根号平衡会变快。

-----

区间一维最近点对，随机数据

还是考虑按$d$大小把数轴分成若干长$d$的区间，那么如果一个区间中有两个点，
>>>>>>> Stashed changes
