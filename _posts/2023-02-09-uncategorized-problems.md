---
layout: post
title: 未归类问题
subtitle: /kk
tags: 问题集
---

标题五个字/cf

-----

spoj CARD - Cardsharper

来自fajne zadania。

考虑每个元素会如何移动。在$a$上沿着一个环走，在$b$上同样沿着一个环走。

我们想起来一个经典问题，好像来自atc，说的是如果你能够转整个序列，或者转前三个元素，就可以排序。显然还有很多类似的东西。猜测我们总是可以生成绝大多数的排列。

考虑能不能把$a$变成一个简单一点的东西。我们尝试把它变成一个环。如果$a$中能找到一个环，满足剩下的环长度都和它的长度互素，那么我们取剩下的环长度的$\mathrm{lcm}$次幂就赢了。当然如果这个环长度是$1$则不行。这个条件还是很难满足。

考虑

-----

cf1578l

这个题是牛逼老哥给我看的啊。

跑个mst先。二分答案先。

时间倒流。然后在kru重构树上往上走即可。

于是也不需要二分答案了。

-----

agc061a

先打表。观察小的感觉偶数的形式很好，这里给出16~30的偶数。

```
16
2 1 4 3 6 5 8 7 10 9 12 11 14 13 16 15 
18
2 1 3 4 5 6 7 8 9 10 11 12 13 14 15 16 18 17 
20
2 1(4 3)5 6 7 8 9 10 11 12 13 14 15 16 18 17 20 19 
22
2 1 3 4(6 5)7 8 9 10 11 12 13 14 15 16 18 17 19 20 22 21  
24
2 1(4 3)(6 5)(8 7)9 10 11 12 13 14 15 16 18 17 20 19 22 21 24 23 
26
2 1 3 4 5 6 7 8(10 9)11 12 13 14 15 16 18 17 19 20 21 22 23 24 26 25 
28
2 1(4 3)5 6 7 8(10 9)(12 11)13 14 15 16 18 17 20 19 21 22 23 24 26 25 28 27 
30
2 1 3 4(6 5)7 8(10 9)11 12(14 13)15 16 18 17 19 20 22 21 23 24 26 25 27 28 30 29 

```

可以注意到只可能是每对$2i-1,2i$交换，这是因为$\mathrm{shuffle}(1,n)=\mathrm{shuffle}(1,n-2),\mathrm{shuffle}(2,n-1),\mathrm{shuffle}(2,n-1),\mathrm{shuffle}(3,n)$，中间抵消了，然后归纳即可。括号标记的是除$n=16$之外，左半边非两头的交换了的位置。

$\mathrm{shuffle}(1,n-2),\mathrm{shuffle}(3,n)$，实际上就是把自己和自己平移一位之后每两个内部是否交换的状态$\operatorname{xor}$一下。于是我们看看$x\leftarrow x\operatorname{xor}(x\operatorname{shift}1)$是什么，把$\operatorname{xor}$看成加法膜$2$我们知道它是$F\leftarrow (1+z)F$，于是当我们想要一个位置的时候，提取出来是一个二项式系数膜$2$，可以用lucas定理算出它那里换没换。如果$n$是偶数那么做完了，如果$n$是奇数那么递归一层即可。

-----

cf717a

求$\sum\limits_{i=l}^r\binom{f_i}{k}$，其中$f$是fib数。

看起来很是不好做。考虑下降幂转普通幂，我们算$\sum\limits_{i=l}^rf_i^k$。尝试塞通项$c(a^n+b^n)$然后二项式定理，它就是$\sum\limits_{j=0}^k\binom{k}{j}\sum\limits_{i=l}^r(a^jb^{k-j})^i=\sum\limits_{j=0}^k\binom{k}{j}\frac{(a^jb^{k-j})^l-(a^jb^{k-j})^{r+1}}{1-a^jb^{k-j}}$，这里需要特判$a^jb^{k-j}=1$的情况。复杂度$O(k^2\log v)$，可以预处理一些东西然后线性求逆做到$O(k^2)$。

洛谷讨论区的题

$f$是$a,b$-fib数，也就是$f_i=af_{i-1}+bf_{i-2}$。

那么问题就是怎么求通项了。$F=azF+bz^2F+f_0+z(f_1-f_0)$，设后面是$p+zq$，那么$F=\frac{p+zq}{1-az-bz^2}$。那么我们知道上面的$a,b$这里就是$1-az-bz^2$的两个根，剩下的东西就乱算一通!

-----

cco2020 Shopping Plans

从xxiii poi stage 1 korale过来的。

首先每种买上最小的$x_j$个。然后第$k$小的钱数$d$，尝试搜出所有方案，我们要调整当前这个颜色到任意一个方案，可以通过在最右一个右边加入一个，或者把一个连续的后缀右移一位。

那么需要保证不能有重复的方案。为了做到这一点，考虑我们依次处理每个种类，也就是可以选择这个颜色的两种操作，或者移动到下一个颜色。我们需要保证移动到下一个颜色时能操作，所以按$2$和$1$位的差从大到小排，二分出可以到哪个后缀去。复杂度$O(n\log^2 n)$。

然后这东西也适用于那个扩展的想法，并且这样我们只需要二分$k$次。复杂度$O(n\log n)$。

-----

loj6500 雅礼集训18 D2 操作

牛逼群友给我看的。

考虑最左边那个数，它确定了最左边的区间是不是需要操作，如此往右递推就是$O(nm)$。

注意到如果我们操作了$[l,l+k)$之后其中还有$1$，必然继续操作下去，但是这个复合有点困难。

还是考虑差分吧!那么操作就是把$s_i,s_{i+k}$同时$\operatorname{xor}$上$1$。于是每个膜$k$等价类中的$1$需要两两配对，答案就是这个距离和，那么处理每个等价类中奇数位置和偶数位置的前缀和，查询的时候差分一下扫描线扫过去就好了。还需要判断是否可行，也就是两边在各等价类状态的奇偶性是否相同，hash一下即可。

-----

loj6736 最小连通块

这个题有一个牛逼做法啊。考虑我们可以$O(c(1+\log\frac{n}{c}))$地在$n$个点的树中找到一棵大小为$c$的子树中的所有点，然后随机一个根和一个点，得到的子树大小期望是$<\frac{n}{2}$的，所以就$O(n\log n)$了。

-----

tjoi2017 城市

有趣题。首先我们必然断直径上的一条边，然后我们会连两边的直径中点，那么问题是怎么求两边的直径中点，随便取一个直径端点为根做一边的，考虑直径中点总是在到任何一个点距离最大的点上，那么dp求出直径长度，长链剖分，从重儿子到父亲直径端点会沿长链向上shift若干步，总移动量是线性。

-----

cf1776G

虽然反对出这种题，但是还是很厉害!

-----

An Optimal Algorithm for Calculating the Profit in the Coins in a Row Game

pa2010 Termites/hnoi2010 取石头游戏

题意是若干个序列，每个序列可能有一端是锚定的或者没有。两个人每次选一个序列，取走一端，如果是锚定的则只能最后取走，都希望自己获得的总和尽可能大。求最终A获得的减去B获得的。

或者说锚定一端的是栈，没有的是deque。

显然每个人选的个数是确定的。

翻译一下论文。

定义一个策略是状态到选择的映射。定义$\operatorname{val}(a,b)$是A采用策略$a$，B采用策略$b$得到的结果。

如果A固定使用策略$a$，那么结果就是$\min\limits_b\operatorname{val}(a,b)$。为了证明$a_1$不比$a_2$优，我们可以对于每个$b_2$，找到一个$b_1$使得结果不会更大。这里$a_2,b_1$都是我们自己选择的。也就是说我们把证明一个策略不优转化成了一个博弈问题。阅读定理1获得更好的体验。

设最大值是$m$。

**定理1** 如果某个$m$可以选，那么必然选它。

**证明** 使用上面那个方法，我们同时进行两个博弈，不妨称为$M_A$和$M_B$。在$M_B$中我们操纵B，而A先手选择了某个序列的某端$t$上的数$x_t$。在$M_A$中我们操纵A，我们让A先手选择一个$m$。根据上面的结论，我们就是要找到一个策略，使得$M_A$的结果总是不比$M_B$小。

首先操纵B在$M_B$中选择$m$。这也是为什么命名为$M$。

接下来进行若干轮，保持$M_B$比$M_A$多进行一步。每轮让对手在两个游戏中各走一步，然后我们反过来走，也就是说如果对手操纵B在$M_A$中选一个数，我们就操纵B在$M_B$中选同一个这样的。

对手选择了$t$的时候我们没法模仿了，因为两个博弈在$t$这里是不同的。不过可以修补一下 : 

 - 如果对手在$M_B$中操纵A选择$t$。我们也在$M_A$中操纵A选择$t$，尽管这两个元素不同。这样两个博弈在$t$上总是只差一个元素。

 - 如果对手在$M_A$中操纵B选择$t$(只考虑$t$上这个元素被选，而不一定是在$t$这一端选，也就是这个元素的另一端空了而选到它也算)。此时两个游戏的状态就相同了。那么算一算发现两个游戏的差距在于$M_A$中你选了$m$丢了$t$上最后一个元素。那么由于$m$最大，$M_A$是不劣的。

第二个case总会出现，否则$t$所在的序列永远不会选完。这就结束了。

**引理2** 如果$m$不能选，它的两边分别是$x,y$，那么如果一个人，不妨设为A，选了$x$，根据定理1，B必然选$m$，引理2断言接下来A必然选$y$。

**证明** 如法炮制。现在博弈$M_B$中A选择了$x$，我们操纵B选择了$m$。

和上面一样进行若干轮模仿。还是考虑何时不能模仿了。

 - 如果对手在$M_A$中操纵B选择$x$。那么我们操纵A选择$m$。由于$m$是最大的，$M_A$不劣。

 - 如果对手在$M_A$中操纵B选择$m$。这说明之前某个时刻有人在$M_A$中选择了$y$。那么我们考虑有人在$M_A$中选择$y$的时候应该怎么办。

   - 如果对手在$M_B$中操纵A选择了$y$(如果一直模仿，我们会模仿他在$M_A$中选择$y$)。如果$x$还没有被选，我们在$M_A$中操纵A选择$x$，那么对手必然跟着选$m$。不管$x$有没有被选，此时我们选择$y$。此时两个游戏完全一样了。

   - 如果对手在$M_A$中操纵B选择了$y$(此时$x$没被选，否则是case 1)。我们在$M_A$中选择$m$。归纳，那么对手必然在$M_A$中选择$x$。于是我们在$M_B$中选择$x$。此时两个游戏又完全一样了。

于是我们知道如果最大值是$m$且不能选，可以把它和两边的$x,y$合并成$x+y-m$。

那么现在我们已经可以解决没有锚定的情况了，也就是每次找到最大值做这样的。

**引理3** 如果$m$两侧是$x,y$，且$x,y$中某一个锚定，可以把它们合并成锚定的$x+y-m$。

**证明** 在引理2的证明中去掉case 2。

**引理4** 如果$m$是锚定的，它和$x$相邻，并且目前还剩$n$个数，可以把它们合并成锚定的$(-1)^n(x-m)$。

证明留作练习。

那么现在我们已经完全会做啦!开个堆就是$O(n\log n)$了。

考虑一些更强力的结论。

**定理2** 现在$m$不一定是$\max$。如果$m$没有锚定，左右是$x,y$，且$m>x,y$，那么可以把$x,m,y$合并成$x+y-m$，它锚定当且仅当$x,y$中有一个锚定。如果$m$锚定了，一侧是$x$，且$m>x$，那么可以把$x,m$合并成锚定的$(-1)^n(x-m)$。

**证明** 没太看懂。懒了。

所以我们只需要开个栈，每次拿出前三个看看能不能这么合并，然后就会把每个栈变成单调的，每个deque变成双调的。然后排序即可。

-----

icpc22 asia xi'an I. Square Grid

vp做到的。

考虑如果我们要横向移动$a$，纵向移动$b$，不妨认为$a,b\geq 0$，那么设往左$i$步，往下$j$步，则往右$i+a$步，往上$j+b$步。

如果$a+b$和$t$奇偶性不同，没救。

那么现在我们就是要求$\sum\limits_{2i+2j+a+b=t}\frac{t!}{i!(i+a)!j!(j+b)!}$。也就是$t![z^{t-a-b}]\left(\sum\frac{z^{2i}}{i!(i+a)!}\right)\left(\sum\frac{z^{2i}}{i!(i+b)!}\right)$。现在这是两个超几何函数，已经d-finite啦，所以我们会了$O(q\sqrt{t}\log t)$。

这时候就体现我的智障。考虑把$\frac{1}{i!j!}$扔进一个组合数，$\frac{1}{(i+a)!(j+b)!}$扔进一个组合数，这样就范德蒙德卷积了。分段打表一个$t!$和$\left(\frac{t}{2}\right)!$就结束了。所以为啥这个题过的这么少?

std好像不是分段打表而是快速阶乘捏。

-----

cf1461f

空跌给的。

感觉让人比较智障。

只有一种符号显然。$+,-$全填$+$。$\times,-$填$\times$直到第一个$0$，在这里填一个$-$，后面的全填$\times$。

$\times,+$。$0$两侧必然是$+$。考虑如果一些数的乘积$>nv$，这里$v$是$9$，那么我们必然是乘起来，不过如果两边有$1$我们会改成$+$。否则容易想到一个dp，求出前缀积然后李超树优化，但是这里斜率居然只有$\log(nv)$种，所以直接每个斜率维护最大的截距即可。复杂度$O(n\log(nv))$。

-----

thupc2021 鬼街

据说很经典!

感觉比较厉害啊。根据第一篇题解，考虑如果是有一个$>y$就触发，那就直接每个素数开个堆维护$y$最小的监控器。但是是和$>y$才触发，我们每个素数开个堆维护$\lceil\frac{y}{\omega(x)}\rceil$最小的监控器，那么一个监控器每弹一次，二分一下求出它是不是真的触发了，如果没触发，$y$必然已经减小到原来的$\frac{\omega(x)-1}{\omega(x)}$以下了，此时我们直接remake一下它。复杂度$n\omega(n)\log_{\frac{\omega(n)}{\omega(n)-1}}n\log n$。这里$\omega(n)=6$。

icpc19~20 hong kong regional I. Incoming Asteroids

一样的trick捏。

-----

xxii open cup gp of Yuquan G. Dynamic Reachability

时间分治。然后发现bitset的时候好像会影响很多点啊。

时间分块。每$K$个分一块，但是一个问题是怎么做到$qK$啊。发现我们好像不是很容易做到。考虑$\frac{qK^2}{w}$是简单的，我们只需要找到所有端点然后把它们之间的连通块拿出来跑一个bitset优化的bfs就好了。复杂度$O(\frac{n^\frac{4}{3}m}{w})$，这里认为$m,q$同阶。算量2e9，不多不少。