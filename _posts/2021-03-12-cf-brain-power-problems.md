---
layout: post
title: CF思维题选㗅
subtitle: 不想上GM的Newbie不是好Newbie
tags: 思维 题选做
---

再开一个坑，整合各种各样的思维题。

CF脑力题选做!(你可以看到URL里面是cf-brain-power-problems)

-----

1495F : 好奇妙!我以为我开了一道2600，其实是一道3300/kk

出题人思维能力好强啊，我要膜拜出题人，不过官方题解写的好简单/kk

官方题解要是硬翻译成人话的话，大概是下面这样。

我们将第一种走法称为 一小步 ，第二种是 一大步 。

考虑这个$$p$$相当于一个高度，走一大步就是往右上方第一个点走。

我们发现，"一大步能走到"具有传递性，"一大步走不到"也具有传递性。也就是说如果$$i<j<k$$满足$$i$$走不到$$j$$，$$j$$走不到$$k$$，那么就有$$p_i>p_j>p_k$$，所以$$i$$也走不到$$k$$。

考虑一棵树，每个点$$i$$连向它左边第一个一大步走不到它的结点$$j$$，如果没有这样的$$j$$则连向$$0$$。由于"一大步走不到"的传递性，我们站在点$$i$$走一大步，将会跨过子树里的所有点。

接下来是四个人类可读的定理，稍微有点绕，请耐心读完。

-----

**定理1** 每个点$$i$$的子树里面编号一定是一个从$$i+1$$开始的区间。

**证明** 考虑每个点$$i$$子树里面的点都是它右下方的点，那么按编号走，走到的第一个子树外的点一定在这个点右上方，不然它应该还在$$i$$这个点子树里面。

考虑如果不是一个区间，那么一定存在一个位置$$j$$使得它前面一直到$$i$$全是子树内的点，后面还有子树内的点，而它自己是子树外的点。

那么我们知道一定有$$p_i<p_j$$，那么假设后面有个点$$k$$在$$i$$的子树里，我们知道$$p_i>p_k$$，所以$$p_j>p_k$$，所以$$k$$应该先连向$$j$$。

-----

**定理2** 如果一个点$$i$$有儿子，那么一定有$$i+1$$这个儿子。

**证明** 如果没有$$i+1$$这个儿子，父亲的编号还要比儿子大，那么$$i+1$$就不可能在子树中，而子树还要是$$i+1$$开始的区间，那么就没有子树，也就没有儿子了。

-----

**定理3** 走一小步是dfs树的过程。

**证明** 归纳法。考虑点$$0$$，我们假设它有$$k$$个儿子，每个的子树分别是$$[1,t_1],[t_1+1,t_2],...,[t_{k-1}+1,n]$$，那么我们知道一棵子树的最后一个点$$t_i$$走一小步之后一定会进入下一棵子树，所以从$$0$$的视角看是进行了dfs，那么根据dfs的递归性质可以知道每个点看来都在dfs。

-----

**定理4** 在点$$i$$走一大步，相当于在dfs树的过程中跳过了$$i$$的子树。

**证明** 假设$$i$$的子树是$$[i+1,j]$$，那么我们就是想要证明$$i$$走一大步会走到$$j+1$$。

如果$$i$$不能通过若干一大步走到$$j+1$$，那么$$p_i>p_{j+1}$$，那么$$j+1$$的父亲要么是$$i$$，要么在$$[i+1,j]$$里面，那么$$j+1$$一定在$$i$$的子树里。这是矛盾的，因为跳过子树之后要么走到兄弟要么回溯祖先并走到祖先的兄弟，不可能进入子树。所以$$i$$一定可以通过若干一大步走到$$j+1$$。

而$$i$$又不能一大步走到$$[i+1,j]$$，所以要想通过超过一个大步走到$$j+1$$中间也没有点可以中转，所以$$i$$走一大步一定会走到$$j+1$$。

-----

我们似乎已经对这棵树的结构有了一定了解。

以下开始全是口胡而不是翻译，我没有实现过，不知道正确性。

现在问题已经变成了，有一棵树，现在你要遍历这棵树，走一小步可以按照dfs序走到下一个结点，走一大步可以直接跳过整棵子树，有一些点必须走到，求走完的最小代价。当然树的根是$$0$$，并且$$0$$走一大步的代价是$$+\infty$$。

我们考虑如果一个点需要被走到，它所有祖先都不能选择跳过子树。每个点只可能走一小步，一大步或者不被经过，所以每次加入一个点，相当于强制要求父亲走一小步；删除就是取消这个要求。

我们设一个dp。令$$f(u)$$表示从$$u$$点出发走一小步，走完子树的最小代价；$$dp(u)$$则允许第一步随便走。那么我们有

$$
\begin{aligned}
f(u)&=\sum_{v\in\mathrm{son}(u)}dp(v)\\
dp(u)&=\min(f_u,b_u)
\end{aligned}
$$

那么你发现，如果强制要求$$u$$走一小步，那么$$\mathrm{fa}(u)$$开始走完子树的代价应该是$$f(\mathrm{fa}(u))+f(u)-dp(u)$$。

如果强制要求$$u$$的一堆儿子$$v_1,...,v_m$$走一小步，那么$$u$$开始走完子树的代价应该是$$f(u)+\sum_{i=1}^m(f(v_i)-dp(v_i))$$。

所以当某个结点是否需要走一小步的要求变化了的时候，我们可以按照上面的式子更新所有祖先的代价。你发现这个转移是ddp的形式，所以我们可以拍个板子搞定它。复杂度$$O(n\log n)$$。

-----

不过官方题解还有更简单的做法，我们继续考虑上面的性质。

先不管哪些点一定要走一小步，如果我现在选出了一个走一小步的点的集合$$H$$，剩下的点都不走或者走一大步，那么首先这个$$H$$必然是包含$$0$$的一个连通块，同时如果它是一个这样的连通块，它一定唯一对应一种走法。

考虑一个方案的代价是 : 

$$
\sum_{u\in H}a_u+\sum_{\mathrm{fa}(u)\in H,u\notin H}b_u
$$

这个$$u\notin H$$看起来比较难处理，我们容斥一下 : 

$$
=\sum_{u\in H}a_u+\sum_{\mathrm{fa}(u)\in H}b_u-\sum_{\mathrm{fa}(u)\in H,u\in H}b_u+\sum_{\mathrm{fa}(u)\notin H,u\in H}b_u
$$

发现一个事情，如果一个点的父亲不在$$H$$里面，这个点一定不在$$H$$里面；如果一个点在$$H$$里面，父亲一定在$$H$$里面，所以可以化简上式 : 

$$
\begin{aligned}
=&\sum_{u\in H}a_u+\sum_{\mathrm{fa}(u)\in H}b_u-\sum_{u\in H}b_u\\
=&\sum_{u\in H}(a_u-b_u)+\sum_{\mathrm{fa}(u)\in H}b_u\\
=&\sum_{u\in H}(a_u-b_u+\sum_{v\in\mathrm{son}(u)}b_v)
\end{aligned}
$$

设$$c_u=a_u-b_u+\sum_{v\in\mathrm{son}(u)}b_v$$，我们就相当于对$$H$$里面所有点的$$c$$求和。

问题变成，给一棵树，求一个连通点集$$H$$，有一些点(一定有根)必须在点集中，使得$$c$$的和最小。

$$c$$不一定是正的，所以我们不能直接贪心，可以考虑dp一下。

我们设$$f(u)$$表示$$u$$子树中强制包含$$u$$的最小连通块大小，有

$$
f(u)=c_u+\sum_{v\in\mathrm{son}(u)}\max(f(v),0)
$$

那么答案就是$$f(0)$$。接下来如果一个点必须选，它的权值就要改成$$-\infty$$，最后我们再把原来的权值搞回来，这个可以ddp维护，或者有人说也可以直接用BiT之类的，我不是很懂。复杂度还是$$O(n\log n)$$。

-----

好了我们翻译完了。你可能要问，是怎么想到建一棵这么奇怪的树的?

实际上"一大步走不到"和"一大步可以走到"是完全对称的，如果你把序列翻转过来，题解的这棵树就变成了走一大步走到的结点串成的树。

然后两个性质也要反过来，于是就变成了，倒着走一小步是dfs树，倒着走到 左边第一个不能走到这个点的点 是跳过子树。

但是倒着不能走实在是比较奇怪，所以我们把序列和树转过来变成正着可以走，这个思想大概是，原问题性质不好或者比较难想，可以考虑对称或者对偶的问题。

-----

这个题好爽啊，我都不舍得换题了，差点把这篇改成1495F题解（

-----

下面就是筛选2600+，constructive algorithms，并且按照通过人数降序做的了。

741C : 我是垃圾!第一感觉是随机调整（

看到只有两种菜，想到二分图，想到黑白染色，我们先给每对情侣连边，然后给每三个人......

不对啊!这个没法直接加边~~!加边!加边!~~。我们可以考虑一个强化，从每个$$2k-1$$向$$2k$$连边，这样搞出来一定满足三个人不都相同。

不过这样可能会丢失解。观察样例发现没有-1，我们可以猜测一定有解，接下来就是要证明这个算法生成的一定是二分图。

因为每个人只有一个npy，所以每个人的度数都是$$2$$，一条边连向npy，一条边连向相邻的同志。所以每个环一定是两类边交替，那么它的长度就一定是偶数。

-----

1375F : 这是一道数学题。

样例选择先手，那我们当然先考虑选择先手。

根据CF的一贯传统，先手大概可以在几步之内必杀。

我们倒着做。考虑每次后手都可以动两堆，如果后手不得不做出两堆相同的，那么可以动的两堆都必须是动了之后就出现相同的。想一想容易发现只有这一种情况 : 

$$
a-k,a,(a+k)
$$

(用括号表示不能动的一堆)。既然$$k$$是你自己选，那么我们知道如果拼成了一个首项不能选的等差数列，你就赢了。

接下来，如果拼成了这样的等差数列，那么......我们来分分情况。假设三堆大小分别是$$x,y,z$$，如果要变成$$a-k,a,(a+k)$$，一定是有一堆操作之后变成了最大的。我们假设你这次操作数是$$t$$。

1. $$x+t=a+k,y=a-k,z=a$$

我们显然是要解出$$t$$来。根据中间我们知道$$k=z-y$$，所以代入左边就得到$$t=z+z-y-x=2z-x-y$$。

还需要分类吗，既然我们已经解出来了?

实际上是需要的，因为我们需要知道我们要限制哪两个数可以操作。

2. $$x=a-k,y+t=a+k,z=a$$

解得$$t=2z-x-y$$。跟上面一样。

3. $$x=a-k,y=a,z+t=a+k$$

解得$$t=2y-x-z$$，不太一样，所以说我们应该取上面两种情况。

任务变成限制最大的不能操作，所以我们第一次操作只要加一个巨大的数，让被操作的数变成最大的就行了。

-----

547D : 