---
layout: post
title: 二轮省集
subtitle: /kk
tags: 课
---

## Day1

### 模拟赛

T1 麻将

给一个01串，求最短的没有作为子串出现过的01串，多解输出字典序最小的。$$n\leq 2^24$$，0.2s。

省选计划原题（

考虑答案长度不会超过$$24$$，从大到小枚举答案，问题变成求长$$k$$子串的$$\mathrm{mex}$$，维护一个值域`bool`数组表示每种子串是否存在就好了。你发现长$$k$$的只有$$2^k$$种，所以就$$O(n)$$了。

-----

T2 德州扑克

平面上有一些线段，每次给一个横平竖直的矩形，查矩形内的线段长度除以总线段长度。保证任意两条线段不交，并且每条线段不是横平竖直的。$$n,q\leq 10^5$$，2s。

首先可以把矩形差分掉，问题变成求一个点左下方的线段长度。

先只考虑斜率为正的线段，负的可以反着跑。可以发现固定一个查询点的话，有贡献的线段只有三种 : 

 - 完全在查询点左下方的

 - 穿过上边界的

 - 穿过右边界的

第一种可以直接转成二维数点，第二种和第三种类似，只考虑第三种。

扫描线。从左往右扫过平面，用平衡树维护线段。不相交就非常好!

考虑扫描线右移的变化量，发现每条线段的变化量是一样的，所以相当于要平衡树支持全局带系数加，查询区间历史和。直接做就好了。

复杂度$$O(n\log n)$$。

-----

T3 将棋

给一棵树，边有边权，每次给一个点集，查询这个点集的斯坦呐树上，有多少种方案选择两条不同的边，使它们边权相同。$$(a,b),(b,a)$$看作同一种方案。$$n,q\leq 10^5$$，2s。

不管怎么着，先想想有没有单次询问只关于点集大小的做法。考虑这个斯坦呐树可以拆分成若干链，条数是线性的。每条链内部可以括号序莫队搞定，链之间可以差分成到根的四条链之间的贡献，也可以莫队搞定。现在问题是链之间贡献次数是平方级别。

考虑进行分治，点集大小很大的时候$$O(n)$$暴力，小的时候用上面的算法，取阀值$$\Theta(n^{\frac{1}{3}})$$，复杂度可以搞到$$O(n^{\frac{5}{3}})$$。当然认为$$n,m$$同阶。

另一个做法是，继续对颜色出现次数根号分治来代替上面链之间的莫队，然后就可以做到$$O(n\sqrt{n}\log n)$$了!

啊具体就是，把颜色分成大颜色和小颜色。大颜色数量很少可以预处理前缀和然后直接查，小颜色可以枚举一对考虑贡献，发现如果$$(u,v)$$同是一个小颜色，那么两条到根的链之间有贡献，当且仅当它们的端点分别在$$u,v$$的子树中。然后子树是dfn的区间，所以就变成了矩形$$+1$$单点查询。

然后对查询也修改根号分治的阀值到$$\Theta(\sqrt{n})$$，就相当于是$$O(n\sqrt{n})$$次矩形$$+1$$和单点查询，直接扫描线，复杂度是$$O(n\sqrt{n}\log n)$$。好像可以把$$\log$$放到根号下面，但是我不会/cy

### 讲课

分治数据结构。

区间的笛卡尔积是矩形，换句话说如果看到 一个东西有贡献，当且仅当查询区间左右端点分别在两个区间内，就可以想到$$(l,r)$$应该在这两个区间的笛卡尔积内，所以就可以上二维数点。

-----

EC Final2020 G

给一个序列，每次给一个区间，查询多少子区间颜色数是奇数。

这个东西等于，区间所有子区间颜色数膜$$2$$的和。

扫描线。考虑插入$$i$$的时候，只有左端点在$$[pre_i+1,i]$$这一段区间的询问会多出来$$a_i$$这种颜色，所以相当于区间异或，查询区间历史和，搞就是了。

-----

神必题

神必题讲啥啊（

-----

JOISC2021 饮食区

有一排队列，支持区间连续push/pop $$k$$次，如果pop超了那就直接pop空，查询某个队列里第$$k$$个数。

扫描线扫序列，数据结构维护时间。发现一次区间修改会在左端点被激活，在右端点右边被不激活，也就是两次单点修改。

考虑我们需要支持什么查询。

你发现如果我们不考虑 弹超了 这件事，也就是每次弹出都会弹恰好那么多，那么可以从查询的时间出发向前线段树二分找到第一个$$\geq k$$的后缀和，那么这个位置就是答案，所以维护最大后缀和即可。

如果考虑弹超，需要找到最后一次弹超了的操作，此后就可以消去弹超的影响，这个可以维护最小前缀和。线段树即可。

-----

hdu5118 GRE Words Once More!

给一个DAG，点从$$1$$到$$n$$标号；有一些点是被标记的。每次查询一个$$k$$，求从点$$1$$开始、截止于一个被标记结点的路径中，编号字典序第$$k$$小的路径长度。$$n\leq 10^5,k\leq 10^{18}$$。

图剖!好像写过来着。

另一种做法是可持久化平衡树，它支持$$O(\log\text{结点数})$$的复制、拼接。

考虑拓扑排序，每一个点$$u$$维护一个序列表示给定$$k$$，kth路径会是什么。

假设$$u$$是标记点，$$k=1$$就是不走，$$k=2,...,size(\text{第一个邻接点}+1)$$就是接上第一个邻接点的序列$$+1$$，后面类似。

发现可以用可持久化平衡树支持复制。但是路径数量是指数级的，会爆掉，不过发现$$k$$只有1e18，我们可以在$$k$$之后截断，复杂度就是$$O(n\log v)$$。

-----

luogu6617 查找

给一个序列和常数$$w$$，支持单点修改，查询区间有没有两个数和为$$w$$。$$n,q\leq 5\timse 10^5$$，4s。

对于每个数，维护它前面最近的和它和为$$w$$的位置$$pre$$。问题变成查询区间$$pre$$有没有在区间内的，线段树维护$$pre$$的最大值即可。

不过修改的时候可能会影响一堆后面的位置，比如有一排$$x$$，前面是一个$$w-x$$。

不过发现这些$$x$$除了第一个都没有用，所以我们可以改为只维护第一个，这样变化量就变成$$O(1)$$了。

-----

爆炸oj3489

每个位置$$i$$的贡献就是$$l\in[pre_i,i],r\in[i,suc_i]$$，这是一个平面上的矩形。

考虑离线怎么做。扫描线扫序列(等价于从左往右扫平面)，那就是要支持区间插入一个数，区间删除一个数，单点查$$\max$$，可以用线段树套堆。

在线的话就是可持久化一下嘛......你发现可持久化整个树套树有点恶心，不过这里只需要可持久化下来那个堆的堆顶，所以就非常简单了!

-----

Ynoi2007 rgxsxrs

给一个序列，支持区间$$>x$$的减$$x$$，查询区间和/$$\min$$/$$\max$$。$$n,q\leq 5\times 10^5,1\leq x,a_i\leq 10^9$$，6s。

肯定要搞这个值域，但是怎么搞呢?

考虑一个类似于基数堆的做法，我们把值域分成$$\log v$$块，也就是$$[0,1),[1,2),[2,4),...$$这样分。

考虑如果要减$$x$$，对于$$2^k>x$$的所有块$$k$$都会减，$$2^{k+1}\leq x$$的都不变，$$2^k\leq x<2^{k+1}$$的最大的若干个会被减。

容易证明，每次减都会让一个元素的块编号变小，于是可以摊掉暴力减的复杂度。每一块开一棵平衡树维护即可，复杂度$$O(n\log n\log v)$$。

当然平衡树常数太\*\*大了，我们可以换成线段树，存在某种神秘方法让它跑得飞快，不过我不会/cy

-----

loj6276

树，点权，问有多少链满足链上颜色互不相同。每种颜色出现次数不超过$$20$$，$$n\leq 10^5$$，4s。

对每个颜色分开考虑。考虑对于两个同色点$$u,v$$，如果它们不是祖孙关系，那么相当于限制路径的两个端点不能分别在这两个子树里。可以相当转成计算不满足的方案数，于是如果全没有祖孙关系，就可以直接矩形面积并。

呃如果有怎么搞?发现在祖先那里会变成一个 子树外，而子树外是两个区间，所以相当于两个矩形，做就行了。复杂度$$O(nk\log n)$$，当然$$k=20$$是最大出现次数。

啊你说为什么不是$$O(nk^2\log n)$$?发现我们可以用$$k$$个点产生$$O(k^2)$$个矩形，而$$k^2$$是下凸函数，所以琴生不等式一下你就知道每次查询都取满是复杂度上限，此时就只有$$\frac{n}{k}$$个颜色。

-----

Ynoi2008 rdCcot/thuwc2020 某科学的动态仙人掌

树，距离是边数，还有一个常数$$C$$。

对于一个树上点集，定义其中两个点$$u,v$$是$$C$$-连通的，当且仅当可以只走点集中的点，每一步距离不超过$$C$$，从$$u$$走到$$v$$。

每次给一个编号区间，查询有多少$$C$$-连通块。$$n,q\leq 10^5$$。

连通块计数问题，考虑对每个连通块找一个代表元。容易想到随便找一个根，然后选择最浅的点作为代表元，不过这个不一定唯一。

不管怎么说我们先接着往下考虑一下。一个点是连通块最浅的点之一，当且仅当比它浅的所有点，距离它$$>C$$。这个看起来还挺简单?

定义邻域$$\mathrm{N}(u,d)$$，$$k$$级祖先$$\mathrm{LA}(u,k)$$，然后我们可以转化成 : $$\mathrm{N}(\mathrm{LA}(u,\frac{C}{2}),\frac{C}{2})$$中没有点在查询区间内。

呃这里看起来需要对奇偶性分类。

 - 如果$$C$$是奇数，应该是$$\mathrm{N}(\mathrm{LA}(u,\frac{C+1}{2}),\frac{C-1}{2})$$。

 - 如果$$C$$是偶数，应该是$$\mathrm{N}(\mathrm{LA}(u,\frac{C}{2}),\frac{C}{2}-1)\cup\mathrm{N}(\mathrm{LA}(u,\frac{C}{2}+1),\frac{C}{2}-1)$$。

然后，没有点在查询区间内，我们可以求出这个邻域内的编号前驱后继，如果查询区间不包含前驱后继，那么这个点就是最浅点之一。

要把多个最浅的点去重，首先注意到最浅的点深度都相同。然后考虑，两个深度相同的点$$C$$-连通，当且仅当它们的$$\lfloor\frac{C}{2}\rfloor$$级祖先相同，这个是显然的。这就非常好，于是可以利用它来去重。

预处理的时候，先对每个深度按照$$\lfloor\frac{C}{2}\rfloor$$级祖先划分成若干等价类。然后对于每个元素，找到刚才说的前驱后继，那么$$x$$的贡献就是一个矩形；去重那就对每个等价类求矩形并。

一般的矩形并是不容易用若干不交矩形简单地表示的，但是这个矩形并很特殊。区间包含一个点的限制是$$y=x$$上一个点的左上方，不包含前驱后继的限制是$$y=x$$上方一个点的右下方，画一画你发现如果不考虑不包含前驱后继的限制那么可以直接处理出来，而对于前驱后继的限制，每$$k$$个点共用一组前驱后继都会多出来$$O(k)$$个矩形，于是划分中的矩形数确实是线性的。现在我们可以扫描线扫一扫了。

但是怎么求邻域前驱后继?考虑它是可快速合并的，这个合并就是$$\min/\max$$，所以它是幂等的。点分治，容易做到$$O(n\log^2 n)$$。

呃但是这太慢了。怎么优化?

考虑每一层的问题相当于把点按深度拍成序列，每次查询一个前缀的前驱后继，容易想到时间倒流之后用链表维护。但是这个不是很行，因为我们查询的数不一定也在这个序列中，这就会导致奇怪的问题。

并查集。

不过要排序，这个可以点分治过程中归并(，这要求我们用二路合并的分治结构，可以用每次合并两棵最小的子树的trick，或者直接换成边分治)。这样做复杂度就是$$O(n\log n\alpha(n)+q\log n)$$。

科技 : 如果知道合并的顺序，可以按$$\log$$大小分块，把并查集做到线性。所以可以当我们做到了$$O((n+q)\log n)$$。

-----

uoj207 共价大爷游长沙

动态树(而不是森林)，支持插入、删除链，查询一条边是不是在所有链上。

LCT。考虑一条边可行，相当于较深的点的子树中，包含了所有链的恰好一个端点。

你发现相当于一条链出现两个端点或者不出现端点就不行，出现一个就可以，于是我们可以用一个$$\operatorname{xor}$$来解决这个问题。

这里有一个经典trick是$$\operatorname{xor}$$哈希。给每条链随机一个巨大权值，如果是`unsigned long long`的话据说错误概率低于$$\frac{1}{10^9}$$。

然后就LCT维护子树$$\operatorname{xor}$$和了。

-----

链排序

树，点权。每次给两条长度相同的链，把两条链分别拿出点权排序，输出哪些位置不同，当然这个排序不会真的排。保证一共输出不超过$$10^6$$个数。

考虑hash+二分，用可持久化值域线段树维护到根的hash值，然后链hash值可以用这个硬拼出来，于是可以Trie二分找到第一个不同的位置，然后继续二分下一个位置就行了......听起来就真\*\*离谱。复杂度居然还是1$$\log$$。

-----

Ynoi2008 stcm

给你一个集合，支持插入一个点和撤销，构造一个方案，凑出每一个点的子树补。子树补就是子树之外的点。$$n\leq 10^5$$，插入次数$$4.5\times 10^6$$。

考虑菊花怎么做，发现此时子树就是自己，删掉每一个求剩下的，容易想到分治。

考虑原问题怎么做，进行重链剖分，然后类似于菊花，只不过从 一个点递归到一些点 变成了 一条链递归到一些链。考虑用类似于静态LCT的方法，把我们的分治树换成Huffman树，就1$$\log$$了。