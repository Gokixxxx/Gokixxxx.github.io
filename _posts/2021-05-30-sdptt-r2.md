---
layout: post
title: 二轮省集
subtitle: /kk
tags: 课
---

## Day1

### 模拟赛

T1 麻将

给一个01串，求最短的没有作为子串出现过的01串，多解输出字典序最小的。$$n\leq 2^24$$，0.2s。

省选计划原题（

考虑答案长度不会超过$$24$$，从大到小枚举答案，问题变成求长$$k$$子串的$$\mathrm{mex}$$，维护一个值域`bool`数组表示每种子串是否存在就好了。你发现长$$k$$的只有$$2^k$$种，所以就$$O(n)$$了。

-----

T2 德州扑克

平面上有一些线段，每次给一个横平竖直的矩形，查矩形内的线段长度除以总线段长度。保证任意两条线段不交，并且每条线段不是横平竖直的。$$n,q\leq 10^5$$，2s。

首先可以把矩形差分掉，问题变成求一个点左下方的线段长度。

先只考虑斜率为正的线段，负的可以反着跑。可以发现固定一个查询点的话，有贡献的线段只有三种 : 

 - 完全在查询点左下方的

 - 穿过上边界的

 - 穿过右边界的

第一种可以直接转成二维数点，第二种和第三种类似，只考虑第三种。

扫描线。从左往右扫过平面，用平衡树维护线段。不相交就非常好!

考虑扫描线右移的变化量，发现每条线段的变化量是一样的，所以相当于要平衡树支持全局带系数加，查询区间历史和。直接做就好了。

复杂度$$O(n\log n)$$。

-----

T3 将棋

给一棵树，边有边权，每次给一个点集，查询这个点集的斯坦呐树上，有多少种方案选择两条不同的边，使它们边权相同。$$(a,b),(b,a)$$看作同一种方案。$$n,q\leq 10^5$$，2s。

不管怎么着，先想想有没有单次询问只关于点集大小的做法。考虑这个斯坦呐树可以拆分成若干链，条数是线性的。每条链内部可以括号序莫队搞定，链之间可以差分成到根的四条链之间的贡献，也可以莫队搞定。现在问题是链之间贡献次数是平方级别。

考虑进行根号分治，点集大小很大的时候$$O(n)$$暴力，小的时候用上面的算法，取阀值$$\Theta(n^{\frac{1}{3}})$$，复杂度可以搞到$$O(n^{\frac{5}{3}})$$。当然认为$$n,m$$同阶。

另一个做法是，继续对颜色出现次数根号分治来代替上面链之间的莫队，然后就可以做到$$O(n\sqrt{n}\log n)$$了!

啊具体就是，把颜色分成大颜色和小颜色。大颜色数量很少可以预处理前缀和然后直接查，小颜色可以枚举一对考虑贡献，发现如果$$(u,v)$$同是一个小颜色，那么两条到根的链之间有贡献，当且仅当它们的端点分别在$$u,v$$的子树中。然后子树是dfn的区间，所以就变成了矩形$$+1$$单点查询。

然后对查询也修改根号分治的阀值到$$\Theta(\sqrt{n})$$，就相当于是$$O(n\sqrt{n})$$次矩形$$+1$$和单点查询，直接扫描线，复杂度是$$O(n\sqrt{n}\log n)$$。啊你问为什么是$$O(n\sqrt{n})$$，而不是$$O(n^2)$$?这当然也是琴生不等式搞出来的。

好像可以把$$\log$$放到根号下面，但是我不会/cy

### 讲课

分治数据结构。

区间的笛卡尔积是矩形，换句话说如果看到 一个东西有贡献，当且仅当查询区间左右端点分别在两个区间内，就可以想到$$(l,r)$$应该在这两个区间的笛卡尔积内，所以就可以上二维数点。

-----

EC Final2020 G

给一个序列，每次给一个区间，查询多少子区间颜色数是奇数。

这个东西等于，区间所有子区间颜色数膜$$2$$的和。

扫描线。考虑插入$$i$$的时候，只有左端点在$$[pre_i+1,i]$$这一段区间的询问会多出来$$a_i$$这种颜色，所以相当于区间异或，查询区间历史和，搞就是了。

-----

神必题

神必题讲啥啊（

-----

JOISC2021 饮食区

有一排队列，支持区间连续push/pop $$k$$次，如果pop超了那就直接pop空，查询某个队列里第$$k$$个数。

扫描线扫序列，数据结构维护时间。发现一次区间修改会在左端点被激活，在右端点右边被不激活，也就是两次单点修改。

考虑我们需要支持什么查询。

你发现如果我们不考虑 弹超了 这件事，也就是每次弹出都会弹恰好那么多，那么可以从查询的时间出发向前线段树二分找到第一个$$\geq k$$的后缀和，那么这个位置就是答案，所以维护最大后缀和即可。

如果考虑弹超，需要找到最后一次弹超了的操作，此后就可以消去弹超的影响，这个可以维护最小前缀和。线段树即可。

-----

hdu5118 GRE Words Once More!

给一个DAG，点从$$1$$到$$n$$标号；有一些点是被标记的。每次查询一个$$k$$，求从点$$1$$开始、截止于一个被标记结点的路径中，编号字典序第$$k$$小的路径长度。$$n\leq 10^5,k\leq 10^{18}$$。

图剖!好像写过来着。

另一种做法是可持久化平衡树，它支持$$O(\log\text{结点数})$$的复制、拼接。

考虑拓扑排序，每一个点$$u$$维护一个序列表示给定$$k$$，kth路径会是什么。

假设$$u$$是标记点，$$k=1$$就是不走，$$k=2,...,size(\text{第一个邻接点}+1)$$就是接上第一个邻接点的序列$$+1$$，后面类似。

发现可以用可持久化平衡树支持复制。但是路径数量是指数级的，会爆掉，不过发现$$k$$只有1e18，我们可以在$$k$$之后截断，复杂度就是$$O(n\log v)$$。

-----

luogu6617 查找

给一个序列和常数$$w$$，支持单点修改，查询区间有没有两个数和为$$w$$。$$n,q\leq 5\times 10^5$$，4s。

对于每个数，维护它前面最近的和它和为$$w$$的位置$$pre$$。问题变成查询区间$$pre$$有没有在区间内的，线段树维护$$pre$$的最大值即可。

不过修改的时候可能会影响一堆后面的位置，比如有一排$$x$$，前面是一个$$w-x$$。

不过发现这些$$x$$除了第一个都没有用，所以我们可以改为只维护第一个，这样变化量就变成$$O(1)$$了。

-----

爆炸oj3489

每个位置$$i$$的贡献就是$$l\in[pre_i,i],r\in[i,suc_i]$$，这是一个平面上的矩形。

考虑离线怎么做。扫描线扫序列(等价于从左往右扫平面)，那就是要支持区间插入一个数，区间删除一个数，单点查$$\max$$，可以用线段树套堆。

在线的话就是可持久化一下嘛......你发现可持久化整个树套树有点恶心，不过这里只需要可持久化下来那个堆的堆顶，所以就非常简单了!

-----

Ynoi2007 rgxsxrs

给一个序列，支持区间$$>x$$的减$$x$$，查询区间和/$$\min$$/$$\max$$。$$n,q\leq 5\times 10^5,1\leq x,a_i\leq 10^9$$，6s。

肯定要搞这个值域，但是怎么搞呢?

考虑一个类似于基数堆的做法，我们把值域分成$$\log v$$块，也就是$$[0,1),[1,2),[2,4),...$$这样分。

考虑如果要减$$x$$，对于$$2^k>x$$的所有块$$k$$都会减，$$2^{k+1}\leq x$$的都不变，$$2^k\leq x<2^{k+1}$$的最大的若干个会被减。

容易证明，每次减都会让一个元素的块编号变小，于是可以摊掉暴力减的复杂度。每一块开一棵平衡树维护即可，复杂度$$O(n\log n\log v)$$。

当然平衡树常数太\*\*大了，我们可以换成线段树，存在某种神秘方法让它跑得飞快，不过我不会/cy

-----

loj6276

树，点权，问有多少链满足链上颜色互不相同。每种颜色出现次数不超过$$20$$，$$n\leq 10^5$$，4s。

对每个颜色分开考虑。考虑对于两个同色点$$u,v$$，如果它们不是祖孙关系，那么相当于限制路径的两个端点不能分别在这两个子树里。可以相当转成计算不满足的方案数，于是如果全没有祖孙关系，就可以直接矩形面积并。

呃如果有怎么搞?发现在祖先那里会变成一个 子树外，而子树外是两个区间，所以相当于两个矩形，做就行了。复杂度$$O(nk\log n)$$，当然$$k=20$$是最大出现次数。

啊你说为什么不是$$O(nk^2\log n)$$?发现我们可以用$$k$$个点产生$$O(k^2)$$个矩形，而$$k^2$$是下凸函数，所以琴生不等式一下你就知道每次查询都取满是复杂度上限，此时就只有$$\frac{n}{k}$$个颜色。

-----

Ynoi2008 rdCcot/thuwc2020 某科学的动态仙人掌

树，距离是边数，还有一个常数$$C$$。

对于一个树上点集，定义其中两个点$$u,v$$是$$C$$-连通的，当且仅当可以只走点集中的点，每一步距离不超过$$C$$，从$$u$$走到$$v$$。

每次给一个编号区间，查询有多少$$C$$-连通块。$$n,q\leq 10^5$$。

连通块计数问题，考虑对每个连通块找一个代表元。容易想到随便找一个根，然后选择最浅的点作为代表元，不过这个不一定唯一。

不管怎么说我们先接着往下考虑一下。一个点是连通块最浅的点之一，当且仅当比它浅的所有点，距离它$$>C$$。这个看起来还挺简单?

定义邻域$$\mathrm{N}(u,d)$$，$$k$$级祖先$$\mathrm{LA}(u,k)$$，然后我们可以转化成 : $$\mathrm{N}(\mathrm{LA}(u,\frac{C}{2}),\frac{C}{2})$$中没有点在查询区间内。

呃这里看起来需要对奇偶性分类。

 - 如果$$C$$是奇数，应该是$$\mathrm{N}(\mathrm{LA}(u,\frac{C+1}{2}),\frac{C-1}{2})$$。

 - 如果$$C$$是偶数，应该是$$\mathrm{N}(\mathrm{LA}(u,\frac{C}{2}),\frac{C}{2}-1)\cup\mathrm{N}(\mathrm{LA}(u,\frac{C}{2}+1),\frac{C}{2}-1)$$。

然后，没有点在查询区间内，我们可以求出这个邻域内的编号前驱后继，如果查询区间不包含前驱后继，那么这个点就是最浅点之一。

要把多个最浅的点去重，首先注意到最浅的点深度都相同。然后考虑，两个深度相同的点$$C$$-连通，当且仅当它们的$$\lfloor\frac{C}{2}\rfloor$$级祖先相同，这个是显然的。这就非常好，于是可以利用它来去重。

预处理的时候，先对每个深度按照$$\lfloor\frac{C}{2}\rfloor$$级祖先划分成若干等价类。然后对于每个元素，找到刚才说的前驱后继，那么$$x$$的贡献就是一个矩形；去重那就对每个等价类求矩形并。

一般的矩形并是不容易用若干不交矩形简单地表示的，但是这个矩形并很特殊。区间包含一个点的限制是$$y=x$$上一个点的左上方，不包含前驱后继的限制是$$y=x$$上方一个点的右下方，画一画你发现如果不考虑不包含前驱后继的限制那么可以直接处理出来，而对于前驱后继的限制，每$$k$$个点共用一组前驱后继都会多出来$$O(k)$$个矩形，于是划分中的矩形数确实是线性的。现在我们可以扫描线扫一扫了。

但是怎么求邻域前驱后继?考虑它是可快速合并的，这个合并就是$$\min/\max$$，所以它是幂等的。点分治，容易做到$$O(n\log^2 n)$$。

呃但是这太慢了。怎么优化?

考虑每一层的问题相当于把点按深度拍成序列，每次查询一个前缀的前驱后继，容易想到时间倒流之后用链表维护。但是这个不是很行，因为我们查询的数不一定也在这个序列中，这就会导致奇怪的问题。

并查集。

不过要排序，这个可以点分治过程中归并(，这要求我们用二路合并的分治结构，可以用每次合并两棵最小的子树的trick，或者直接换成边分治)。这样做复杂度就是$$O(n\log n\alpha(n)+q\log n)$$。

科技 : 如果知道合并的顺序，可以按$$\log$$大小分块，把并查集做到线性。所以可以当我们做到了$$O((n+q)\log n)$$。

-----

uoj207 共价大爷游长沙

动态树(而不是森林)，支持插入、删除链，查询一条边是不是在所有链上。

LCT。考虑一条边可行，相当于较深的点的子树中，包含了所有链的恰好一个端点。

你发现相当于一条链出现两个端点或者不出现端点就不行，出现一个就可以，于是我们可以用一个$$\operatorname{xor}$$来解决这个问题。

这里有一个经典trick是$$\operatorname{xor}$$哈希。给每条链随机一个巨大权值，如果是`unsigned long long`的话据说错误概率低于$$\frac{1}{10^9}$$。

然后就LCT维护子树$$\operatorname{xor}$$和了。

-----

链排序

树，点权。每次给两条长度相同的链，把两条链分别拿出点权排序，输出哪些位置不同，当然这个排序不会真的排。保证一共输出不超过$$10^6$$个数。

考虑hash+二分，用可持久化值域线段树维护到根的hash值，然后链hash值可以用这个硬拼出来，于是可以Trie二分找到第一个不同的位置，然后继续二分下一个位置就行了......听起来就真\*\*离谱。复杂度居然还是1$$\log$$。

-----

Ynoi2008 stcm

给你一个集合，支持插入一个点和撤销，构造一个方案，凑出每一个点的子树补。子树补就是子树之外的点。$$n\leq 10^5$$，插入次数$$4.5\times 10^6$$。

考虑菊花怎么做，发现此时子树就是自己，删掉每一个求剩下的，容易想到分治。

考虑原问题怎么做，进行重链剖分，然后类似于菊花，只不过从 一个点递归到一些点 变成了 一条链递归到一些链。考虑用类似于静态LCT的方法，把我们的分治树换成Huffman树，就1$$\log$$了。

## Day2

### 模拟赛

题面很好玩（

-----

T1 多项式时间哈密顿回路

给一个外向基环树森林，每一个点上有若干个物品，物品可以沿着有向边移动，你可以往任意结点放共$$m$$个物品，构造方案使得所有点上物品数量最小值最大，只需要输出这个最大值。$$n\leq 10^5,m,a_i\leq 10^9$$。

直接二分答案，基环树dp。

-----

T2 AI高考数学134分

给三个序列$$a,b,c$$，对于每个区间，对$$a,b,c$$中这个区间分别求极差，然后乘起来作为这个区间的权值。求所有区间的权值和。$$n\leq 10^5$$。

枚举右端点，搞三个单调栈，然后可以用线段树维护所有东西来处理。

啊你说具体维护什么?需要

 - 三个序列的极差$$x,y,z$$

 - $$xy,yz,xz$$

 - $$xyz$$

转移可以写成矩乘，做就是了。

-----

T3 自动化leetcode

给一个序列$$a$$，每次查询给出一个区间和一个数$$x$$，问从左往右扫过这个区间，每次把$$x$$变成$$\vert x-a_i\vert$$，最后会得到什么。$$n,q\leq 10^5,a_i,x\leq 10^7$$。

std倒是依赖值域......不过是在可持久化平衡树建树的时候。

容易发现段数是指数级，于是要想直接维护这个东西，可以想到可持久化平衡树。

考虑全局询问怎么做。从左往右扫过序列，一开始平衡树存储恒等变换，然后每次相当于把$$a_i$$上面的部分移下来，下面的部分翻转一下。你发现这两部分出现了重合!这就让我们不是很好维护。

考虑倒过来做，你发现正着相当于给$$x$$求$$f(x)=\vert x-a\vert$$，倒着相当于给$$f(x)$$求$$x$$，解一下你知道当$$x\geq a$$的时候是$$x=f(x)+a$$，否则$$x=-f(x)+a$$。第一个意义是把整个平移$$a$$，第二个是把$$a$$以下翻转，这俩正好是不交的。于是可持久化平衡树硬上就好了。

要支持区间查询，可以在外面套一棵线段树。$$O(n\log n\log v)$$。

除此之外，这个题合并的时候也可以用第二分块的trick，复杂度就是根号了。

### 讲课

CF464E The Classic Problem

每条边边权是$$2^{w_i}$$，求最短路。

考虑Dij只需要支持

 - 一个数加上一个边权

 - 比较两个数

 - 一个数赋值成另一个数

看到第三个，考虑可持久化数据结构。我们选择可持久化线段树。

加一个边权，可以二分出进位的一段做推平，然后对前面那一位单点修改。

比较两个数，相当于比较字典序，可以用二分哈希来搞定。

-----

CF1446D2 Frequency Problem 加强版

序列，求一个最长的子段，使得其中众数不唯一。$$n\leq 5\times 10^6$$。

当然还是那个结论，答案区间中一定有一个众数是全局众数。

考虑找到所有的全局众数，然后对于每个数，尝试找到最长的区间，使得这个数和全局众数出现次数相同。注意这样找到的区间不一定满足它俩是众数，但是它的正确性在于这样找不优于答案，并且一定会找到答案。

考虑怎么让复杂度只跟我们处理的这个数出现次数$$cnt$$相关。

进行两轮标记。第一轮一开始把所有全局众数标记成没用的，然后对于每个我们处理的数，往左找到第一个没用的全局众数，把它改成有用的。第二轮反过来从右往左遍历并往右找没用的位置，如果一个位置两轮都没被标记成有用的，那它确实没用了。这个好像有点像 雪灾与外卖 的某个部分分?

怎么证明这个东西的正确性?如果一个全局众数在第一轮被标记没用，那么它往右不管21怎么延伸，都有全局众数出现次数多于我们处理的数(因为数两两配对，而总是剩下这一个)，所以它不可能作为一个左端点。

然后剩下的可能端点数就是$$O(cnt)$$的了。不过怎么找到这些点?

数据结构问题是 : 删一个数，查询前驱，重置。可以用并查集来维护，当然可以用线性并查集做到线性。

啊你说重置?考虑线性并查集需要修改$$\Omega(\log n)$$次才会合并第一次，所以全撤回去复杂度是正确的。普通的并查集呢?好像只能多个$$\log$$吧。

然后问题是在这些端点里面找到最长的区间，使得全局众数和我们处理的数出现次数相同。

这是经典技巧。把所有全局众数改成$$1$$，处理的数改成$$-1$$，问题变成找和为$$0$$的区间，拆前缀和扔进桶里即可。这样就线性了。

-----

CF997E Good Subsegments

给一个排列，每次给一个区间，查询有多少子区间值域连续。$$n\leq 1.2\times 10^5$$，可以做到$$5\times 10^5$$。

你发现因为是排列，一个区间连续，相当于$$r-l=\max-\min$$。

考虑分别建立大/小根笛卡尔树，那么每一个$$\max/\min$$的贡献是一个矩形，同时$$l,r$$的贡献也是矩形。问题变成矩形加减，数一个点右下方有多少$$0$$。

先把修改查询都差分掉，然后肯定扫描线，问题变成区间加减，查历史$$0$$总个数。怎么维护$$0$$的个数?

你发现这里一定有$$r-l\leq\max-\min$$，所以我们可以线段树维护区间最小值和最小值个数，然后历史和的话硬打标记就好了。

-----

CF765F Souvenirs

给一个序列，每次查询一个区间中选两个数，差的绝对值的最小值。$$n\leq 5\times 10^5$$。

回滚莫队大家都会!但是那太慢了。

对于每个$$i$$，考虑它和哪些位置拼起来可能有用，我们试图从左往右找出这些位置。

先只考虑顺序对，逆序对可以相反地求出来。

我们找到$$i$$右边第一个比$$a_i$$大的$$a_j$$，这个$$j$$肯定有用。然后考虑接下来如果一个$$k$$想要$$(i,k)$$优于$$(i,j),(j,k)$$，那么$$a_k$$就必须更靠近$$a_i$$(比起它靠近$$a_j$$的程度)，那么$$a_k$$的取值范围就在$$[a_i,\frac{a_i+a_j}{2}]$$内了。你发现值域变成了一半!这样找$$O(\log v)$$个就一定会停下。

这个东西可以从后往前建立主席树来找到，每次是一个$$\log$$的。剩下的就是二维数点了。总共是$$O(n\log n\log v+m(\log n+\log\log v))$$，

-----

CF176E Archaeology

维护一个点集，支持插入删除，查询斯坦呐树权值和。$$n,q\leq 10^5$$。

呃结论是，斯坦呐树权值和，就是按照dfn排序成一个环之后，相邻点两两距离之和的一半。set维护即可。

另一种做法是Top tree/jy

不过可以比Top tree更优，因为我们可以用vEB代替set查前驱后继。

-----

CF896E Welcome home, Chtholly

第二分块的在线版。

给一个序列，支持区间$$>x$$的减$$x$$，查询区间某个数出现次数。$$n,a_i\leq 10^5$$。

值域1e5!要查询出现次数，显然是开值域桶。要平衡掉巨大的桶，考虑分块。

容易发现对于这个修改操作，每一个数大小都是不升的。这题核心在于 : 用块最大值的减小，摊掉爆力修改的复杂度。

先考虑我们需要支持什么查询。整块查询的时候，只需要查一个数出现次数；零散块重构的时候，则需要快速对于每个数查询它变成了什么数。

考虑设最大值是$$k$$，

 - 如果$$2x> k$$，那么最大值会减小至少$$k-x$$，所以我们只可以付出$$O(k-x)$$的实际复杂度。啊这个很简单，爆力枚举所有被减了的$$O(k-x)$$个值，然后用并查集来合并就好了。啊具体就是我们需要合并$$i$$和$$i-x$$。

 - 如果$$2x\leq k$$，那么最大值会减小至少$$x$$，所以我们只可以付出$$O(x)$$的实际复杂度。考虑反过来，我们把所有值都减$$x$$，然后把原来$$1,...,x$$这些值都加上$$x$$，第一个可以打全局减标记，第二个可以枚举这$$O(x)$$个值用并查集合并。

注意到这个并查集比较特殊，它的`find`一定是在零散块重构的时候，所以一定总是`find`一遍，所以复杂度是线性的。总共就是$$O(n\sqrt{n})$$。

离线版本是线性空间的，这个注意到查询很容易合并，所以可以离线对于每一块分别处理。

-----

CF700D Huffman Coding on Segment

给一个字符串，每次查询区间Huffman编码之后的长度。$$n,q\leq 10^5$$。

出现次数只有根号种，可以暴力莫队搞定每个区间的出现次数们，然后离线计排，线性Huffman树就做完了。

-----

CF453E Little Pony and Lord Tirek

给一个序列，每个位置一开始是$$a_i$$，每时刻会增大$$r_i$$，直到上限$$m_i$$。有一些操作依次进行，每次查询一个区间的和，并把这个区间推平成$$0$$。

破坏性查询，考虑连续段均摊，当然这里的连续段是上一次推平时间的连续段。发现查询一整个连续段的时候，我们需要知道的信息有两个 : 

 - 所有达到上限的位置的上限之和

 - 所有没有达到上限位置的增长速度之和

第一个怎么做?考虑如果距离上一次推平的时间$$t$$至少是达到上限所需时间$$\lceil\frac{m_i}{r_i}\rceil$$的时候，$$i$$就达到上限了。于是可以用一个按$$\lceil\frac{m_i}{r_i}\rceil$$排序的平衡树维护。

第二个怎么做?用那个平衡树也可以搞定。所以我们就得到了$$O(n\log n)$$算法。

-----

CF1476G Minimum Difference

给一个序列，单点修改，或者查询从一个区间中选$$k$$个不同的数，使得这些数在区间中出现次数的极差最小，输出这个极差。$$n,q\leq 10^5$$。

不同出现次数是根号的，所以还是可以爆力莫队搞定，单点修改那就带修莫队。就过了/jk

-----

CF1344E Train Tracks

树，边权。树上有一些火车，每个在$$t_i$$从$$1$$出发前往$$s_i$$。每个点每个时刻向儿子的铁轨只能有一个方向，你每个时刻可以选择一个点，更改它连向的儿子，这个操作先于火车移动。如果火车跑到一个点上，接下来要走的方向和铁轨开放的方向不同，那它就会自爆。求能不能让火车不自爆，如果不得不自爆最晚在什么时候自爆，以及至少需要调整多少次铁轨方向。

这个信息看起来很巨量，所以考虑能不能重用。想到静态链分治，数据结构要支持插入并查询前驱后继，用一个set来维护即可。可以换成动态开点vEB，不过我觉得没有人想写动态开点vEB的。

-----

CF1017G The Tree

树。支持把一个点的黑色连通块向下扩展一个单位，把一个点子树染白，查询一个点的颜色。

考虑一个点是黑色，当且仅当存在一个祖先，使得这个祖先到这个点链上染黑的操作次数加起来，至少有这条链这么长。这个可以树剖之后从下往上线段树二分解决，或者直接静态Top tree二分做到一个$$\log$$。

染白这个操作很不好，因为光是清空子树的染黑操作次数不够，上面的染黑操作可能渗透下来。

不过你发现，如果上面的操作渗透下来$$d$$单位，我们可以染黑$$-d$$次。这么做可行是因为染黑这个操作次数已经被我们彻底抽象掉了，它的意义已经不重要了，进行负数次也没什么问题。这个$$d$$也可以树剖线段树求出来。

-----

CF1340F Nastya and CBS

收录于 类楼房重建线段树。

