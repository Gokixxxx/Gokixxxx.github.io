---
layout: post
title: 二轮省集
subtitle: /kk
tags: 课
---

## Day1

### 模拟赛

T1 麻将

给一个01串，求最短的没有作为子串出现过的01串，多解输出字典序最小的。$$n\leq 2^24$$，0.2s。

省选计划原题（

考虑答案长度不会超过$$24$$，从大到小枚举答案，问题变成求长$$k$$子串的$$\mathrm{mex}$$，维护一个值域`bool`数组表示每种子串是否存在就好了。你发现长$$k$$的只有$$2^k$$种，所以就$$O(n)$$了。

-----

T2 德州扑克

平面上有一些线段，每次给一个横平竖直的矩形，查矩形内的线段长度除以总线段长度。保证任意两条线段不交，并且每条线段不是横平竖直的。$$n,q\leq 10^5$$，2s。

首先可以把矩形差分掉，问题变成求一个点左下方的线段长度。

先只考虑斜率为正的线段，负的可以反着跑。可以发现固定一个查询点的话，有贡献的线段只有三种 : 

 - 完全在查询点左下方的

 - 穿过上边界的

 - 穿过右边界的

第一种可以直接转成二维数点，第二种和第三种类似，只考虑第三种。

扫描线。从左往右扫过平面，用平衡树维护线段。不相交就非常好!

考虑扫描线右移的变化量，发现每条线段的变化量是一样的，所以相当于要平衡树支持全局带系数加，查询区间历史和。直接做就好了。

复杂度$$O(n\log n)$$。

-----

T3 将棋

给一棵树，边有边权，每次给一个点集，查询这个点集的斯坦呐树上，有多少种方案选择两条不同的边，使它们边权相同。$$(a,b),(b,a)$$看作同一种方案。$$n,q\leq 10^5$$，2s。

不管怎么着，先想想有没有单次询问只关于点集大小的做法。考虑这个斯坦呐树可以拆分成若干链，条数是线性的。每条链内部可以括号序莫队搞定，链之间可以差分成到根的四条链之间的贡献，也可以莫队搞定。现在问题是链之间贡献次数是平方级别。

考虑进行根号分治，点集大小很大的时候$$O(n)$$暴力，小的时候用上面的算法，取阀值$$\Theta(n^{\frac{1}{3}})$$，复杂度可以搞到$$O(n^{\frac{5}{3}})$$。当然认为$$n,m$$同阶。

另一个做法是，继续对颜色出现次数根号分治来代替上面链之间的莫队，然后就可以做到$$O(n\sqrt{n}\log n)$$了!

啊具体就是，把颜色分成大颜色和小颜色。大颜色数量很少可以预处理前缀和然后直接查，小颜色可以枚举一对考虑贡献，发现如果$$(u,v)$$同是一个小颜色，那么两条到根的链之间有贡献，当且仅当它们的端点分别在$$u,v$$的子树中。然后子树是dfn的区间，所以就变成了矩形$$+1$$单点查询。

然后对查询也修改根号分治的阀值到$$\Theta(\sqrt{n})$$，就相当于是$$O(n\sqrt{n})$$次矩形$$+1$$和单点查询，直接扫描线，复杂度是$$O(n\sqrt{n}\log n)$$。啊你问为什么是$$O(n\sqrt{n})$$，而不是$$O(n^2)$$?这当然也是琴生不等式搞出来的。

好像可以把$$\log$$放到根号下面，但是我不会/cy

### 讲课

分治数据结构。

区间的笛卡尔积是矩形，换句话说如果看到 一个东西有贡献，当且仅当查询区间左右端点分别在两个区间内，就可以想到$$(l,r)$$应该在这两个区间的笛卡尔积内，所以就可以上二维数点。

-----

EC Final2020 G

给一个序列，每次给一个区间，查询多少子区间颜色数是奇数。

这个东西等于，区间所有子区间颜色数膜$$2$$的和。

扫描线。考虑插入$$i$$的时候，只有左端点在$$[pre_i+1,i]$$这一段区间的询问会多出来$$a_i$$这种颜色，所以相当于区间异或，查询区间历史和，搞就是了。

-----

神必题

神必题讲啥啊（

-----

JOISC2021 饮食区

有一排队列，支持区间连续push/pop $$k$$次，如果pop超了那就直接pop空，查询某个队列里第$$k$$个数。

先把这个pop干掉，做法是直接爆力求出每次查询查的是不考虑pop的第几个数。这个东西实际上问题在于pop空，可以用吉老师线段树支持区间对$$0$$取$$\max$$。

扫描线扫序列，数据结构维护时间。发现一次区间push会在左端点被激活，在右端点右边被不激活，也就是两次单点修改。然后要支持查kth，线段树就行了。

-----

hdu5118 GRE Words Once More!

给一个DAG，点从$$1$$到$$n$$标号；有一些点是被标记的。每次查询一个$$k$$，求从点$$1$$开始、截止于一个被标记结点的路径中，编号字典序第$$k$$小的路径长度。$$n\leq 10^5,k\leq 10^{18}$$。

图剖!好像写过来着。

另一种做法是可持久化平衡树，它支持$$O(\log\text{结点数})$$的复制、拼接。

考虑拓扑排序，每一个点$$u$$维护一个序列表示给定$$k$$，kth路径会是什么。

假设$$u$$是标记点，$$k=1$$就是不走，$$k=2,...,size(\text{第一个邻接点}+1)$$就是接上第一个邻接点的序列$$+1$$，后面类似。

发现可以用可持久化平衡树支持复制。但是路径数量是指数级的，会爆掉，不过发现$$k$$只有1e18，我们可以在$$k$$之后截断，复杂度就是$$O(n\log v)$$。

-----

luogu6617 查找

给一个序列和常数$$w$$，支持单点修改，查询区间有没有两个数和为$$w$$。$$n,q\leq 5\times 10^5$$，4s。

对于每个数，维护它前面最近的和它和为$$w$$的位置$$pre$$。问题变成查询区间$$pre$$有没有在区间内的，线段树维护$$pre$$的最大值即可。

不过修改的时候可能会影响一堆后面的位置，比如有一排$$x$$，前面是一个$$w-x$$。

不过发现这些$$x$$除了第一个都没有用，所以我们可以改为只维护第一个，这样变化量就变成$$O(1)$$了。

-----

爆炸oj3489

每个位置$$i$$的贡献就是$$l\in[pre_i,i],r\in[i,suc_i]$$，这是一个平面上的矩形。

考虑离线怎么做。扫描线扫序列(等价于从左往右扫平面)，那就是要支持区间插入一个数，区间删除一个数，单点查$$\max$$，可以用线段树套堆。

在线的话就是可持久化一下嘛......你发现可持久化整个树套树有点恶心，不过这里只需要可持久化下来那个堆的堆顶，所以就非常简单了!

-----

Ynoi2007 rgxsxrs

给一个序列，支持区间$$>x$$的减$$x$$，查询区间和/$$\min$$/$$\max$$。$$n,q\leq 5\times 10^5,1\leq x,a_i\leq 10^9$$，6s。

肯定要搞这个值域，但是怎么搞呢?

考虑一个类似于基数堆的做法，我们把值域分成$$\log v$$块，也就是$$[0,1),[1,2),[2,4),...$$这样分。

考虑如果要减$$x$$，对于$$2^k>x$$的所有块$$k$$都会减，$$2^{k+1}\leq x$$的都不变，$$2^k\leq x<2^{k+1}$$的最大的若干个会被减。

容易证明，每次减都会让一个元素的块编号变小，于是可以摊掉暴力减的复杂度。每一块开一棵平衡树维护即可，复杂度$$O(n\log n\log v)$$。

当然平衡树常数太\*\*大了，我们可以换成线段树，存在某种神秘方法让它跑得飞快，不过我不会/cy

-----

loj6276

树，点权，问有多少链满足链上颜色互不相同。每种颜色出现次数不超过$$20$$，$$n\leq 10^5$$，4s。

对每个颜色分开考虑。考虑对于两个同色点$$u,v$$，如果它们不是祖孙关系，那么相当于限制路径的两个端点不能分别在这两个子树里。可以相当转成计算不满足的方案数，于是如果全没有祖孙关系，就可以直接矩形面积并。

呃如果有怎么搞?发现在祖先那里会变成一个 子树外，而子树外是两个区间，所以相当于两个矩形，做就行了。复杂度$$O(nk\log n)$$，当然$$k=20$$是最大出现次数。

啊你说为什么不是$$O(nk^2\log n)$$?发现我们可以用$$k$$个点产生$$O(k^2)$$个矩形，而$$k^2$$是下凸函数，所以琴生不等式一下你就知道每次查询都取满是复杂度上限，此时就只有$$\frac{n}{k}$$个颜色。

-----

Ynoi2008 rdCcot/thuwc2020 某科学的动态仙人掌

树，距离是边数，还有一个常数$$C$$。

对于一个树上点集，定义其中两个点$$u,v$$是$$C$$-连通的，当且仅当可以只走点集中的点，每一步距离不超过$$C$$，从$$u$$走到$$v$$。

每次给一个编号区间，查询有多少$$C$$-连通块。$$n,q\leq 10^5$$。

连通块计数问题，考虑对每个连通块找一个代表元。容易想到随便找一个根，然后选择最浅的点作为代表元，不过这个不一定唯一。

不管怎么说我们先接着往下考虑一下。一个点是连通块最浅的点之一，当且仅当比它浅的所有点，距离它$$>C$$。这个看起来还挺简单?

定义邻域$$\mathrm{N}(u,d)$$，$$k$$级祖先$$\mathrm{LA}(u,k)$$，然后我们可以转化成 : $$\mathrm{N}(\mathrm{LA}(u,\frac{C}{2}),\frac{C}{2})$$中没有点在查询区间内。

呃这里看起来需要对奇偶性分类。

 - 如果$$C$$是奇数，应该是$$\mathrm{N}(\mathrm{LA}(u,\frac{C+1}{2}),\frac{C-1}{2})$$。

 - 如果$$C$$是偶数，应该是$$\mathrm{N}(\mathrm{LA}(u,\frac{C}{2}),\frac{C}{2}-1)\cup\mathrm{N}(\mathrm{LA}(u,\frac{C}{2}+1),\frac{C}{2}-1)$$。

然后，没有点在查询区间内，我们可以求出这个邻域内的编号前驱后继，如果查询区间不包含前驱后继，那么这个点就是最浅点之一。

要把多个最浅的点去重，首先注意到最浅的点深度都相同。然后考虑，两个深度相同的点$$C$$-连通，当且仅当它们的$$\lfloor\frac{C}{2}\rfloor$$级祖先相同，这个是显然的。这就非常好，于是可以利用它来去重。

预处理的时候，先对每个深度按照$$\lfloor\frac{C}{2}\rfloor$$级祖先划分成若干等价类。然后对于每个元素，找到刚才说的前驱后继，那么$$x$$的贡献就是一个矩形；去重那就对每个等价类求矩形并。

一般的矩形并是不容易用若干不交矩形简单地表示的，但是这个矩形并很特殊。区间包含一个点的限制是$$y=x$$上一个点的左上方，不包含前驱后继的限制是$$y=x$$上方一个点的右下方，画一画你发现如果不考虑不包含前驱后继的限制那么可以直接处理出来，而对于前驱后继的限制，每$$k$$个点共用一组前驱后继都会多出来$$O(k)$$个矩形，于是划分中的矩形数确实是线性的。现在我们可以扫描线扫一扫了。

但是怎么求邻域前驱后继?考虑它是可快速合并的，这个合并就是$$\min/\max$$，所以它是幂等的。点分治，容易做到$$O(n\log^2 n)$$。

呃但是这太慢了。怎么优化?

考虑每一层的问题相当于把点按深度拍成序列，每次查询一个前缀的前驱后继，容易想到时间倒流之后用链表维护。但是这个不是很行，因为我们查询的数不一定也在这个序列中，这就会导致奇怪的问题。

并查集。

不过要排序，这个可以点分治过程中归并(，这要求我们用二路合并的分治结构，可以用每次合并两棵最小的子树的trick，或者直接换成边分治)。这样做复杂度就是$$O(n\log n\alpha(n)+q\log n)$$。

科技 : 如果知道合并的顺序，可以按$$\log$$大小分块，把并查集做到线性。所以可以当我们做到了$$O((n+q)\log n)$$。

-----

uoj207 共价大爷游长沙

动态树(而不是森林)，支持插入、删除链，查询一条边是不是在所有链上。

LCT。考虑一条边可行，相当于较深的点的子树中，包含了所有链的恰好一个端点。

你发现相当于一条链出现两个端点或者不出现端点就不行，出现一个就可以，于是我们可以用一个$$\operatorname{xor}$$来解决这个问题。

这里有一个经典trick是$$\operatorname{xor}$$哈希。给每条链随机一个巨大权值，如果是`unsigned long long`的话据说错误概率低于$$\frac{1}{10^9}$$。

然后就LCT维护子树$$\operatorname{xor}$$和了。

-----

链排序

树，点权。每次给两条长度相同的链，把两条链分别拿出点权排序，输出哪些位置不同，当然这个排序不会真的排。保证一共输出不超过$$10^6$$个数。

考虑hash+二分，用可持久化值域线段树维护到根的hash值，然后链hash值可以用这个硬拼出来，于是可以Trie二分找到第一个不同的位置，然后继续二分下一个位置就行了......听起来就真\*\*离谱。复杂度居然还是1$$\log$$。

-----

Ynoi2008 stcm

给你一个集合，支持插入一个点和撤销，构造一个方案，凑出每一个点的子树补。子树补就是子树之外的点。$$n\leq 10^5$$，插入次数$$4.5\times 10^6$$。

考虑菊花怎么做，发现此时子树就是自己，删掉每一个求剩下的，容易想到分治。

考虑原问题怎么做，进行重链剖分，然后类似于菊花，只不过从 一个点递归到一些点 变成了 一条链递归到一些链。考虑用类似于静态LCT的方法，把我们的分治树换成Huffman树，就1$$\log$$了。

## Day2

### 模拟赛

题面很好玩（

-----

T1 多项式时间哈密顿回路

给一个外向基环树森林，每一个点上有若干个物品，物品可以沿着有向边移动，你可以往任意结点放共$$m$$个物品，构造方案使得所有点上物品数量最小值最大，只需要输出这个最大值。$$n\leq 10^5,m,a_i\leq 10^9$$。

直接二分答案，基环树dp。

-----

T2 AI高考数学134分

给三个序列$$a,b,c$$，对于每个区间，对$$a,b,c$$中这个区间分别求极差，然后乘起来作为这个区间的权值。求所有区间的权值和。$$n\leq 10^5$$。

枚举右端点，搞三个单调栈，然后可以用线段树维护所有东西来处理。

啊你说具体维护什么?需要

 - 三个序列的极差$$x,y,z$$，

 - $$xy,yz,xz$$，

 - $$xyz$$。

转移可以写成矩乘，做就是了。

-----

T3 自动化leetcode

给一个序列$$a$$，每次查询给出一个区间和一个数$$x$$，问从左往右扫过这个区间，每次把$$x$$变成$$\vert x-a_i\vert$$，最后会得到什么。$$n,q\leq 10^5,a_i,x\leq 10^7$$。

std倒是依赖值域......不过是在可持久化平衡树建树的时候。

容易发现段数是指数级，于是要想直接维护这个东西，可以想到可持久化平衡树。

考虑全局询问怎么做。从左往右扫过序列，一开始平衡树存储恒等变换，然后每次相当于把$$a_i$$上面的部分移下来，下面的部分翻转一下。你发现这两部分出现了重合!这就让我们不是很好维护。

考虑倒过来做，你发现正着相当于给$$x$$求$$f(x)=\vert x-a\vert$$，倒着相当于给$$f(x)$$求$$x$$，解一下你知道当$$x\geq a$$的时候是$$x=f(x)+a$$，否则$$x=-f(x)+a$$。第一个意义是把整个平移$$a$$，第二个是把$$a$$以下翻转，这俩正好是不交的。于是可持久化平衡树硬上就好了。

要支持区间查询，可以在外面套一棵线段树。$$O(n\log n\log v)$$。

除此之外，这个题合并的时候也可以用第二分块的trick，复杂度就是根号了。

### 讲课

CF464E The Classic Problem

每条边边权是$$2^{w_i}$$，求最短路。

考虑Dij只需要支持

 - 一个数加上一个边权

 - 比较两个数

 - 一个数赋值成另一个数

看到第三个，考虑可持久化数据结构。我们选择可持久化线段树。

加一个边权，可以二分出进位的一段做推平，然后对前面那一位单点修改。

比较两个数，相当于比较字典序，可以用二分哈希来搞定。

-----

CF1446D2 Frequency Problem 加强版

序列，求一个最长的子段，使得其中众数不唯一。$$n\leq 5\times 10^6$$。

当然还是那个结论，答案区间中一定有一个众数是全局众数。

考虑找到所有的全局众数，然后对于每个数，尝试找到最长的区间，使得这个数和全局众数出现次数相同。注意这样找到的区间不一定满足它俩是众数，但是它的正确性在于这样找不优于答案，并且一定会找到答案。

考虑怎么让复杂度只跟我们处理的这个数出现次数$$cnt$$相关。

进行两轮标记。第一轮一开始把所有全局众数标记成没用的，然后对于每个我们处理的数，往左找到第一个没用的全局众数，把它改成有用的。第二轮反过来从右往左遍历并往右找没用的位置，如果一个位置两轮都没被标记成有用的，那它确实没用了。这个好像有点像 雪灾与外卖 的某个部分分?

怎么证明这个东西的正确性?如果一个全局众数在第一轮被标记没用，那么它往右不管怎么延伸，都有全局众数出现次数多于我们处理的数(因为数两两配对，而总是剩下这一个)，所以它不可能作为一个左端点。

然后剩下的可能端点数就是$$O(cnt)$$的了。不过怎么找到这些点?

数据结构问题是 : 删一个数，查询前驱，重置。可以用并查集来维护，当然可以用线性并查集做到线性。

啊你说重置?考虑线性并查集需要修改$$\Omega(\log n)$$次才会合并第一次，所以全撤回去复杂度是正确的。普通的并查集呢?好像只能多个$$\log$$吧。

然后问题是在这些端点里面找到最长的区间，使得全局众数和我们处理的数出现次数相同。

这是经典技巧。把所有全局众数改成$$1$$，处理的数改成$$-1$$，问题变成找和为$$0$$的区间，拆前缀和扔进桶里即可。这样就线性了。

-----

CF997E Good Subsegments

给一个排列，每次给一个区间，查询有多少子区间值域连续。$$n\leq 1.2\times 10^5$$，可以做到$$5\times 10^5$$。

你发现因为是排列，一个区间连续，相当于$$r-l=\max-\min$$。

考虑分别建立大/小根笛卡尔树，那么每一个$$\max/\min$$的贡献是一个矩形，同时$$l,r$$的贡献也是矩形。问题变成矩形加减，数一个点右下方有多少$$0$$。

先把修改查询都差分掉，然后肯定扫描线，问题变成区间加减，查历史$$0$$总个数。怎么维护$$0$$的个数?

你发现这里一定有$$r-l\leq\max-\min$$，所以我们可以线段树维护区间最小值和最小值个数，然后历史和的话硬打标记就好了。

-----

CF765F Souvenirs

给一个序列，每次查询一个区间中选两个数，差的绝对值的最小值。$$n\leq 5\times 10^5$$。

回滚莫队大家都会!但是那太慢了。

对于每个$$i$$，考虑它和哪些位置拼起来可能有用，我们试图从左往右找出这些位置。

先只考虑顺序对，逆序对可以相反地求出来。

我们找到$$i$$右边第一个比$$a_i$$大的$$a_j$$，这个$$j$$肯定有用。然后考虑接下来如果一个$$k$$想要$$(i,k)$$优于$$(i,j),(j,k)$$，那么$$a_k$$就必须更靠近$$a_i$$(比起它靠近$$a_j$$的程度)，那么$$a_k$$的取值范围就在$$[a_i,\frac{a_i+a_j}{2}]$$内了。你发现值域变成了一半!这样找$$O(\log v)$$个就一定会停下。

这个东西可以从后往前建立主席树来找到，每次是一个$$\log$$的。剩下的就是二维数点了。总共是$$O(n\log n\log v+m(\log n+\log\log v))$$，

-----

CF176E Archaeology

维护一个点集，支持插入删除，查询斯坦呐树权值和。$$n,q\leq 10^5$$。

呃结论是，斯坦呐树权值和，就是按照dfn排序成一个环之后，相邻点两两距离之和的一半。set维护即可。

另一种做法是Top tree/jy

不过可以比Top tree更优，因为我们可以用vEB代替set查前驱后继。

-----

CF896E Welcome home, Chtholly

第二分块的在线版。

给一个序列，支持区间$$>x$$的减$$x$$，查询区间某个数出现次数。$$n,a_i\leq 10^5$$。

值域1e5!要查询出现次数，显然是开值域桶。要平衡掉巨大的桶，考虑分块。

容易发现对于这个修改操作，每一个数大小都是不升的。这题核心在于 : 用块最大值的减小，摊掉爆力修改的复杂度。

先考虑我们需要支持什么查询。整块查询的时候，只需要查一个数出现次数；零散块重构的时候，则需要快速对于每个数查询它变成了什么数。

考虑设最大值是$$k$$，

 - 如果$$2x> k$$，那么最大值会减小至少$$k-x$$，所以我们只可以付出$$O(k-x)$$的实际复杂度。啊这个很简单，爆力枚举所有被减了的$$O(k-x)$$个值，然后用并查集来合并就好了。啊具体就是我们需要合并$$i$$和$$i-x$$。

 - 如果$$2x\leq k$$，那么最大值会减小至少$$x$$，所以我们只可以付出$$O(x)$$的实际复杂度。考虑反过来，我们把所有值都减$$x$$，然后把原来$$1,...,x$$这些值都加上$$x$$，第一个可以打全局减标记，第二个可以枚举这$$O(x)$$个值用并查集合并。

注意到这个并查集比较特殊，它的`find`一定是在零散块重构的时候，所以一定总是`find`一遍，所以复杂度是线性的。总共就是$$O(n\sqrt{n})$$。

离线版本是线性空间的，这个注意到查询很容易合并，所以可以离线对于每一块分别处理。

-----

CF700D Huffman Coding on Segment

给一个字符串，每次查询区间Huffman编码之后的长度。$$n,q\leq 10^5$$。

出现次数只有根号种，可以暴力莫队搞定每个区间的出现次数们，然后离线计排，线性Huffman树就做完了。

-----

CF453E Little Pony and Lord Tirek

给一个序列，每个位置一开始是$$a_i$$，每时刻会增大$$r_i$$，直到上限$$m_i$$。有一些操作依次进行，每次查询一个区间的和，并把这个区间推平成$$0$$。

破坏性查询，考虑连续段均摊，当然这里的连续段是上一次推平时间的连续段。发现查询一整个连续段的时候，我们需要知道的信息有两个 : 

 - 所有达到上限的位置的上限之和

 - 所有没有达到上限位置的增长速度之和

第一个怎么做?考虑如果距离上一次推平的时间$$t$$至少是达到上限所需时间$$\lceil\frac{m_i}{r_i}\rceil$$的时候，$$i$$就达到上限了。于是可以用一个按$$\lceil\frac{m_i}{r_i}\rceil$$排序的平衡树维护。

第二个怎么做?用那个平衡树也可以搞定。所以我们就得到了$$O(n\log n)$$算法。

-----

CF1476G Minimum Difference

给一个序列，单点修改，或者查询从一个区间中选$$k$$个不同的数，使得这些数在区间中出现次数的极差最小，输出这个极差。$$n,q\leq 10^5$$。

不同出现次数是根号的，所以还是可以爆力莫队搞定，单点修改那就带修莫队。就过了/jk

-----

CF1344E Train Tracks

树，边权。树上有一些火车，每个在$$t_i$$从$$1$$出发前往$$s_i$$。每个点每个时刻向儿子的铁轨只能有一个方向，你每个时刻可以选择一个点，更改它连向的儿子，这个操作先于火车移动。如果火车跑到一个点上，接下来要走的方向和铁轨开放的方向不同，那它就会自爆。求能不能让火车不自爆，如果不得不自爆最晚在什么时候自爆，以及至少需要调整多少次铁轨方向。

这个信息看起来很巨量，所以考虑能不能重用。想到静态链分治，数据结构要支持插入并查询前驱后继，用一个set来维护即可。可以换成动态开点vEB，不过我觉得没有人想写动态开点vEB的。

-----

CF1017G The Tree

树。支持把一个点的黑色连通块向下扩展一个单位，把一个点子树染白，查询一个点的颜色。

考虑一个点是黑色，当且仅当存在一个祖先，使得这个祖先到这个点链上染黑的操作次数加起来，至少有这条链这么长。这个可以树剖之后从下往上线段树二分解决，或者直接静态Top tree二分做到一个$$\log$$。

染白这个操作很不好，因为光是清空子树的染黑操作次数不够，上面的染黑操作可能渗透下来。

不过你发现，如果上面的操作渗透下来$$d$$单位，我们可以染黑$$-d$$次。这么做可行是因为染黑这个操作次数已经被我们彻底抽象掉了，它的意义已经不重要了，进行负数次也没什么问题。这个$$d$$也可以树剖线段树求出来。

-----

CF1340F Nastya and CBS

收录于 类楼房重建线段树。（然而好像写错了

## Day3

### 模拟赛

T1

定义$$f(x)$$是$$x$$所有因子的异或和，给一个$$n$$，求$$f(1)$$到$$f(n)$$的异或和。$$n\leq 10^{14}$$。

直接整除分块。

-----

T2

平面上有一些横平竖直的线段，在两条线段之间连边当且仅当它们有交，求所有割点。

显然主席树优化建图，但是建出来发现不容易直接跑Tarjan。

考虑利用主席树的结构来维护Tarjan。我们要支持 : 

 - 查询第一个没有走过的邻接点

 - 查询邻接点`low`的最小值

，显然可以维护

 - 区间有没有没被遍历的点

 - 区间`low`的最小值

。注意到在主席树上合并信息并不容易，不过其实我们不需要保证所有点的信息都是正确的，可以等需要信息的时候再去`push_up`。这样每个点应该只被更新一次，所以就是$$O(n\log n)$$。

另一个做法是，注意到图的特殊性质，只可能是一条横线割掉之后让竖线不连通，或者一条竖线割掉后让横线不连通，可以分开处理。如果只要求一遍连通性的话，直接扫描线扫过去，用线段树维护可以合并的点，并查集来合并就好了。要删每一条竖线，可以用 消失之物 的分治。这样做是俩$$\log$$的。

-----

T3

树，每个点有一个颜色，支持单点改颜色，一个点所在的同色连通块改颜色，查询一个点所在同色连通块的颜色、大小、最大深度、最小深度。颜色只有$$30$$种。

点连通块性质不优秀，把点权转移到父边上，转而维护边连通块。

考虑每次连通块改颜色，可能会使连通块变大，不过这个是有均摊的，可以爆力修改。

ETT。维护连通块下方有哪些颜色，每次改的时候找到下面有没有相同的颜色，爆力递归下去合并就好了，这样我们以一个$$\log$$的代价合并了两个连通块。总复杂度$$O(nc\log n)$$，那个$$c$$是合并颜色是否存在信息的代价。

发现这个 有哪些颜色 的合并是一个二进制$$\mathrm{or}$$，考虑压位成一个`int`，复杂度就砍掉了那个$$c$$。

### 讲课

lxl!

-----

Ynoi2016 这是我自己的发明

换根的trick，然后大力差分。

-----

爆炸oj3920 Yunna的礼物

序列，每次给出$$x,y$$，查询一个区间里面出现次数第$$x$$小的数里面第$$y$$小的。线性空间。

不管线性空间怎么做?要查这个出现次数很容易，一个值域分块就好了。要查这个数，我们可以对每种出现次数开一个值域分块，然后动态开点一下就好了。

诶这个动态开点好像是空间瓶颈。考虑可能的$$(\text{出现次数},\text{数})$$只有$$n$$种，所以我们可以进行 高维离散化。

高维离散化是什么?开一排`vector`，对于出现了$$c$$次的$$x$$，把它分别push进第$$1,2,3,...,c$$个`vector`里，然后对于每个`vector`分别离散化。

然后就很简单了，我们可以直接在每个`vector`上开值域分块，空间就是线性了。

-----

爆炸oj4241 历史研究

给一个序列，每次查询一个区间$$x\times x\text{的出现次数}$$的最大值，线性空间。

这题可以不用回滚莫队。

不考虑空间，爆力做法是莫队的时候直接给每个出现次数开值域分块。

注意到跟上一题一样，这题也可以高维离散化，然后再值域分块就好了。

-----

Ynoi2015 いずれその陽は落ちるとしても

给一个序列，每次查询一个区间的所有子序列去重之后的和的和。每次的模数不同。

很有意思。考虑如果区间长度是$$l$$，一个数$$x$$出现$$c$$次，那么它的贡献是$$x2^{l-c}(2^c-1)=x2^l-x2^{l-c}$$。第一个很容易维护，第二个怎么办?

注意到不同的出现次数只有根号种，所以我们完全可以搞出来爆力处理。

至于快速幂，可以用 光速幂 来做。

-----

HNOI2016 大数

考虑是质数是个什么东西。

显然特判掉$$p=2,5$$，然后剩下的就和$$10$$互质了!

考虑打一个后缀和(因为前缀和不好打)，然后一个区间就可以表示成$$\frac{suf_l-suf_{r+1}}{10^{n-r}}$$，你发现因为$$p$$和$$10$$互质，那个除$$10^k$$是不影响的，所以就变成区间数有多少对膜$$p$$相等，小Z的妹子即可。

-----

luogu3604 美好的每一天

给一个串，每次查询一个区间里有多少子区间可以重排成回文串。

考虑利用异或来搞。给字符$$c$$权值$$2^c$$。这样如果一个区间的异或和是一个$$2^k$$就可行。

于是搞一个前缀和，枚举那个$$k$$来转移，复杂度就是$$O(n\sqrt{n}\Sigma)$$。

-----

线性空间离线区间逆序对

收录于 apio的课。

-----

爆炸oj4358 permu

给一个序列(而不是排列)，每次查询把一个区间所有数扔进一排桶里，得到的最长连续段长度。

考虑对于每个连续段维护左右两个指针。每次插入的时候，如果插入到非空桶那就没啥需要做的，否则我们看左右是不是已经有东西，一边有就并入，两边都有就合并两边。这个不好删除，所以可以回滚。

-----

在线区间逆序对

爆力处理各种贡献就好了!

-----

SHOI2006 Homework

集合，支持插入$$x$$，或者给出$$y$$，查询$$x\bmod{y}$$的最小值。值域$$10^5$$。

对$$y$$根号分治。对于小的直接维护答案，对于大的，注意到$$y,2y,3y,...$$只有根号个，而只有每一个的后面第一个$$x$$可能产生贡献。

于是要支持$$O(\sqrt{n})$$插入和$$O(1)$$查询后继。发现插入就是前驱+推平，所以可以直接值域分块解决。

-----

POI2015 ODW

树，点权，每次给出$$u,v,k$$，求从$$u$$出发，每次跳$$k$$步，跳到$$v$$，走过的点权和。保证$$u,v$$的距离是$$k$$的倍数。

对$$k$$根号分治。对每个小的$$k$$离线下来，按深度膜$$k$$建$$k$$棵虚树做树上前缀和。

对大的$$k$$直接爆力跳，用$$O(n\log n)-O(1)$$ LA的科技就可以做到一个根号了。

-----

Ynoi2015 いまこの時の輝きを

序列，每次查询一个区间乘积的约数个数，膜$$19260817$$，值域$$10^9$$。

先爆力Pollard-Rho分解一遍!

每个数只能有$$O(\log v)$$个质因子，可以爆力莫队，复杂度$$O(n\sqrt{n}\log v)$$。

每个数只能有$$O(\log v/\log\log v)$$个不同质因子，复杂度$$O(n\sqrt{n}\log v/\log\log v)$$。

刮痧不动了。考虑对质因子大小根号分治，我们取$$v^\frac{1}{3}=1000$$作为阀值，小的据说只有$$168$$个可以打前缀和，大的不超过两个可以莫队维护。这样就做完了。

总复杂度算一算，应该是$$O(n(\sqrt{n}+v\frac{1}{3}/\log\log v)$$，这里认为PR复杂度是$$O(v^\frac{1}{4})$$。

-----

Ynoi2009 ra1rmdq

给一棵树，**非负**边权，还有一个结点序列。支持区间跳父亲，查询区间最大深度，深度是边权意义下的。

收录于 洛谷省选计划。

-----

Ynoi2011 D2T2

给一个序列，每次给出区间和一个$$b$$，查询最大的$$x$$，使得存在一个$$a$$，使得$$a,a+b,...,a+(x-1)b$$这$$x$$个数全在区间里出现过。值域$$10^5$$。



-----

半平面数点

k-dt

最广为人知的是k-dt，但是它是假的，但是它随机数据是真的。

旋转扫描线

这个东西是说，考虑$$n$$条直线把平面分成$$O(n^2)$$个区域，我们爆力处理每个点在哪个区域，然后按照极角序转转转处理每个查询。复杂度是$$O(q^2+n\log n)$$。

分块

发现旋转扫描线复杂度不平衡，可以对查询分块处理，可以得到根号$$\log$$做法。

四分树/六分树

半平面数点的两个简单结构。

四分树每次选取两条直线，把平面分成四个区域，四个区域点数相同，那么每个半平面只可能递归到其中三个，所以复杂度是$$T(n)=3T(\frac{n}{4})+O(n)$$。解出来大概是$$n^{1.8}$$。

六分树每次选取三条直线(交于同一点)，把平面分成六个区域，六个区域点数相同，那么每个半平面只可能递归到其中四个，所以复杂度是$$T(n)=4T(\frac{n}{6})+O(n)$$。解出来大概是$$n^{1.7}$$。

当然可以继续搞下去，但是更高的划分数就会带来巨大的常数，算法竞赛中没什么意义。

结合旋转扫描线爆力，可以获得比根号略低的半平面数点做法。啊你说怎么结合?你就分治到一定大小改为爆力就好了，这可以做到$$O(n^{1.442}\log n)$$(四分树)之类的，没有找到六分树的分析。

-----

Ynoi2019 宝石之国/CTS2021 半平面修改查询

平面上有一些点，每一个都有权值$$a_i$$，注意权值是抽象数据类型。每次操作求一个半平面的和，然后把半平面乘上一个抽象数据类型。$$n,q\leq 10^5$$，基本运算次数不超过$$2.5\times 10^7$$。

考虑一个爆力。我们都知道$$n$$条直线把平面分成$$O(n^2)$$个区域，所以可以考虑这样的分治 : 

一开始给每个点找到它所在的区域，接下来在时间上进行分治，每次递归下去的时候合并一些区域，回溯会把一些区域再分开。递归到底层的时候，只剩下两个区域，此时可以

-----

Ynoi2019 美好的每一天~不连续的存在

树，点有颜色，还有一个序列$$a$$。每次查询一个编号区间，它在树上形成了若干连通块，每个连通块如果有$$k$$个出现奇数次的颜色，会对答案造成$$a_k$$的贡献，总答案是贡献和。

势能均摊莫队。看下去之前我要提醒你，势能均摊莫队和我们说的势能法摊还分析没有关系。

考虑莫队。发现插入的时候，好像只能启发式合并/yun

启发式合并有什么问题?不能删除，横跳的指针复杂度也不是很对，因为一个块里面可能有巨量的操作，是可以构造出来的。

不管怎么说先回滚一个。每个块处理右端点在块里的询问，那么左端点的移动显然正确，右端点的横跳怎么保证?

考虑按照启发式合并中的实际代价，也就是操作的次数分块。如果设$$f(l,r)$$表示往$$[l,r-1]$$插入$$r$$的代价，注意到一件事 : $$f(l,r)\leq f(1,r)$$。这是因为树的性质，只有$$r$$这个点可以合并它周围的连通块，所以不插入它的话，区间越长，它周围的连通块不会变少。

所以你发现，不管左端点在哪，横跳的时候插入并撤销一整个块的代价，不会超过固定左端点在$$1$$时的代价。而$$f(1,i)$$之和是$$O(n\log n)$$，于是我们按照$$f(1,i)$$之和每$$\Theta(\sqrt{n}\log n)$$个分一块，就得到了一个$$O(n\sqrt{n}\log n)$$的做法。

注意我们在做这个的时候，只用到了$$f(l,r)\leq f(1,r)$$的性质，所以势能均摊莫队对这一类问题具有普适性，虽然这一类问题本来就没多少。比如如果把这题放到图上，这个性质就不存在了，因为多插入的点可能已经把一些连通块合并掉了。