---
layout: post
title: zroi noip18联测
subtitle: 蔡老板赚大钱
tags: 课
---

以及两天的杂题选讲（

## Day1

杂题选讲。

-----

CF1427E Xum

牛逼题/jy

直接想法是，随$$10^3$$个倍数插入线性基，但是这个好像不太行。

更随的想法是，直接随$$10^5$$次操作插入线性基，这个好像很可以。

简单做法是，考虑每次消去最高位，于是设$$x$$的位数是$$k$$，你就考虑把$$x$$左移$$k-1$$位使得它的最低位和$$x$$的最高位对齐，记为$$t$$，那么$$y=x\operatorname{xor}t$$就消去了$$x$$的最高位。此时我们把这个数以$$x$$的最高位分成两部分，高一半就是$$t-1$$，而低一半是$$x$$除去最高位。

然后我们给$$y$$再加上$$t$$，低一半不变，高一半变成$$2t-1$$。注意到$$2t$$的$$\mathrm{lowbit}$$必然是$$2$$(忽略后面一车$$0$$)，于是这里必然在$$2$$上造成退位，于是它的$$2$$这一位变成$$0$$而$$1$$这一位变成$$1$$。

考虑$$2t$$，我们计算$$(x+2t)\operatorname{xor}(y+t)$$，$$x+2t$$在$$k,k+1$$位上是$$1,1$$，而$$y+t$$是$$1,0$$。我们得到了一个$$2^{k+1}$$，但是本来打算要$$2^k$$来着¿

没有关系，我们可以用这个把$$t$$中$$>k$$位的$$1$$全都干掉，就得到了$$2^k$$。做完了。

惊悚做法是，考虑裴蜀定理。

发现$$x\operatorname{xor}t$$必然和$$x$$互质，因为$$x\operatorname{xor}t+2^k$$是$$x$$的倍数，而$$2^k$$不是。

所以我们exgcd解出一组$$a,b$$使得$$ax+by=1$$，现在问题是$$a,b$$可能有负数，正数直接做就完了。

考虑钦定$$b$$是负的，那么直接给$$b$$取负，问题变成实现减法。注意到$$ax,by$$是相邻的，于是如果是奇数减偶数就可以直接$$\mathrm{xor}$$，如果是偶数减奇数那我们就都加上$$x$$，就变成奇数减偶数了。

-----

CF1340D Nastya and Time Machine

classic/jy

收录于 CF思维题选胡。

-----

CF1442D Sum

classic/jy

收录于 CF再选做。

-----

CF1446C Xor Tree

建立trie，设$$dp(u)$$表示$$u$$子树最多保留几个点。发现只选一棵子树一定是可以的，如果选了两棵子树，那么其中一棵一定只有一个点，超过一个则会自己连自己，两边就不连通了。

-----

CF1439B Graph Subset Problem

classic/jy

收录于 CF思维题选胡。

-----

洛谷P4007 小Y和恐怖的奴隶主

看起来就直接设$$dp(i,a,b,c)$$表示打了$$i$$下，有$$a,b,c$$个$$1,2,3$$血量的随从概率，$$f(i)$$表示打boss次数的期望，转移是线性变换，状态数大概不到$$500$$，矩阵快速幂即可。多测就预处理幂，矩阵乘向量。

实际上据说状态数是$$166$$(包括$$f$$)/jy

-----

HDU6145 Arithmetic of Bomb II

看起来很有儒略日内味。

考虑我们把每个bomb表达式标准化成左闭右开，也就是左边是数字，右边是运算符。

如果一个bomb表达式两边都是符号，那它就完了。如果两边都是数字，我们可以拆出第一段和最后一段，把中间搞成左闭右开。

然后就可以考虑，如果最后一个是加号那就简简单单；如果最后一个是乘号，如果全是乘号那就直接做，否则就把最前和最后一项拼起来，还是特判开头结尾。做完了。

然后听说是矩阵快速幂/jy

考虑一个牛逼做法，我们维护三元组$$a+bc$$，那么加入一个数字和三种符号都是线性变换，做完了。

-----

Gym100543L Outer space invaders

离离原上谱，区间dp。

考虑设$$dp(i,j)$$表示干掉左右端点都在$$[l,r]$$的敌人的最小代价，那么最远的那个一定要为它开一炮，于是我们可以枚举什么时刻把它干了，就分成两段了。

这还是一个扫描线方向的问题，这个做法就是按距离从上到下扫描线。所以还是不要一上来就咬定自己的扫描线方向。

-----

Gym101480E Export Estimate

扫描线。

注意到所有二度点都会被删掉，会减少一条边。

然后考虑自环不会被删。

并查集维护即可。

-----

Gym101620J Justified Jungle

$$k+1$$必然是$$n$$的因数，所以就枚举一个大力模拟即可。

然后你发现砍了一个点的父边，当且仅当它的子树大小是$$\frac{n}{k+1}$$的倍数，于是做完了。想不到吧，狄利克雷前缀和一下，这是$$O(n\log\log n)$$的/jy

------

Gym101620L Lunar Landscape

垂直于屏幕向外扫描线（

坐标极小，我们直接算每个格子被覆盖多少次(斜边上是0.5次)，两类分别差分-前缀和即可。

哦注意到斜边有四类，所以我们需要给每一类斜边都开一个差分-前缀和，所以是六个/jy

-----

AGC052B Tree Edges XOR

随便找一个点作为根，求一个树上前缀和，那么边权就变成了点权的$$\mathrm{xor}$$。

考虑此时一个操作的效果，发现它就是交换端点的点权。

所以我们直接判断两个集合是否相等，然后就wa飞了。

考虑这个找一个根，相当于钦定了一个点点权是$$0$$，但是后面这个点权可能换走了。所以我们需要枚举那个点权换到哪里去了，或者枚举它可能还被钦定成了什么(这个数一定可以是某个$$d$$)，这就$$n^2$$了。

注意到$$n$$是奇数，所以我们给所有数都$$\mathrm{xor}$$上全局$$\mathrm{xor}$$和，就相当于把它们标准化了，判断是否同构即可。

另一个直接且爆力的想法是，我们直接找到一组点权$$f$$，使得一条边的权值是端点权值的$$\mathrm{xor}$$。为了保证唯一性，由于$$n$$是奇数，我们可以限制总$$\mathrm{xor}$$和是$$0$$。直接分配，然后给每个数$$\mathrm{xor}$$上总$$\mathrm{xor}$$和，判断是否同构即可。

-----

COCI2018-2019 TENIS

有三项属性，一个人可能打败另一个人当且仅当有一维排名更靠前，现在要进行淘汰赛，你每次可以选两个人比赛，支持交换两个人的排名，查询一个人是否可能登顶。$$n,q\leq 10^5$$。

考虑每个人在每个维度上向他可以打败的人连边，然后得到三个竞赛图，缩SCC之后还是形成一条链，第一个SCC就是可能赢的人。问题变成找第一个SCC，这等价于找第一个前缀使得三个排列中这个前缀都是SCC并且重排同构，而你发现一个排列中每个前缀都是SCC，因为这是完全可比并且传递的。所以就是找一个前缀使得三个序列的这个前缀同构。

hash看起来并不可行。

考虑找到每个数第一次出现和最后一次出现，那么这条线就不能被这两次出现跨过，每个数相当于一个区间加，要找第一个$$0$$，线段树即可。

-----

洛谷P5307 COCI2018-2019 Mobitel

离离原上谱。考虑设$$dp(i,j,k)$$表示走到$$i,j$$，再乘一个$$k$$就能超过$$n$$，而$$k$$只有根号种，所以就做完了。

-----

洛谷P7207 COCI2019-2020#3 Sob

¿

考虑法嘛塔优化建图，然后Dinic硬上，有没有可能做完了¿

考虑$$A$$中最大的数$$x$$和哪个匹配，我们爆力找出这个数$$y$$，那么$$x-1,y-1$$也能匹配。然后就做完了。

听起来很奇怪，这是为什么呢?优质解答 : 我不知道

-----

COCI2019-2020 Pastiri

树，有$$k$$个关键点，你要放一些守卫，每个守卫可以守住最近的关键点，如果有多个那么都可以守住，求最少需要多少守卫，构造方案。$$n\leq 5\times 10^5$$。

考虑随便选一个根，然后考虑所有深度最深的关键点，我们一定需要一个守卫去守它，但是它实在是很深所以我们希望这个守卫尽量靠上，所以我们要找到所有能守住这个点的点中最浅的。

然后我们就删掉所有影响了复杂度的点。一开始预处理每个点可以守住哪些关键点，可以多源bfs。

-----

COCI2019-2020 Semafor

有最多两个五段显示器，每个可以显示$$0,...,9$$，接下来你要操作$$n$$次，每$$k$$次之后要求每个显示器显示的都是合法数字，问最后显示出来每个数的方案数。$$n\leq 10^{15}$$。

考虑爆力矩阵快速幂，做完了。

吗?你发现要求每$$k$$个的转移矩阵，复杂度比较高，因为状态数是$$2^{5+5}=1024$$。每$$k$$个之间状态数是$$100$$。

考虑一段之内，两个显示器是独立的，所以我们可以分别算，最后卷起来。这个还是不行。

注意到方案数只跟有多少位变化了有关，所以我们可以直接记录现在需要变$$i$$位的方案数，然后这个也可以矩阵快速幂。这个矩阵大小就只有$$11$$。

-----

AGC043B 123 Triangle

差分还取绝对值，离离原上谱。不过可以注意到这个操作对两个操作数是对称的。

考虑答案只可能是$$0,1,2$$。

考虑如果有$$1$$，那么最后$$1$$会把$$2$$吃掉，于是答案只可能是$$0,1$$。否则，答案就是$$0,2$$。

然后你发现操作变成了$$\mathrm{xor}$$，于是用组合数算出每个数贡献多少次即可。膜$$2$$难以处理逆元，可以使用Lucas定理。

-----

AGC044B Joker

爆力01bfs就是$$n^4$$。如何优化?

不要优化。考虑每个人被算入多少次，那么我们就算他在每个时间走出去的最短路，然后算他到每个人的最短路，还是$$n^4$$。

做法足够厉害。考虑先直接往一个方向冲作为最短路，这样最短路的和是$$O(n^3)$$的，然后用spfa的方法爆力更新，每次更新都会减少总和，所以总次数就是$$O(n^3)$$。

-----

AGC045B 01 Unbalanced

把$$0$$变成$$-1$$，问题变成最小化前缀和的极差。

枚举最大值，然后我们能填$$1$$就填$$1$$，这样会让最小前缀和尽可能小。复杂度是$$O(n^2)$$。

结论是，把所有$$?$$当成$$-1$$，然后求最大前缀和$$s$$，那么只需要检查$$s$$和$$s+1$$。因为有一个$$-1$$变成了$$1$$的话，如果最小前缀和在此之前它不会变，否则它也只能变大$$2$$，因此一定不更优。

-----

AGC045C Range Set

考虑怎么判断一个串是否可行。时间倒流，变成你可以把连续$$a$$个$$0$$或者$$b$$个$$1$$变成任意串。

不妨设$$a>b$$，于是如果有连续$$a$$个$$0$$就一定可行，否则考虑如果有连续$$b$$个$$1$$，那么我们把它全变成$$0$$，然后剩下了连续$$a$$个$$0$$就可行。

考虑dp，设$$dp(i,j,0/1)$$表示填了$$i$$位，换完$$1$$连续段之后最后有连续$$j$$个$$0$$，这一位是$$0/1$$的方案数。

 - 如果在填黑色，我们枚举上一个白色的位置，可以前缀和优化

 - 如果在填白色，我们枚举上一个黑色的位置，还是可以前缀和优化

然后就做完了。复杂度是$$O(n^2)$$。

-----

CF1458C Latin Square

足够厉害。收录于 CF再选做。

-----

CF1361E James and the Chase

看到占比，考虑随机化，我们随$$100$$次，然后判断一个点是不是好点。

考虑如果找到了一个好点，怎么才能找到所有好点。建立dfs树，那么因为根是好点，不可能有横向边，于是好点的子树内只有恰好一条返祖边，并且这条边连向另一个好点。复杂度$$O(kn)$$，$$k$$是常数$$100$$。

哦，考虑怎么找好点，那就是有横向边就不是好点，否则就是好点。

-----

CF1444D Rectangular Polyline

先判掉$$h\neq v$$，然后背包背一个一半。

考虑直接构造，我们已经分成了两半，每一半让横着的从小到大排，竖着的从大到小排，这样就可以尽可能远离了。

容易证明这样做一定不会越过对角线，于是不会在顶点之外的地方相交。

## Day2

挂分王/cy

挂了85/cy

40+25+0+100=165，垫底了。

-----

A

给$$p,(a,b),(c,d)$$，每次可以变成$$(2a,b-a)$$或者$$(a-b,2b)$$然后膜$$p$$，求多少次之后变成$$(c,d)$$。$$T\leq 10^5,a,b,c,d\leq 10^9$$。

打表可以发现系数的规律。设最后变成$$(ax-by,bz-aw)$$，操作了$$k$$次，那么$$x+y=z+w=2^k,x+z=2^k-1,y+w=2^k+1$$，这样就可以消去$$y,z,w$$。直接代入解出$$x,y,z,w$$，然后判断是否合法即可，注意需要满足$$1\leq x\leq 2^k$$。

-----

B

给一个序列，你可以删去不超过$$25$$个数，然后把剩下的数划分成两部分，要求两部分的和相同。$$n,a_i\leq 2\times 10^5$$，保证数据随机。

小数据爆力，大数据随机。

一个策略是，先贪心地取使得两部分的差不超过2e5，留下最后$$25$$个元素进行调整。

另一个策略是，猜测其中一个取一个区间可行，多次随机删掉哪些，然后双指针检查。

随机题还是要坚定地认为乱搞能过的/hanx

-----

这题[有一个牛逼版本](https://www.luogu.com.cn/problem/P7703)是说，给一个序列，可以任选两个非空子集，让它们的和相等，值域达到1e18，还是随机生成的。

考虑我们排序之后把相邻两项合并，也就是用大的减去小的。这个操作会把每个位置的期望除一个$$n$$，并把$$n$$减半，$$n=5000$$时七次就可以把期望值减小到$$0.0268$$左右，也就是说每个数期望都会非常接近$$0$$，于是很大概率出现一个$$0$$。用链表维护每个数从哪里来，再搞上基排，复杂度是$$O(n)$$，当然这里认为$$v=n^{O(1)}$$。

看起来这个做法最多进行$$\lg n$$轮，此时$$v$$变成了$$\frac{v}{n^{\frac{\lg n-1}{2}}}$$，令它为$$O(1)$$则得到$$v=O(n^{\frac{\lg n-1}{2}})$$，这个已经超过了我们一般认为的$$v=n^{O(1)}$$。我不知道应该如何扩展这个方法使它能支持更大的$$v$$。

这个题应该成为 传世经典。

-----

C

给一棵树，有未知任意点权，你可以知道每个大小$$>k$$的子树除去根的点权和，也可以知道每个儿子个数$$\geq k$$的点的儿子点权和。现在你可以进行若干次操作，每次删掉一个叶子，删完之后你会得到这些点权和，求最多可以利用这些信息确定多少个点的点权。$$n\leq 10^5$$。

注意到一个点有兄弟，它就不可能被问出来，因为任何一次询问它们都同时出现。所以只有独子能被求出来。

现在对于每个独子，如果它的子树大小$$>k$$，那么可以用它的父亲的子树和减去它的子树和。

如果它的子树大小$$\leq k$$，它子树里的点就都不能确定了。一个特例是，如果它的子树大小是$$1$$，那么它说不定可以搞出来，方式是用爷爷的子树减去爷爷的所有儿子，再减去爷爷的所有其它子树。

所以一个点可以求出来，当且仅当

 - 是独子

 - 满足以下两个条件之一 : 

    - 子树大小$$>k$$

    - 是叶子，爷爷儿子个数$$\geq k$$，叔叔们要么子树大小$$>k$$，要么是叶子

然后呢?考虑一个dp，设$$dp(u,i)$$表示$$u$$子树保留$$i$$个点的答案。呃你发现其实没必要记$$i$$，因为叶子的$$dp$$值是$$0$$，所以$$dp$$
非$$0$$的点子树大小一定$$>k$$。

所以考虑转移。对于每个子树，如果它大小$$>k$$，那么可以只选这个子树。

如果要选一个叶子呢?首先需要保留$$k$$个儿子，然后你发现如果一个点$$dp$$值是$$0$$，不如直接把它删成叶子，否则就留下它。所以方法是留下一个只有一个叶子作为独子的儿子(有可能本来就是，也有可能是删一个$$dp$$值尽可能小的子树，这里只有删$$dp$$值为$$0$$的才有用)，然后把其它儿子加起来(有值的一定足够大，值为$$0$$的可以删成叶子)。

当然也可以什么都不做，这样就是把所有儿子的值加起来。

-----

D

签到题。

## Day3

简单题，但是C智障了，没能一眼看出来/cy

100+100+0+25=225。

-----

A

爆搜，签到题。

-----

B

法嘛塔求最大and/or，板子题。

-----

C

给一棵树，一开始有两个黑点，然后你每次可以把每个黑点旁边的一个黑点染黑(也可以不染)，注意每次操作是对每个黑点都做一次，问最少多少次可以把整棵树染黑。$$n\leq 10^5$$。

考虑如果只有一个黑点，直接dp，把儿子们按照$$dp$$值从大到小染黑就行了。

如果有两个，那么中间一定会在某个地方相撞，然后分成两部分。容易猜到单峰，三分这个点即可，不过可能会出现平的一段，此时可以向两侧倍增找到段的开头结尾。

更好的方法是二分，尽可能让两边的操作次数相同。

更好的方法是直接顺着，倒着分别扫一遍，然后枚举中点，瓶颈在于排序，可以vEB做到$$\log\log$$，但是更低我就不会了。

-----

D

码力题，没什么营养。

## Day4

100+100+100+0=300。奇怪。

-----

A

模板 法嘛塔，签到题。我多个$$n$$直接冲过了。

-----

B

模板 莫反，签到题。

-----

C

有趣题。有$$n$$个人排成一排要比赛，每次你选择**相邻**两个人比一比，输了的就溜了，现在给你任意两个人之间的胜负情况，求有多少人可以赢得最后的胜利。$$n\leq 2000$$。

考虑一个爆力dp，设$$dp(l,r,i)$$表示$$i$$能不能成为区间$$l,...,r$$的胜者，转移就枚举一个划分，看$$i$$是从哪边上来的，另一边就需要是一个$$i$$可以打败的人，可以用bitset优化做到$$O(n^5/w)$$。

考虑优化，你发现一个结论是，让$$i$$只打两场，一次干掉他左边的胜者，一次干掉他右边的胜者，这么做一定不劣。于是可以省去枚举划分，复杂度变为$$n^4/w$$。

你发现枚举一个$$i$$之后，我们要做的bitset操作就是把左半边和$$i$$能打败的人and起来，右半边也和$$i$$能打败的人and起来，然后看两边是否都有$$1$$。

你发现一个区间的$$dp$$值只会和左/右端点and起来，于是我们就能将这个and的次数降为$$n^2$$，此时转移复杂度从$$O(n/w)$$降为$$O(1)$$，一共是$$O(n^3)$$。

看一眼你就发现还可以用bitset批量转移，于是变成了$$O(n^3/w)$$。做完了。

空间很大，~~zroj忍一下~~ 需要滚。

-----

D

神题。给一张图，从每个点走到$$s$$，有一条未知边断了，只有你走到旁边才会发现它断了。求最优方案中，最坏情况下每个点到$$s$$的路程。$$n\leq 10^6,m\leq 2\times 10^6,w_i\leq 10^9$$。

考虑一定是你想走一条路径，然后这个路径冲到一半发现边断了，那就完蛋了，你只能走新的最短路。注意你一开始想走的这条路径不一定是最短路，因为从最短路中退出来可能会有巨大的花费。

我们把路径分成两段，一段是从起点$$u$$到发现边断了的时候所在的点$$v$$，一段是从$$v$$到$$s$$。容易想到先求后一段。

考虑如果我们断的不是$$v$$在最短路树上的父边，那么这条边断的毫无意义，本来要走最短路，结果现在最短路没有变。所以我们求出$$f(v)$$表示断掉$$v$$在最短路树上的父边之后$$v$$到$$s$$的最短路。

先假设我们算出来了这个东西，那么接下来我们考虑一条路径最优，当且仅当在路径上每一个点处断开，得到代价的最大值最小。考虑设$$dp(u)$$表示$$u$$出发的答案，那么有转移

$$
dp(u)=\min_{e=u\leftrightarrow v}\max(f(u),dp(v)+w(e))
$$

，这个看起来有点像最短路，直接猜测可以使用Dij求解即可，实际上这个完全就是一个最短路，只不过你在确定了一个点的最短路之后才能确定它邻边的边权。

现在问题是怎么算各$$f$$。

根据k短路的经典结论，断了一条边之后，只可能走一条非树边。所以每条非树边相当于是给它端点之间的树链加上了一个换边的选择，并且形式很简单，我们直接用树剖维护这个东西，就可以做到一个$$\log$$。时限极高(7s)，可以过掉。

更好的方法是排序之后变成在链上找到所有$$0$$并推平成$$1$$，可以用并查集维护，使用基排则瓶颈在Dij，可以用线性最短路来优化到线性/jy

## Day5(10.18)

100+100+3+0。C写麻了。

-----

A

签到题。

-----

B

签到题。

-----

C

签到题。基环树找环请用toposort。

-----

D

给一个图，求DAG生成子图个数。$$n\leq 18$$。

这是一道传世经典 清华集训2014 主旋律 的一个部分，而这个题收录于 子集反演。

## Day6

100+15+0+0=115。

非常牛逼。

-----

A

签到题。还是一个扫描线方向的问题。

-----

B

好玩题。给一张图，给边染成黑白，要求每个点的邻边中两种颜色的个数差不超过$$1$$。$$n,m\leq 10^6$$。

结论是，如果一个连通块所有点的度数都是偶数，但是有奇数条边，那么必然无解，否则可以直接跑 Mike and Fish 的欧拉回路，也就是在欧拉回路上交替染两种颜色。

为什么这就无解了?小朋友想一想，因为所有点度数都是偶数，那么每个点的两种颜色邻边数差必然是$$0$$，所以我们知道两种颜色的边数应该是相等的，所以总边数不应该是奇数。

为什么除此之外一定有解?加入虚点之后，所有点度数都是偶数，如果有奇数条边，我们从$$0$$开始跑会导致$$0$$的差是$$\pm 2$$，不过反正我们要把它删掉。如果有偶数条边则更简单。

-----

C

好玩题。给一棵树，点权，求每个点的 子树和到根路径的并 的补的线性基。$$n\leq 4\times 10^5,v<2^{61}$$。

考虑这个东西是什么，你发现我们dfs这棵树，在离开一个点的时候把它加入线性基。反着再dfs这棵树，在离开一个点的时候把它加入线性基。分别记录这两个东西，那么一个点的答案就可以用dfs到它时的两个线性基合并出来。

然后注意到一个很好玩的事情，这样dfs只有插入，而只插入得到的线性基只有$$\log v$$种，所以我们求出所有线性基，预处理它们两两的合并即可。总复杂度是$$O(n\log v+\log^4 v)$$。

有一个牛逼题是Ynoi2008 stcm，不过那个远强于这个。主要还是线性基不撤销的话信息变化总量只有$$\log v$$。

-----

D

好玩题。给一张图，一开始是空的，每次从一个区间每个点到另一个区间每个点连边，然后去掉所有重边和自环。求有多少种方式选择一些没有出现的边加入图中，使得每个点度数都是偶数。$$n\leq 10^5$$。

加边是矩形or，可以用扫描线线段树搞定，具体一点就是看成矩形$$+1$$，那么没有边就是$$0$$，而不会出现负的，所以可以线段树维护最小值及其个数。

把度数数组和边对度数的改变都看成向量。

考虑补图，每个连通块是独立的，而连通块内存在生成树，生成树是$$n-1$$维的，而度数也是$$n-1$$维的(有一维是没有用的，因为度数和必然是偶数)，所以不管别的边怎么选，都有唯一的方案操纵生成树使得最后得到全$$0$$。答案就是$$2^{c-(n-k)}$$，其中$$c$$是还剩的边数，$$k$$是连通块个数。

现在问题是怎么求连通块个数。简单想法是bitset爆力$$O(n^2/w)$$，大概冲不过去。

边数很大，查询方法只有扫描线线段树，于是考虑Boruvka~~别乳卡~~一类的算法。我们线段树每个点存所在连通块编号最小和最大的$$0$$，扫描线扫过去即可，这看起来真的很像 新年的繁荣 的Boruvka+法嘛塔做法。仍然一共需要跑$$\log$$轮，总复杂度$$O(n\log^2 n)$$。

看起来不是很能写。

## Day7

100+60+60+0=220。

-----

A

签到题。

-----

B

大原题 CF741C。

数组开小/cy

-----

C

简单dp题。dp优化一定要考虑清楚，写的时候要按照思考过程来写，不要追求小常数而导致混乱。

被卡常了/ll

滚动数组很有用。

-----

D

奇怪题。平面，你要从极左走到极右，你的方向是向右上或者右下$$45$$度，你可以在任意实数时刻改变方向。有$$n$$条竖线作为障碍，你不能碰到上面去(包括端点)，求有多少面积是你不能走的(走不进去，或者走了就不能到达对面的)。$$n,v\leq 10^5$$。

偷点题解的图。

直觉是直接做矩形并，但是你发现不行，因为两条线段可能相互影响，比如有的点可以躲开其中任意一条线段，但是躲开了这一条就会撞上另一条，那么这个点也是不能走的。

考虑一开始给每条线段画一个斜的正方形，那么如果两个正方形有交，就需要把它们左右缺的角也补上，但是如果是上下缺角则不补。

![img](/img/2021-10-11-zroi-noip/day7-d-1.png)

考虑先补左边的。我们把每个矩形取左半边，得到一个三角形，然后从右往左扫描线扫过去，用set维护它们下面直角边的顺序(具体一点就是按$$x+y$$排序)。加入一个三角形的时候，下面和它相交的三角形只可能是下面第一个，上面和它相交的三角形可以爆力查出，这些会相互影响，整体的作用效果就是合并成了一个大三角形。每次合并都会减少一个三角形，所以复杂度是一个$$\log$$。

![img](/img/2021-10-11-zroi-noip/day7-d-2.png)

两边都做一遍，然后现在问题变成有若干三角形，有朝左的有朝右的，求并的面积。这个看起来很难做，不过注意到一个三角形不能走，它另一边对称的也不能走，所以可以补成正方形，转一转扫描线即可。总复杂度一个$$\log$$。

## Day8

100+80+100+50=330。送分场。

-----

A

简单题。

-----

B

诈骗题。

给一棵树，求所有长$$k$$的路径的逆序对数之和。

注意到路径反过来还是路径，所以每一对都会被算两次，所以逆序对是假的，问题变成了求长$$k$$的路径数，长剖即可。

-----

C

简单题。

-----

D

看起来还挺厉害。

给一个01串，要进行$$k$$轮操作，每次从左往右扫一遍，遇到01就会标记，扫完将每个被标记的01换成10。$$n,k\leq 10^6$$。

考虑这个过程相当于每个0都在往后冲，每次最多冲一格。

考虑一个非常牛逼的递推，我们从右往左处理每个0，然后用某种数据结构维护每个时刻它的位置。你发现最后一个0的位置肯定是一直往后冲直到撞墙。

我们考虑如果已经知道了上一个0的位置，那么这个0至少要跟在上个0后面，所以我们先把它的位置全都往左一位，时间全都往后一位。然后这个0不一定是一直跟在上个0后面，它可能会一开始在很左边，然后慢慢追上来了，所以我们需要再画一条冲过去的线，然后把下面那一段截掉。这里还是偷个题解图。

![img](/img/2021-10-11-zroi-noip/day8-d.png)

把竖着走一步记为0，斜着记为1，用队列维护即可。

这题有点眼熟¿

呃，遇到 会被什么东西挡住，并且只会被一个东西挡住，那么就从那个递推过来就好了。刺激¿

## Day9(10.25)

100+0+0+0=100。这就是noip模拟赛吗?

-----

A

简单题。

-----

B

奇怪题。

给$$n$$个三维向量，求线性无关的无序三元组个数。$$n\leq 2500$$。

考虑三个向量线性无关，等价于它们两两张成的面不同，所以我们枚举两个，把它们张成的面扔进map，然后统计答案即可。

一个爆力做法是转成直线数点然后直接扫描线，复杂度是一样的，但是这个需要实现分数所以极度麻烦。

-----

C

简单题。但是为什么这么难写/fn

给一棵树，定义一个连通块的权值为点权的积，对每个点求所有包含它且大小不超过$$k$$的连通块的权值和。$$n\leq 3000$$。

直接做，发现dp可以写成生成函数卷积，于是我们带一车点值扔进去，dp过程是$$O(n^2)$$了，现在问题是插值还原太慢了。

注意到只需要求前$$k$$项系数和，仔细观察拉插的式子，发现这个系数可以$$O(n^2)$$预处理，于是就做完了。

-----

D

noip模拟赛，出个锤子SAM/fn

给一个串的序列，你需要从每个串选一个子串，然后把它们按顺序拼起来，求最后可以得到多少不同的串，这里两个串是否相同只看内容而不看来源。$$\sum\vert s\vert\leq 10^5$$。

## Day10

杂题选讲。

主题是经典题。

-----

Ternary String Counting

Comet OJ #12

ARC074E($$n$$个球的序列，染成RGB，若干限制，每个限制一个区间颜色数，求方案数)，加强到n5e3 m1e6。

容易写出一个dp，设$$dp(i,j,k)$$表示$$i$$染成某个颜色，上一个下一个颜色出现在$$j$$，上一个下下个颜色出现在$$k$$，转移枚举下一位填什么来刷表的话，看起来是

$$dp(i,j,k)\rightarrow dp(i+1,j,k),dp(i+1,k,i),dp(i+1,i,j)$$

。考虑这个转移的结构，第一种转移就是直接copy，第二种是把每一行$$k$$的和加到$$(k,i)$$上，第三种是把每一列$$j$$的和加到$$(i,j)$$上。

考虑如果没有限制，那么我们只需要知道每一行和每一列的和，所以我们只需要维护每一行和每一列的和就好了，这样就优化到$$O(n^2)$$。

考虑有限制的话，每个限制相当于把一个矩形之外的位置全部清空，注意到每个位置被清空之后就一直是$$0$$了，所以可以爆力找没被清过的位置。

-----

Graph Subpaths

给一个DAG和上面的若干条链，求有多少链不包含给定的任何一条链。$$n,m,\sum len\leq 10^5$$。

建一个ACAM(而不是trie图，这里字符集很大)，现在问题是我们需要同时在DAG和ACAM上走，需要同时记录两个点，复杂度就飞了。

考虑了各种想法，发现没有啥用，于是我们大力猜测状态数极少。

考虑一个状态$$(u,v)$$合法，其中$$u$$是DAG上的点，$$v$$是ACAM上的点，当且仅当$$v$$是根，或者$$v$$在trie上父边上的字符是$$u$$。所以trie上每条边只会贡献一个状态。

现在问题是转移复杂度过高，因为这是一个DAG，跳fail次数可以被卡满。需要支持查询一个点在fail树上到根链上第一个存在某个转移的点，这个直接拿可持久化线段树冲trie图就能做。

不过我们有更简单的做法，直接对每个字符的转移把dfs序拿出来二分找就行了。

另一个简单的做法是，把转移先挂上，然后推一遍标记，每个点找到子树内还没匹配的转移，然后我们就知道怎么转移了。

实际上好像有转移顺序的结论，不过我们实在不太需要了（

-----

Tree Equation

CCPC2017 秦皇岛 J

定义两棵有根树的加法是把它们的根摁在一起，乘法是把后面那棵树代入前面那棵树的每个点。

给三棵树$$a,b,c$$，求两棵树$$x,y$$使得$$ax+by=c$$。$$n\leq 10^5$$。

注意到和的点数等于点数的和$$-1$$，积的点数等于点数的积，所以我们可能可以知道点数?好像不能。

考虑最大深度。你发现积的最大深度等于最大深度的和，和的最大深度等于最大深度的$$\max$$。

考虑$$c$$中的最大深度是哪边贡献的，如果是$$ax$$贡献的，那么我们就可以从这个最深的点向上跳$$x$$的深度，这个深度就是$$c$$的最大深度减去$$a$$的最大深度，此时的子树就是$$x$$，然后模拟即可。如果是$$by$$贡献的，也check一下就好了。

AHU冲啊，正确性非常正确，复杂度可以线性。

-----

Wind of Change

XX Open Cup, GP of Korea, Problem K

两棵树，边权，求一对不同的点，最小化它们在两棵树上的距离和。$$n\leq 2.5\times 10^5$$。

在第一棵树上点分治，每个分治块把dis拆成两个深度的和。现在问题变成在第二棵树上，每个点有点权，求点权+距离意义下的最近点对。

注意到这里是$$\min$$，所以不需要考虑是否在同一棵子树。

虚树冲啊，然后就结束了。简单dp即可。

要做到1$$\log$$，st表lca，排序的话每一层统一排序，换成二路分治结构归并排序，或者自顶向下划分，都是可以的。

爆力写挂 不能这么冲，原因是求的是$$\max$$，此时我们需要考虑两个点是否在同一棵子树了，简单想法是用线段树合并来进行虚树上的dp。更简单的做法是这个dp转移只会ban掉一个子树内的点，所以我们只需要设$$dp(u)=(x,y,z)$$表示最小值$$x$$，$$x$$所在的子树，以及和$$x$$不在同一个子树的最小值。还是一个$$\log$$。

但是 通道 要更强一些，先咕咕咕（

-----

Monster Hunter

树，除了$$1$$以外每个点有一个怪，每个怪会砍你$$a_i$$点血然后给你加$$b_i$$点血，如果你的血变成了负数你就没了，每个点的怪只会打一遍。求要打完所有怪，一开始至少需要多少血。$$n\leq 10^5$$。

先二分，然后你发现很可能不需要二分（

考虑菊花怎么做。

先选能回血的，按$$a$$从小到大选。

然后选扣血的，按$$b$$从大到小选。

第一部分显然，第二部分为什么是对的?

考虑邻项交换，我们把$$(i,j)$$换成$$(j,i)$$之后，前面能打过当且仅当$$x\geq\max(a_i,a_i-b_i+a_j)$$，后面能打过当且仅当$$x\geq\max(a_j,a_j-b_j+a_i)$$。

不妨设$$a_i\leq a_j$$，注意到$$b\leq a$$，也就是$$a_i-b_i\geq 0$$，所以第一个$$\max$$必然是$$a_j$$，第二个是$$a_j+\max(a_i-b_j,0)$$。所以如果$$a_i-b_j\geq 0$$，那么应该选择顺序$$(i,j)$$，否则两个没啥区别。为了让所有$$(j,i)$$都不出现$$a_i-b_j\geq 0$$，我们应该把

不是菊花的话，相当于有若干个 要打一个点，先打父亲 的限制。我们先把所有点排序，选一个最牛逼的，那么可以认为选了这个点的父亲之后，立刻就会选这个点，所以我们把这两个点合并。

怎么合并?$$(a_2,b_2)$$合并到$$(a_1,b_1)$$，此时最大扣血是$$\max(a_1,a_1-b_1+a_2)$$，而加血就是总的减去这个。

-----

Count the Sequences

给$$m,b,c,n$$，求满足

 - $$0\leq x_i\leq b^i-c$$

 - $$\sum x_i<n$$

的长$$m$$的序列$$x$$的个数。$$m\leq 50,2\leq b\leq 10^9,-b+2\leq c\leq b-1,1\leq n\leq b^{m+1}$$，$$n$$可能是高精度数。

据说这是经典容斥（

直接算看起来啥数据结构都维护不了，考虑先搞个好点的形式。

我们对这个上限进行容斥，钦定一些数超过$$b^i-c$$，那么设$$x$$为这些数的$$b^i-c+1$$之和(有$$0$$哦)，随便分配的方案数就可以加入一个辅助变量，然后隔板掉，它是$$\binom{n-1-x+m}{m}$$。设这个为$$f(x)$$。

$$f$$不好办，但是注意到它是$$m$$次多项式，所以考虑把每一项拆开，然后对于$$k=0,...,m$$，计算所有集合中的$$x^k$$之和。注意如果$$x$$实在太大，$$n-1-x+m$$变成了负数，我们也不希望要这个情况，于是我们还要求$$x\leq n-1$$。

考虑枚举集合的大小$$a$$，那么$$\sum\limits_{i\in S}(b^i-c+1)=\sum\limits_{i\in S}b^i-a(c+1)$$，所以我们求出$$n-1-a(c+1)$$的$$b$$进制分解，问题就变成钦定前面若干位相同，后面可以随便选，数位dp即可，转移可以用二项式定理硬冲。

直接做是$$m^5$$的，注意到对于相同的$$k$$，每个$$a$$钦定了前面若干位相同之后，后面随便选的部分是一样的，于是预处理一下就$$O(n^4)$$了。

-----

Dead Cacti Society

XX Open Cup, GP of Korea, Problem E

给一个仙人掌，边有边权，还有一套附加的点权和边权。你需要给每个环断一条边，如果断了边$$u\leftrightarrow v$$，那么会加两个点$$u^\prime,v^\prime$$，从$$u$$连到$$u^\prime$$，$$v$$连到$$v^\prime$$，边权分别是$$u,v$$的附加点权加上断掉的附加边权。最小化得到的树在边权意义下的直径。$$n\leq 10^5,m\leq 1.5\times 10^5$$。

先建个圆方树再说。

考虑一个圆方树dp，你发现我们需要决策留下哪条链。二分答案，然后直接按照类似于ARC088F的方法做即可。

具体一点，我们设$$dp(u)$$表示$$u$$子树满足限制的情况下，留给上面的最长链最短是多长。删掉每条边，得到子树内的直径和最大深度，把直径合法的方案，最大深度取一个$$\min$$即可，可以用各种方法解决。据说精细实现是线性的。

-----

Entanglement

给一个$$n\times m$$的矩阵和常数$$k$$，求有多少对长$$n,m$$，值域都在$$[1,k]$$的序列$$a,b$$，满足矩阵中每个位置$$(i,j)$$，和$$a_i,b_j$$中至少一个相等。$$n,m\leq 300$$。

考虑直接搜，考虑先确定$$a_1$$，如果它不等于第一行的某个数$$j$$，那么$$b_j$$必须是这个数。至于$$a_2$$，如果它不等于第二行的某个数$$j$$，并且$$b_j$$还没确定，那么$$b_j$$必须是这个数，否则要么不合法要么不用管。

考虑怎么求这个东西的复杂度，它是$$T(n,m)=T(n-1,0)+\sum_{x}T(n-1,c(x))+O(nm)$$，其中$$c(x)$$是$$x$$在这一行的出现次数，$$nm$$是我们确定一列之后需要把已经合法的标记上。

我们归纳证明这个复杂度不超过$$n^2m$$。因为$$c$$的总和是$$O(m)$$，所以递归树上每一层$$m$$的总和是不变的，一共有$$n$$层，所以总共就是$$O(n^2m)$$。

-----

Four Elements

XIX Open Cup, GP of C , Problem M

给一些值域区间，求有多少种方式从这些区间里面选出四个数(可重)，使得和为给定的一个$$s$$。$$n\leq 400,s\leq 8\times 10^8,l,r\leq 2\times 10^8$$。

先算不可重的。

给区间求交，然后考虑一个折半，我们先求选两个数的方案数。

问题是怎么求选两个数的方案数，你发现两个数要么在一个区间内，要么在两个区间中，第一种是二次的，第二种还是二次的。问题变成维护一个序列，支持区间加二次函数，最后求它倒过来和自己的点积。

注意到二次函数的和还是二次函数，这个函数最后就是$$n^2$$段，每一段还是二次函数，然后我们就爆力算这个分段函数并倒过来和自己点积即可，二次函数点积二次函数也是可以算的。

然后如果可重，可以爆搜等价类来容斥，不过这里只有四个所以也可以手动讨论。

-----

Accommodataion Plan

XVII Open Cup, GP of Ukraine, Problem A

给一棵树，边权，选$$k$$个半径$$L$$的邻域，求有多少方案使得这些邻域交非空。邻域可以重复，并且有序。$$n,k\leq 10^5,L\leq 10^9$$。

希 望

考虑经典配凑，邻域交是树或者空，树满足$$n-m=1$$，空满足$$n=m=0$$，所以我们算所有方案中邻域交的点数和边数，用点数减去边数即可。这样每个点每条边就都独立了。

现在问题是如何统计一个点出现在多少邻域中，也就是它的邻域中有多少种方案选择$$k$$个点，直接点分治求邻域点数即可。边的话就是两端点的邻域交。复杂度$$O(n\log n)$$。

一个等价的想法是，在邻域交深度最小的点处计算这个邻域交的答案。如果一个点的父亲也在连通块中，那么它就不是邻域交深度最小的点，所以我们要减去它的父边端点都在邻域交中的方案数。

-----

The Jump from Height of Self-importance to Height of IQ Level

给一个序列，支持区间循环移$$k$$位，查询是否有长度为$$3$$的严格上升子序列。$$n,q\leq 1.2\times 10^5$$。

考虑平衡树冲第一个，问题是怎么合并?

考虑Dilworth : 最长反链等于最小链划分。然而这里的偏序关系是二元的，它的反性质不是很好（

考虑Dilworth对偶 : 最长链等于最小反链划分。这个反的性质我们就不管它好不好了（

考虑直接做。我们平衡树每个点维护子树内是否有解，以及最小值，最大值，长度为$$2$$的上升子序列中第一个元素的最大值，第二个元素的最小值。合并的时候，第一个直接合并，第二三个直接合并，第四五个需要递归到另一棵子树查前驱/后继，复杂度是类楼房重建线段树的$$O(\log^2 n)$$。

然后你发现不对劲，这里要查前驱/后继，但是这是序列平衡树/yiw

考虑一个牛逼结论，如果一个区间有解那么别的信息都不重要了，否则假设我们要查左子树最小值在右子树的后继，在这个后继之前右子树可能是任何东西，但是这个后继之后必然是递减的，否则就会构成一个解。所以我们直接在这上面二分即可。

Leafy Tree做这个应该很爽。

-----

Draw in Straight Lines

给一个矩阵，一开始全白，有常数$$a,b,c$$。你每次可以选一行或者一列的一个区间涂黑，假设你选的区间长度是$$l$$，则代价是$$al+b$$；或者选择一个格子涂黑，代价是$$c$$。

如果一个格子被涂了白色，就不能再涂黑了，并且每个格子最多涂两次。给定一个目标状态，求达到目标状态的最小代价。$$n,m\leq 40$$。

看起来很牛逼。

猜一手网络流，1.6e3应该是最大流（

注意到每个格子最多涂两次，而第一次要么是涂黑，要么没有第二次，所以我们可以先考虑所有的涂黑，再考虑所有的涂白，也就是说涂色的顺序不重要了。

你发现一开始就是白色的，所以涂白色只可能是涂了一串黑色，然后把中间一段涂成白色，如果它俩在同一方向，这个就等价于直接涂两段黑色，所以一个格子如果涂黑了，那么一定可以不在同一个方向上变白。

所以如果一个格子是黑色，那么它一定没有被涂白过，它

离谱。

-----

Halting Problem

有一个机器有$$n+1$$个状态，一开始在状态$$1$$，还有一个数$$x$$初始化为$$x_0$$。每个状态有五个参数$$a,b,c,d,e$$，表示如果$$x=a$$，则会给$$x$$加上$$b$$并跳到状态$$c$$，否则会给$$x$$加上$$d$$并跳到状态$$e$$，状态$$n+1$$是终止状态。求这个机器是否会终止，如果终止了会执行多少次操作。$$n\leq 10^5,\vert x_0\vert\leq 10^{13}$$。

先把边都连上再说，这构成了两个内向基环树。你发现每个$$e$$构成的环走一圈会有一个偏移量，如果哪次整的恰好了就可能跳出环走到别的环去。然而即使可以数据结构维护这个跳出去，跳的次数还是可能很大。

等等，它好像不是很大啊（

注意到如果两次跳了同一条$$c$$，那么接下来肯定还会跳，就循环了。所以跳的次数是$$O(n)$$。

现在问题就是怎么数据结构维护下一次会怎么跳了。考虑树上的部分，随便移个项就好了；对于环上，我们移项之后把所有东西都膜一个$$s$$，然后可以得到若干等价类，每个等价类内部就能对上，那么问题就变成查一个等价类中的后继(这样走的最少)，直接set即可，或者离线基排做到线性。

怎么离线?发现每个点查询的$$x$$是确定的，它必然是$$x_0$$或者$$a_i+b_i$$，把这些都问一遍即可。

-----

Cycles

300iq Contest #3

给一个二分图，求简单环个数。

-----

Invariant Tree

给一个排列，求有多少无根树，满足对于每条边$$i\leftrightarrow j$$，也有边$$p_i\leftrightarrow p_j$$。$$n\leq 3\times 10^5$$。

考虑每个置换环，那么如果一个置换环内连了一条边，它就会连一圈最终成环，所以所有的边都在置换环之间。特别的，大小为$$2$$的环是可以连环内的。

然后你发现，两个环之间连一条边，它们也会开始转圈，最后会转出$$\mathrm{lcm}(a,b)$$条边，如果这个数至少是$$a+b$$那就没救了，其中$$a,b$$是两个环的大小。所以我们知道只有$$a\mid b$$的环之间可能连边。

不同的环长只有根号种，可以爆力求出哪些边可以连，现在问题是选择一些组边，和为$$n-1$$且没有成环的方案数。

## Day11

15+95+0+0=110。

-----

A

并查集写挂了/hanx

-----

B

简单题。

-----

C

给$$n,s$$，构造一个长$$n$$的排列$$p$$，使得$$\sum\limits_{i=1}^n i\bmod{p_i}=s$$，或报告无解。$$n\leq 10^6$$。

考虑这个$$\bmod{p_i}$$很奇怪，我们完全看不出它有什么性质。同时注意到$$p$$有$$n!$$种，而$$s$$只能在$$[0,\frac{1}{2}n(n-1)]$$，所以我们随一种构造，它很可能很正确，甚至于在大部分情况下都是正确的，然后多拼几个构造说不定就拼出来了。

首先我们考虑，尽可能不要让这个$$\bmod{p_i}$$产生影响，但是它又不得不产生影响，因为如果全都不产生影响的话那就没啥意思了。

考虑我们选取$$1,...,n$$中的一些数，让它们和为$$s$$，然后把没选的那些$$k$$，让$$p_k=k$$。但是这样剩下的也不好办，我们需要修补一下，让$$p_1=n,p_2=1$$，在$$2,...,n-1$$中选一些数和为$$s-1$$，此时构造方法是显然的，直接每次放选了的中最小的即可。

这个和最小是$$2$$，最大是$$\frac{1}{2}(n+1)(n-2)$$，这个最大值和$$\frac{1}{2}n(n-1)$$只差$$2$$，并且变化看起来很连续。那么现在问题是$$s=2$$以及$$s=\frac{1}{2}(n^2-n-1)$$怎么做了。大家肯定都会吧!

-----

D

给树和$$p,q$$，求长分别为$$p,q$$的不交路径对个数。$$n\leq 10^5$$。

先上 希望 的配凑，现在问题是怎么计算经过一个点/一条边的长为$$k$$的路径数。

考虑差分一波，然后长剖，合并一条路径的时候，我们要给端点和lca都打标记，而批量合并的时候，端点就是一棵子树里一个深度的点，lca就是自己，我们把前者的标记挂到子树根，最后dfs一遍推标记即可。复杂度$$O(n)$$。

草，想到了点分就没继续想长剖/hanx

## Day12

40+0+10+0=50，挂了250/hanx

-----

A

好玩题。给一张图，一开始你在$$a$$，一个杀手在$$b$$，你要到$$t$$，你知道杀手一开始在哪。杀手的速度是$$1$$。请你求出你的最小速度，使得存在一条从$$s$$到$$t$$的路径让你不可能遇到杀手。$$n\leq 10^4,m\leq 5\times 10^5$$。

我们二分答案，然后先从杀手出发跑Dij，然后从你出发跑Dij，如果遇到一个点杀手可以比你先到，那么你不能走这个点，也就是它不能进行转移。

-----

B

简单题。

-----

C

简单题。但是很难写（

遇到推平问题的时候，能线段树就线段树，不要尝试set，因为set维护连续段的话，边界情况多而复杂，并且代码并不美观。

-----

D

奇怪题。

定义一个01串是好的，当且仅当你可以用若干次如下的操作把它变成一个1 : 取前面长奇数的一段，不断把这一段的最后三个字符变成一个字符，变成什么样的字符由函数$$f$$给出，最后剩下一个字符，把这个字符接回前面。

给一个01串，有一些位置是?，再给你函数$$f$$的值，求有多少种方案把?变成01使得串是好的。$$n\leq 10^5$$。

要判定可行性，容易想到一个$$n^2$$的dp，也容易感觉到它可以优化成$$O(n)$$，但是这个dp性质很差，原因是一个串可能有很多种可行的方式。

考虑我们要想让这个可行的方式唯一，考虑构造一个dfa来搞它，然后就可以在dfa上随便dp了。然后你发现这个好像很困难，因为我们也不知道哪个状态更有用（

考虑一个爆力想法，我们不一定要让匹配的状态唯一，因为这个dfa不会非常大，我们可以把匹配的状态全都记下来，也就是说一个点可以有多条相同的转移边。然而还是不会构造（

考虑把这个判定合法的过程改成，开一个栈，每次处理两个字符，你可以选择把它们都push进去，或者push一个，不停做掉栈顶直到只剩一个，然后再push一个。最后栈里剩下一个1就合法。

你发现这个栈里面可能有很多字符，但是实际上只有两个信息有用，也就是加入一个0/1，然后不停操作，会得到什么。

我们建一个有四个点的"dfa"，每个点表示加入一个0/1之后会变成0/1，容易处理转移边。做完了。

## Day13

100+100+100+0=300。飞了/fn

-----

A

智障题。

-----

B

智障题。

-----

C

智障题。

-----

D

这题没啥营养，noip模拟赛出可持久化分块/jy

经典trick : 求trie点数，可以把插进trie的所有串排序，然后减去相邻两项lcp的和，在trie点数很大而串数很少的时候可以用。

经典trick : 两个串的等价类同构，当且仅当它们的last数组相同。

双平衡树二分的常数不知道怎么样啊（

## Day14

72+100+0+0=172。

A挂飞了/ll

-----

A

简单题。

-----

B

无向二分图，Alice和Bob要在图上博弈，一开始从$$s$$出发，轮流移动一步，不能两次走到同一个点，不能动就输了，对每个$$s$$求谁会赢。$$n\leq 5\times 10^4$$。

经典结论 : 如果一个点必然在最大匹配中，那么从它出发先手必胜，否则先手必败。

先跑一遍Dinic，然后从每个不在最大匹配的点出发dfs，尝试把邻接点匹配的点替换出来。

-----

C

简单题。

-----

D

离谱题，noip出个锤子sa?

不过还是挺牛逼的。给一个环形的字符串，把它划分成$$k$$段，最小化最大字典序。$$k\leq n\leq 10^5$$。

结论 : 第一刀一定在最小表示处。然后破环为链，在$$n^2$$个子串中二分答案的排名，用sa或者sam求出这个串。然后怎么check?

考虑做两次，一次求出分成$$\geq k$$段，一次求出分成$$\leq k$$段。

第一个很容易，我们需要尽可能多分，那就能分就分，想了想你发现需要从后往前扫。

第二个也很容易，我们从前往后扫，能不分就不分。

做完了。

## Day15

100+0+0+0=100。

离谱难度。

-----

A

给一个集合，求$$\mathrm{xor}=\mathrm{and}$$的子集个数。$$n\leq 50,v\leq 2^13$$。

结论 : 在$$\mathrm{and}>0$$的情况下，如果集合大小是奇数，那么$$\mathrm{and}$$中是$$1$$的位置，$$\mathrm{xor}$$中必然也是$$1$$。如果集合大小是偶数，那么$$\mathrm{and}$$中是$$1$$的位置，$$\mathrm{xor}$$中必然是$$0$$。

所以我们枚举一个$$\mathrm{and}$$，直接求$$\mathrm{xor}$$是枚举的这个数的方案数，它们可以直接计入答案。对于$$\mathrm{and}=0$$，可能出现实际上有$$\mathrm{and}>0$$的情况，我们容斥一发即可。

使用dp则是$$O(3^{\lg v}n)$$，线性基是$$O(nv\log v)$$。

-----

B

爆力。

每个人都需要一个好的集合幂板子（

呃实际上这题不需要集合幂。问题是给一张图，对于所有的生成子图使得图中最多有一个环，求它们的各连通块大小乘积之和，$$n\leq 16$$。

做法也很直接，枚举环所在的连通块，它必然形成基环树，剩下的就是一个生成森林，而基环树可以集合幂ln或者dp搞掉，或者用一个牛逼做法。什么牛逼做法?

呃考虑我们枚举环，求出它形成一个环的方案数(classic?)，然后缩成一个点跑生成森林即可。所以其实并不需要枚举环所在的连通块（

生成森林连通块大小乘积是经典trick，我们建一个虚点连向每个点，这个图的生成树个数就是原图的生成森林连通块大小乘积之和。总复杂度是$$O(2^nn^3)$$，这不比爆力状压dp牛逼多了!

-----

C

有趣题。给一些操作，每个是下取整除或者取模，再给$$x$$，求有多少种应用操作的顺序，使得操作过后$$x$$变成$$0$$。

考虑到有效的操作不超过$$\log$$次，所以我们可以状压已经选了哪些下取整除，并记录现在$$x$$是多少，然后枚举下一个操作是一个除还是一个比$$x$$小的取模，每次操作之后那些跨过去的取模就可以随便放了，把它们计入方案数。

这个东西看起来是$$v^3$$的，但是实际上每次操作都会让值域折半，所以状态数只有$$O(v)$$，并且常数实在是很小。

-----

D

爆力数据结构，没啥意思。

区间历史和可以表示成一个矩阵标记（

## Day16

100+0+100+0=200。飞了啊/ll

-----

A

简单题。不过有点意思?

你有一个数，一开始是$$x$$，给一个序列$$p$$，如果现在这个数是$$i$$，那么有$$p_i$$的概率变成$$i+1$$，有$$1-p_i$$的概率回到初始值。多次给$$x,y$$，问从$$x$$开始要到达$$y$$期望需要多少步。$$n,q\leq 10^5$$。

注意到从$$i$$到$$i+1$$的每次尝试都是独立的，整体是一个几何分布，所以我们可以直接设$$f(i)$$表示第一次到$$i$$的期望，那么有$$f(i)=\frac{1}{p_{i-1}}f(i-1)+1$$，而$$f(x)=1$$，最后要给答案减去$$1$$，每次查询dp一遍即可。

发现转移是一次函数，所以相当于区间一次函数复合，求前缀复合和复合逆即可。

-----

B

奇怪随机题。给$$s,t$$，你需要在$$s$$中选出一个和$$t$$相同的子序列，使得它的开头和结尾位置差至少是$$k$$，求方案数。$$k<n\leq 10^5,m\leq 50$$，保证串随机，$$n,m$$是什么懂的都懂。

爆力是枚举子序列的第一个位置然后直接dp，复杂度$$O(n^2m)$$。

注意到只有和$$t_1$$相同的字符才可能成为第一个位置，复杂度变成$$O(n^2m/\Sigma)$$。

注意到只有和我们要的字符相同的字符才会产生转移，用vector存每个字符，复杂度变成$$O(n^2m/\Sigma^2)$$，可以通过。

-----

C

奇怪结论 : $$n$$以内和$$n$$互质的数的乘积膜$$n$$是$$\pm 1$$，而它是$$-1$$当且仅当$$n$$有原根。

题意是求这个东西的前缀和，直接分段打表即可。

考虑怎么证明这个结论，不想证，oeis吧（

20以内有原根的数是1,2,3,4,5,6,7,9,10,11,13,14,17,18,19，看到这样的东西可能是原根相关的。

-----

D

两个串，允许插入/删除/替换一个字符，代价相等，求编辑距离并构造方案，如果超过$$k$$则输出NO。这题有两个部分。

第一部分是$$n,m\leq 2\times 10^6,k\leq 10^3$$。

注意到操作每次只会插入/删除一个字符，所以两边匹配的长度差是很小的，所以考虑维度交换。

设$$dp(i,j)$$表示用了$$i$$次操作，现在两边匹配到的长度差是$$j$$，最多匹配到$$s$$的哪里。转移的时候枚举下一步干什么，然后尽可能向后匹配，可以用二分hash求两个串分别一个后缀的lcp支持 尽可能向后匹配。总复杂度是$$O(n+k^2\log n)$$。可以把二分hash换成别的东西来砍$$\log$$。

第二部分是$$n,m\leq 1.5\times 10^4,k\leq 10^6$$，线性空间。主要难度在于线性空间构造方案。

不会/hanx

考虑我们对$$s$$的每个字符求出它最后和$$t$$的哪个位置匹配，也就是从这一对位置把两个串分开，前半段之间的编辑距离加上后半段之间的最小。注意到这个是单调的，考虑分治，然后可以写出爆力dp并滚掉。总复杂度是$$O(n^2)$$。

## Day17

100+100+0+0=200。飞了/ll

-----

A

简单题。

-----

B

简单题。

-----

C

人类智慧题。给一棵树，定义一个覆盖是说选取若干链(可以相同)使得树上每条边被经过两次，设其中有$$k$$对链是相同的，那么这个覆盖的权值是$$2^{-k}$$。求所有覆盖的权值和。两个覆盖不同，当且仅当存在一条链出现次数不同。

考虑覆盖在一个结点局部地来看，就是把它的每条邻边拆成两条，然后把这些边匹配起来，当然也可以留一些单着的。我们直接把这些东西全乘起来，然后你发现这样会算重，因为我们把每条边分成了两条，所以会给每个方案算$$2^{n-1}$$次。然后你发现如果出现了一对相同的链，那么这两条链所选的边就是相反的，于是把两条链都反过来(选和原来不同的那条边)，得到的匹配是一样的，所以如果有$$k$$对相同的链，只会算重$$2^{n-1-k}$$次。

现在问题是怎么算配对方案。你发现两个度数相同的点是没有区别的，然后可以考虑dp，设$$dp(i)$$表示这个点有$$i$$条邻边，拆一拆然后匹配的方案数。转移考虑第$$i$$条拆成的两条分别是单着还是和前面的某条边匹配，此时可能会钦定出一个或者两个被匹配了一次的邻边，注意到我们可以转移的时候先处理这些匹配了一次的邻边，这可以保持这样的边不超过两条，于是多记一个$$0/1/2$$就做完了。

-----

D

平面上有一些点，它们的横纵坐标都构成排列。你可以选择一连串矩形，满足每一个的右上角的右上方是下一个的左下角，然后对于每个矩形获得里面点的点权之和。对每个位置求出以这个位置作为矩形串的右上角，最大可以获得多少权值。$$n\leq 4000$$，10s。

转移是

$$
dp(i,j)=s_{i,j}+\max_{k<i,l<j}(dp(k,l)+s_{k,l}-s_{i,l}-s_{k,j})
$$

有两个形如$$s_{a,c}$$的交叉项，考虑决策单调性或者分治。

注意到如果固定$$i,k$$，它的含义是从一列转移到另一列，此时维护$$l$$上的前缀$$\max$$即可。考虑依次处理每一列到后面的转移，这就是$$O(n^3)$$的。

考虑分治，我们处理了左边的列之后，批量转移到右边的列。这每次需要$$O(n^2)$$的时间。所以就做完了?

呃实际上没有。这不止需要$$O(n^2)$$，因为我们现在不是固定两列了。想一想你发现我们需要用线段树维护，于是单次转移复杂度是$$O(n^2\log n)$$。

直接做是$$O(n^2\log^2 n)$$。如果每次选取长边切开，并只在扫到点的时候进行修改，那么一共有$$n^2\log n$$次单点查询和$$n^2$$次后缀修改，查询可以遍历线段树做到线性，修改直接做，复杂度居然是$$O(n^2\log n)$$。