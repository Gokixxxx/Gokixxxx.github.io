---
layout: post
title: zroi noip18联测
subtitle: 蔡老板赚大钱
tags: 课
---

以及两天的杂题选讲（

## Day1

杂题选讲。

-----

CF1427E Xum

牛逼题/jy

直接想法是，随$$10^3$$个倍数插入线性基，但是这个好像不太行。

更随的想法是，直接随$$10^5$$次操作插入线性基，这个好像很可以。

简单做法是，考虑每次消去最高位，于是设$$x$$的位数是$$k$$，你就考虑把$$x$$左移$$k-1$$位使得它的最低位和$$x$$的最高位对齐，记为$$t$$，那么$$y=x\operatorname{xor}t$$就消去了$$x$$的最高位。此时我们把这个数以$$x$$的最高位分成两部分，高一半就是$$t-1$$，而低一半是$$x$$除去最高位。

然后我们给$$y$$再加上$$t$$，低一半不变，高一半变成$$2t-1$$。注意到$$2t$$的$$\mathrm{lowbit}$$必然是$$2$$(忽略后面一车$$0$$)，于是这里必然在$$2$$上造成退位，于是它的$$2$$这一位变成$$0$$而$$1$$这一位变成$$1$$。

考虑$$2t$$，我们计算$$(x+2t)\operatorname{xor}(y+t)$$，$$x+2t$$在$$k,k+1$$位上是$$1,1$$，而$$y+t$$是$$1,0$$。我们得到了一个$$2^{k+1}$$，但是本来打算要$$2^k$$来着¿

没有关系，我们可以用这个把$$t$$中$$>k$$位的$$1$$全都干掉，就得到了$$2^k$$。做完了。

惊悚做法是，考虑裴蜀定理。

发现$$x\operatorname{xor}t$$必然和$$x$$互质，因为$$x\operatorname{xor}t+2^k$$是$$x$$的倍数，而$$2^k$$不是。

所以我们exgcd解出一组$$a,b$$使得$$ax+by=1$$，现在问题是$$a,b$$可能有负数，正数直接做就完了。

考虑钦定$$b$$是负的，那么直接给$$b$$取负，问题变成实现减法。注意到$$ax,by$$是相邻的，于是如果是奇数减偶数就可以直接$$\mathrm{xor}$$，如果是偶数减奇数那我们就都加上$$x$$，就变成奇数减偶数了。

-----

CF1340D Nastya and Time Machine

classic/jy

收录于 CF思维题选胡。

-----

CF1442D Sum

classic/jy

收录于 CF再选做。

-----

CF1446C Xor Tree

建立trie，设$$dp(u)$$表示$$u$$子树最多保留几个点。发现只选一棵子树一定是可以的，如果选了两棵子树，那么其中一棵一定只有一个点，超过一个则会自己连自己，两边就不连通了。

-----

CF1439B Graph Subset Problem

classic/jy

收录于 CF思维题选胡。

-----

洛谷P4007 小Y和恐怖的奴隶主

看起来就直接设$$dp(i,a,b,c)$$表示打了$$i$$下，有$$a,b,c$$个$$1,2,3$$血量的随从概率，$$f(i)$$表示打boss次数的期望，转移是线性变换，状态数大概不到$$500$$，矩阵快速幂即可。多测就预处理幂，矩阵乘向量。

实际上据说状态数是$$166$$(包括$$f$$)/jy

-----

HDU6145 Arithmetic of Bomb II

看起来很有儒略日内味。

考虑我们把每个bomb表达式标准化成左闭右开，也就是左边是数字，右边是运算符。

如果一个bomb表达式两边都是符号，那它就完了。如果两边都是数字，我们可以拆出第一段和最后一段，把中间搞成左闭右开。

然后就可以考虑，如果最后一个是加号那就简简单单；如果最后一个是乘号，如果全是乘号那就直接做，否则就把最前和最后一项拼起来，还是特判开头结尾。做完了。

然后听说是矩阵快速幂/jy

考虑一个牛逼做法，我们维护三元组$$a+bc$$，那么加入一个数字和三种符号都是线性变换，做完了。

-----

Gym100543L Outer space invaders

离离原上谱，区间dp。

考虑设$$dp(i,j)$$表示干掉左右端点都在$$[l,r]$$的敌人的最小代价，那么最远的那个一定要为它开一炮，于是我们可以枚举什么时刻把它干了，就分成两段了。

这还是一个扫描线方向的问题，这个做法就是按距离从上到下扫描线。所以还是不要一上来就咬定自己的扫描线方向。

-----

Gym101480E Export Estimate

扫描线。

注意到所有二度点都会被删掉，会减少一条边。

然后考虑自环不会被删。

并查集维护即可。

-----

Gym101620J Justified Jungle

$$k+1$$必然是$$n$$的因数，所以就枚举一个大力模拟即可。

然后你发现砍了一个点的父边，当且仅当它的子树大小是$$\frac{n}{k+1}$$的倍数，于是做完了。想不到吧，狄利克雷前缀和一下，这是$$O(n\log\log n)$$的/jy

------

Gym101620L Lunar Landscape

垂直于屏幕向外扫描线（

坐标极小，我们直接算每个格子被覆盖多少次(斜边上是0.5次)，两类分别差分-前缀和即可。

哦注意到斜边有四类，所以我们需要给每一类斜边都开一个差分-前缀和，所以是六个/jy

-----

AGC052B Tree Edges XOR

随便找一个点作为根，求一个树上前缀和，那么边权就变成了点权的$$\mathrm{xor}$$。

考虑此时一个操作的效果，发现它就是交换端点的点权。

所以我们直接判断两个集合是否相等，然后就wa飞了。

考虑这个找一个根，相当于钦定了一个点点权是$$0$$，但是后面这个点权可能换走了。所以我们需要枚举那个点权换到哪里去了，或者枚举它可能还被钦定成了什么(这个数一定可以是某个$$d$$)，这就$$n^2$$了。

注意到$$n$$是奇数，所以我们给所有数都$$\mathrm{xor}$$上全局$$\mathrm{xor}$$和，就相当于把它们标准化了，判断是否同构即可。

另一个直接且爆力的想法是，我们直接找到一组点权$$f$$，使得一条边的权值是端点权值的$$\mathrm{xor}$$。为了保证唯一性，由于$$n$$是奇数，我们可以限制总$$\mathrm{xor}$$和是$$0$$。直接分配，然后给每个数$$\mathrm{xor}$$上总$$\mathrm{xor}$$和，判断是否同构即可。

-----

COCI2018-2019 TENIS

有三项属性，一个人可能打败另一个人当且仅当有一维排名更靠前，现在要进行淘汰赛，你每次可以选两个人比赛，支持交换两个人的排名，查询一个人是否可能登顶。$$n,q\leq 10^5$$。

考虑每个人在每个维度上向他可以打败的人连边，然后得到三个竞赛图，缩SCC之后还是形成一条链，第一个SCC就是可能赢的人。问题变成找第一个SCC，这等价于找第一个前缀使得三个排列中这个前缀都是SCC并且重排同构，而你发现一个排列中每个前缀都是SCC，因为这是完全可比并且传递的。所以就是找一个前缀使得三个序列的这个前缀同构。

hash看起来并不可行。

考虑找到每个数第一次出现和最后一次出现，那么这条线就不能被这两次出现跨过，每个数相当于一个区间加，要找第一个$$0$$，线段树即可。

-----

洛谷P5307 COCI2018-2019 Mobitel

离离原上谱。考虑设$$dp(i,j,k)$$表示走到$$i,j$$，再乘一个$$k$$就能超过$$n$$，而$$k$$只有根号种，所以就做完了。

-----

洛谷P7207 COCI2019-2020#3 Sob

¿

考虑法嘛塔优化建图，然后Dinic硬上，有没有可能做完了¿

考虑$$A$$中最大的数$$x$$和哪个匹配，我们爆力找出这个数$$y$$，那么$$x-1,y-1$$也能匹配。然后就做完了。

听起来很奇怪，这是为什么呢?优质解答 : 我不知道

-----

COCI2019-2020 Pastiri

树，有$$k$$个关键点，你要放一些守卫，每个守卫可以守住最近的关键点，如果有多个那么都可以守住，求最少需要多少守卫，构造方案。$$n\leq 5\times 10^5$$。

考虑随便选一个根，然后考虑所有深度最深的关键点，我们一定需要一个守卫去守它，但是它实在是很深所以我们希望这个守卫尽量靠上，所以我们要找到所有能守住这个点的点中最浅的。

然后我们就删掉所有影响了复杂度的点。一开始预处理每个点可以守住哪些关键点，可以多源bfs。

-----

COCI2019-2020 Semafor

有最多两个五段显示器，每个可以显示$$0,...,9$$，接下来你要操作$$n$$次，每$$k$$次之后要求每个显示器显示的都是合法数字，问最后显示出来每个数的方案数。$$n\leq 10^{15}$$。

考虑爆力矩阵快速幂，做完了。

吗?你发现要求每$$k$$个的转移矩阵，复杂度比较高，因为状态数是$$2^{5+5}=1024$$。每$$k$$个之间状态数是$$100$$。

考虑一段之内，两个显示器是独立的，所以我们可以分别算，最后卷起来。这个还是不行。

注意到方案数只跟有多少位变化了有关，所以我们可以直接记录现在需要变$$i$$位的方案数，然后这个也可以矩阵快速幂。这个矩阵大小就只有$$11$$。

-----

AGC043B 123 Triangle

差分还取绝对值，离离原上谱。不过可以注意到这个操作对两个操作数是对称的。

考虑答案只可能是$$0,1,2$$。

考虑如果有$$1$$，那么最后$$1$$会把$$2$$吃掉，于是答案只可能是$$0,1$$。否则，答案就是$$0,2$$。

然后你发现操作变成了$$\mathrm{xor}$$，于是用组合数算出每个数贡献多少次即可。膜$$2$$难以处理逆元，可以使用Lucas定理。

-----

AGC044B Joker

爆力01bfs就是$$n^4$$。如何优化?

不要优化。考虑每个人被算入多少次，那么我们就算他在每个时间走出去的最短路，然后算他到每个人的最短路，还是$$n^4$$。

做法足够厉害。考虑先直接往一个方向冲作为最短路，这样最短路的和是$$O(n^3)$$的，然后用spfa的方法爆力更新，每次更新都会减少总和，所以总次数就是$$O(n^3)$$。

-----

AGC045B 01 Unbalanced

把$$0$$变成$$-1$$，问题变成最小化前缀和的极差。

枚举最大值，然后我们能填$$1$$就填$$1$$，这样会让最小前缀和尽可能小。复杂度是$$O(n^2)$$。

结论是，把所有$$?$$当成$$-1$$，然后求最大前缀和$$s$$，那么只需要检查$$s$$和$$s+1$$。因为有一个$$-1$$变成了$$1$$的话，如果最小前缀和在此之前它不会变，否则它也只能变大$$2$$，因此一定不更优。

-----

AGC045C Range Set

考虑怎么判断一个串是否可行。时间倒流，变成你可以把连续$$a$$个$$0$$或者$$b$$个$$1$$变成任意串。

不妨设$$a>b$$，于是如果有连续$$a$$个$$0$$就一定可行，否则考虑如果有连续$$b$$个$$1$$，那么我们把它全变成$$0$$，然后剩下了连续$$a$$个$$0$$就可行。

考虑dp，设$$dp(i,j,0/1)$$表示填了$$i$$位，换完$$1$$连续段之后最后有连续$$j$$个$$0$$，这一位是$$0/1$$的方案数。

 - 如果在填黑色，我们枚举上一个白色的位置，可以前缀和优化

 - 如果在填白色，我们枚举上一个黑色的位置，还是可以前缀和优化

然后就做完了。复杂度是$$O(n^2)$$。

-----

CF1458C Latin Square

足够厉害。收录于 CF再选做。

-----

CF1361E James and the Chase

看到占比，考虑随机化，我们随$$100$$次，然后判断一个点是不是好点。

考虑如果找到了一个好点，怎么才能找到所有好点。建立dfs树，那么因为根是好点，不可能有横向边，于是好点的子树内只有恰好一条返祖边，并且这条边连向另一个好点。复杂度$$O(kn)$$，$$k$$是常数$$100$$。

哦，考虑怎么找好点，那就是有横向边就不是好点，否则就是好点。

-----

CF1444D Rectangular Polyline

先判掉$$h\neq v$$，然后背包背一个一半。

考虑直接构造，我们已经分成了两半，每一半让横着的从小到大排，竖着的从大到小排，这样就可以尽可能远离了。

容易证明这样做一定不会越过对角线，于是不会在顶点之外的地方相交。

## Day2

挂分王/cy

挂了85/cy

40+25+0+100=165，垫底了。

-----

A

给$$p,(a,b),(c,d)$$，每次可以变成$$(2a,b-a)$$或者$$(a-b,2b)$$然后膜$$p$$，求多少次之后变成$$(c,d)$$。$$T\leq 10^5,a,b,c,d\leq 10^9$$。

打表可以发现系数的规律。设最后变成$$(ax-by,bz-aw)$$，操作了$$k$$次，那么$$x+y=z+w=2^k,x+z=2^k-1,y+w=2^k+1$$，这样就可以消去$$y,z,w$$。直接代入解出$$x,y,z,w$$，然后判断是否合法即可，注意需要满足$$1\leq x\leq 2^k$$。

-----

B

给一个序列，你可以删去不超过$$25$$个数，然后把剩下的数划分成两部分，要求两部分的和相同。$$n,a_i\leq 2\times 10^5$$，保证数据随机。

小数据爆力，大数据随机。

一个策略是，先贪心地取使得两部分的差不超过2e5，留下最后$$25$$个元素进行调整。

另一个策略是，猜测其中一个取一个区间可行，多次随机删掉哪些，然后双指针检查。

随机题还是要坚定地认为乱搞能过的/hanx

-----

这题[有一个牛逼版本](https://www.luogu.com.cn/problem/P7703)是说，给一个序列，可以任选两个非空子集，让它们的和相等，值域达到1e18，还是随机生成的。

考虑我们排序之后把相邻两项合并，也就是用大的减去小的。这个操作会把每个位置的期望除一个$$n$$，并把$$n$$减半，$$n=5000$$时七次就可以把期望值减小到$$0.0268$$左右，也就是说每个数期望都会非常接近$$0$$，于是很大概率出现一个$$0$$。用链表维护每个数从哪里来，再搞上基排，复杂度是$$O(n)$$，当然这里认为$$v=n^{O(1)}$$。

看起来这个做法最多进行$$\lg n$$轮，此时$$v$$变成了$$\frac{v}{n^{\frac{\lg n-1}{2}}}$$，令它为$$O(1)$$则得到$$v=O(n^{\frac{\lg n-1}{2}})$$，这个已经超过了我们一般认为的$$v=n^{O(1)}$$。我不知道应该如何扩展这个方法使它能支持更大的$$v$$。

这个题应该成为 传世经典。

-----

C

给一棵树，有未知任意点权，你可以知道每个大小$$>k$$的子树除去根的点权和，也可以知道每个儿子个数$$\geq k$$的点的儿子点权和。现在你可以进行若干次操作，每次删掉一个叶子，删完之后你会得到这些点权和，求最多可以利用这些信息确定多少个点的点权。$$n\leq 10^5$$。

注意到一个点有兄弟，它就不可能被问出来，因为任何一次询问它们都同时出现。所以只有独子能被求出来。

现在对于每个独子，如果它的子树大小$$>k$$，那么可以用它的父亲的子树和减去它的子树和。

如果它的子树大小$$\leq k$$，它子树里的点就都不能确定了。一个特例是，如果它的子树大小是$$1$$，那么它说不定可以搞出来，方式是用爷爷的子树减去爷爷的所有儿子，再减去爷爷的所有其它子树。

所以一个点可以求出来，当且仅当

 - 是独子

 - 满足以下两个条件之一 : 

    - 子树大小$$>k$$

    - 是叶子，爷爷儿子个数$$\geq k$$，叔叔们要么子树大小$$>k$$，要么是叶子

然后呢?考虑一个dp，设$$dp(u,i)$$表示$$u$$子树保留$$i$$个点的答案。呃你发现其实没必要记$$i$$，因为叶子的$$dp$$值是$$0$$，所以$$dp$$
非$$0$$的点子树大小一定$$>k$$。

所以考虑转移。对于每个子树，如果它大小$$>k$$，那么可以只选这个子树。

如果要选一个叶子呢?首先需要保留$$k$$个儿子，然后你发现如果一个点$$dp$$值是$$0$$，不如直接把它删成叶子，否则就留下它。所以方法是留下一个只有一个叶子作为独子的儿子(有可能本来就是，也有可能是删一个$$dp$$值尽可能小的子树，这里只有删$$dp$$值为$$0$$的才有用)，然后把其它儿子加起来(有值的一定足够大，值为$$0$$的可以删成叶子)。

当然也可以什么都不做，这样就是把所有儿子的值加起来。

-----

D

签到题。

## Day3

简单题，但是C智障了，没能一眼看出来/cy

100+100+0+25=225。

-----

A

爆搜，签到题。

-----

B

法嘛塔求最大and/or，板子题。

-----

C

给一棵树，一开始有两个黑点，然后你每次可以把每个黑点旁边的一个黑点染黑(也可以不染)，注意每次操作是对每个黑点都做一次，问最少多少次可以把整棵树染黑。$$n\leq 10^5$$。

考虑如果只有一个黑点，直接dp，把儿子们按照$$dp$$值从大到小染黑就行了。

如果有两个，那么中间一定会在某个地方相撞，然后分成两部分。容易猜到单峰，三分这个点即可，不过可能会出现平的一段，此时可以向两侧倍增找到段的开头结尾。

更好的方法是二分，尽可能让两边的操作次数相同。

更好的方法是直接顺着，倒着分别扫一遍，然后枚举中点，瓶颈在于排序，可以vEB做到$$\log\log$$，但是更低我就不会了。

-----

D

码力题，没什么营养。

## Day4

100+100+100+0=300。奇怪。

-----

A

模板 法嘛塔，签到题。我多个$$n$$直接冲过了。

-----

B

模板 莫反，签到题。

-----

C

有趣题。有$$n$$个人排成一排要比赛，每次你选择**相邻**两个人比一比，输了的就溜了，现在给你任意两个人之间的胜负情况，求有多少人可以赢得最后的胜利。$$n\leq 2000$$。

考虑一个爆力dp，设$$dp(l,r,i)$$表示$$i$$能不能成为区间$$l,...,r$$的胜者，转移就枚举一个划分，看$$i$$是从哪边上来的，另一边就需要是一个$$i$$可以打败的人，可以用bitset优化做到$$O(n^5/w)$$。

考虑优化，你发现一个结论是，让$$i$$只打两场，一次干掉他左边的胜者，一次干掉他右边的胜者，这么做一定不劣。于是可以省去枚举划分，复杂度变为$$n^4/w$$。

你发现枚举一个$$i$$之后，我们要做的bitset操作就是把左半边和$$i$$能打败的人and起来，右半边也和$$i$$能打败的人and起来，然后看两边是否都有$$1$$。

你发现一个区间的$$dp$$值只会和左/右端点and起来，于是我们就能将这个and的次数降为$$n^2$$，此时转移复杂度从$$O(n/w)$$降为$$O(1)$$，一共是$$O(n^3)$$。

看一眼你就发现还可以用bitset批量转移，于是变成了$$O(n^3/w)$$。做完了。

空间很大，~~zroj忍一下~~ 需要滚。

-----

D

神题。给一张图，从每个点走到$$s$$，有一条未知边断了，只有你走到旁边才会发现它断了。求最优方案中，最坏情况下每个点到$$s$$的路程。$$n\leq 10^6,m\leq 2\times 10^6,w_i\leq 10^9$$。

考虑一定是你想走一条路径，然后这个路径冲到一半发现边断了，那就完蛋了，你只能走新的最短路。注意你一开始想走的这条路径不一定是最短路，因为从最短路中退出来可能会有巨大的花费。

我们把路径分成两段，一段是从起点$$u$$到发现边断了的时候所在的点$$v$$，一段是从$$v$$到$$s$$。容易想到先求后一段。

考虑如果我们断的不是$$v$$在最短路树上的父边，那么这条边断的毫无意义，本来要走最短路，结果现在最短路没有变。所以我们求出$$f(v)$$表示断掉$$v$$在最短路树上的父边之后$$v$$到$$s$$的最短路。

先假设我们算出来了这个东西，那么接下来我们考虑一条路径最优，当且仅当在路径上每一个点处断开，得到代价的最大值最小。考虑设$$dp(u)$$表示$$u$$出发的答案，那么有转移

$$
dp(u)=\min_{e=u\leftrightarrow v}\max(f(u),dp(v)+w(e))
$$

，这个看起来有点像最短路，直接猜测可以使用Dij求解即可，实际上这个完全就是一个最短路，只不过你在确定了一个点的最短路之后才能确定它邻边的边权。

现在问题是怎么算各$$f$$。

根据k短路的经典结论，断了一条边之后，只可能走一条非树边。所以每条非树边相当于是给它端点之间的树链加上了一个换边的选择，并且形式很简单，我们直接用树剖维护这个东西，就可以做到一个$$\log$$。时限极高(7s)，可以过掉。

更好的方法是排序之后变成在链上找到所有$$0$$并推平成$$1$$，可以用并查集维护，使用基排则瓶颈在Dij，可以用线性最短路来优化到线性/jy

## Day5(10.18)

100+100+3+0。C写麻了。

-----

A

签到题。

-----

B

签到题。

-----

C

签到题。基环树找环请用toposort。

-----

D

给一个图，求DAG生成子图个数。$$n\leq 18$$。

这是一道传世经典 清华集训2014 主旋律 的一个部分，而这个题收录于 子集反演。

## Day6

100+15+0+0=115。

非常牛逼。

-----

A

签到题。还是一个扫描线方向的问题。

-----

B

好玩题。给一张图，给边染成黑白，要求每个点的邻边中两种颜色的个数差不超过$$1$$。$$n,m\leq 10^6$$。

结论是，如果一个连通块所有点的度数都是偶数，但是有奇数条边，那么必然无解，否则可以直接跑 Mike and Fish 的欧拉回路，也就是在欧拉回路上交替染两种颜色。

为什么这就无解了?小朋友想一想，因为所有点度数都是偶数，那么每个点的两种颜色邻边数差必然是$$0$$，所以我们知道两种颜色的边数应该是相等的，所以总边数不应该是奇数。

为什么除此之外一定有解?加入虚点之后，所有点度数都是偶数，如果有奇数条边，我们从$$0$$开始跑会导致$$0$$的差是$$\pm 2$$，不过反正我们要把它删掉。如果有偶数条边则更简单。

-----

C

好玩题。给一棵树，点权，求每个点的 子树和到根路径的并 的补的线性基。$$n\leq 4\times 10^5,v<2^{61}$$。

考虑这个东西是什么，你发现我们dfs这棵树，在离开一个点的时候把它加入线性基。反着再dfs这棵树，在离开一个点的时候把它加入线性基。分别记录这两个东西，那么一个点的答案就可以用dfs到它时的两个线性基合并出来。

然后注意到一个很好玩的事情，这样dfs只有插入，而只插入得到的线性基只有$$\log v$$种，所以我们求出所有线性基，预处理它们两两的合并即可。总复杂度是$$O(n\log v+\log^4 v)$$。

有一个牛逼题是Ynoi2008 stcm，不过那个远强于这个。主要还是线性基不撤销的话信息变化总量只有$$\log v$$。

-----

D

好玩题。给一张图，一开始是空的，每次从一个区间每个点到另一个区间每个点连边，然后去掉所有重边和自环。求有多少种方式选择一些没有出现的边加入图中，使得每个点度数都是偶数。$$n\leq 10^5$$。

加边是矩形or，可以用扫描线线段树搞定，具体一点就是看成矩形$$+1$$，那么没有边就是$$0$$，而不会出现负的，所以可以线段树维护最小值及其个数。

把度数数组和边对度数的改变都看成向量。

考虑补图，每个连通块是独立的，而连通块内存在生成树，生成树是$$n-1$$维的，而度数也是$$n-1$$维的(有一维是没有用的，因为度数和必然是偶数)，所以不管别的边怎么选，都有唯一的方案操纵生成树使得最后得到全$$0$$。答案就是$$2^{c-(n-k)}$$，其中$$c$$是还剩的边数，$$k$$是连通块个数。

现在问题是怎么求连通块个数。简单想法是bitset爆力$$O(n^2/w)$$，大概冲不过去。

边数很大，查询方法只有扫描线线段树，于是考虑Boruvka~~别乳卡~~一类的算法。我们线段树每个点存所在连通块编号最小和最大的$$0$$，扫描线扫过去即可，这看起来真的很像 新年的繁荣 的Boruvka+法嘛塔做法。仍然一共需要跑$$\log$$轮，总复杂度$$O(n\log^2 n)$$。

看起来不是很能写。

## Day7

100+60+60+0=220。

-----

A

签到题。

-----

B

大原题 CF741C。

数组开小/cy

-----

C

简单dp题。dp优化一定要考虑清楚，写的时候要按照思考过程来写，不要追求小常数而导致混乱。

被卡常了/ll

滚动数组很有用。

-----

D

奇怪题。平面，你要从极左走到极右，你的方向是向右上或者右下$$45$$度，你可以在任意实数时刻改变方向。有$$n$$条竖线作为障碍，你不能碰到上面去(包括端点)，求有多少面积是你不能走的(走不进去，或者走了就不能到达对面的)。$$n,v\leq 10^5$$。

偷点题解的图。

直觉是直接做矩形并，但是你发现不行，因为两条线段可能相互影响，比如有的点可以躲开其中任意一条线段，但是躲开了这一条就会撞上另一条，那么这个点也是不能走的。

考虑一开始给每条线段画一个斜的正方形，那么如果两个正方形有交，就需要把它们左右缺的角也补上，但是如果是上下缺角则不补。

![img](/img/2021-10-11-zroi-noip/day7-d-1.png)

考虑先补左边的。我们把每个矩形取左半边，得到一个三角形，然后扫描线扫过去，用set维护它们下面直角边的顺序(具体一点就是按$$x+y$$排序)。加入一个三角形的时候，下面和它相交的三角形只可能是下面第一个，上面和它相交的三角形可以爆力查出，这些会相互影响，整体的作用效果就是合并成了一个大三角形。每次合并都会减少一个三角形，所以复杂度是一个$$\log$$。

![img](/img/2021-10-11-zroi-noip/day7-d-2.png)

两边都做一遍，然后现在问题变成有若干三角形，有朝左的有朝右的，求并的面积。这个看起来很难做，不过注意到一个三角形不能走，它另一边对称的也不能走，所以可以补成正方形，转一转扫描线即可。总复杂度一个$$\log$$。

## Day8

100+80+100+50=330。送分场。

-----

A

简单题。

-----

B

诈骗题。

给一棵树，求所有长$$k$$的路径的逆序对数之和。

注意到路径反过来还是路径，所以每一对都会被算两次，所以逆序对是假的，问题变成了求长$$k$$的路径数，长剖即可。

-----

C

简单题。

-----

D

看起来还挺厉害。

给一个01串，要进行$$k$$轮操作，每次从左往右扫一遍，遇到01就会标记，扫完将每个被标记的01换成10。$$n,k\leq 10^6$$。

考虑这个过程相当于每个0都在往后冲，每次最多冲一格。

考虑一个非常牛逼的递推，我们从右往左处理每个0，然后用某种数据结构维护每个时刻它的位置。你发现最后一个0的位置肯定是一直往后冲直到撞墙。

我们考虑如果已经知道了上一个0的位置，那么这个0至少要跟在上个0后面，所以我们先把它的位置全都往左一位，时间全都往后一位。然后这个0不一定是一直跟在上个0后面，它可能会一开始在很左边，然后慢慢追上来了，所以我们需要再画一条冲过去的线，然后把下面那一段截掉。这里还是偷个题解图。

![img](/img/2021-10-11-zroi-noip/day8-d.png)

把竖着走一步记为0，斜着记为1，用队列维护即可。

这题有点眼熟¿

呃，遇到 会被什么东西挡住，并且只会被一个东西挡住，那么就从那个递推过来就好了。刺激¿

## Day9(10.25)

100+0+0+0=100。这就是noip模拟赛吗?

-----

A

简单题。

-----

B

奇怪题。

给$$n$$个三维向量，求线性无关的无序三元组个数。$$n\leq 2500$$。

考虑三个向量线性无关，等价于它们两两张成的面不同，所以我们枚举两个，把它们张成的面扔进map，然后统计答案即可。

一个爆力做法是转成直线数点然后直接扫描线，复杂度是一样的，但是这个需要实现分数所以极度麻烦。

-----

C

简单题。但是为什么这么难写/fn

给一棵树，定义一个连通块的权值为点权的积，对每个点求所有包含它且大小不超过$$k$$的连通块的权值和。$$n\leq 3000$$。

直接做，发现dp可以写成生成函数卷积，于是我们带一车点值扔进去，dp过程是$$O(n^2)$$了，现在问题是插值还原太慢了。

注意到只需要求前$$k$$项系数和，仔细观察拉插的式子，发现这个系数可以$$O(n^2)$$预处理，于是就做完了。

-----

D

noip模拟赛，出个锤子SAM/fn

给一个串的序列，你需要从每个串选一个子串，然后把它们按顺序拼起来，求最后可以得到多少不同的串，这里两个串是否相同只看内容而不看来源。$$\sum\vert s\vert\leq 10^5$$。

## Day10

杂题选讲。

主题是经典题。

-----

Ternary String Counting

Comet OJ #12

ARC074E($$n$$个球的序列，染成RGB，若干限制，每个限制一个区间颜色数，求方案数)，加强到n5e3 m1e6。

容易写出一个dp，设$$dp(i,j,k)$$表示$$i$$染成某个颜色，上一个下一个颜色出现在$$j$$，上一个下下个颜色出现在$$k$$，转移枚举下一位填什么来刷表的话，看起来是

$$dp(i,j,k)\rightarrow dp(i+1,j,k),dp(i+1,k,i),dp(i+1,i,j)$$

。考虑这个转移的结构，第一种转移就是直接copy，第二种是把每一行$$k$$的和加到$$(k,i)$$上，第三种是把每一列$$j$$的和加到$$(i,j)$$上。

考虑如果没有限制，那么我们只需要知道每一行和每一列的和，所以我们只需要维护每一行和每一列的和就好了，这样就优化到$$O(n^2)$$。

考虑有限制的话，每个限制相当于把一个矩形之外的位置全部清空，注意到每个位置被清空之后就一直是$$0$$了，所以可以爆力找没被清过的位置。

-----

Graph Subpaths

给一个DAG和上面的若干条链，求有多少链不包含给定的任何一条链。$$n,m,\sum len\leq 10^5$$。

建一个ACAM(而不是trie图，这里字符集很大)，现在问题是我们需要同时在DAG和ACAM上走，需要同时记录两个点，复杂度就飞了。

考虑了各种想法，发现没有啥用，于是我们大力猜测状态数极少。

考虑一个状态$$(u,v)$$合法，其中$$u$$是DAG上的点，$$v$$是ACAM上的点，当且仅当$$v$$是根，或者$$v$$在trie上父边上的字符是$$u$$。所以trie上每条边只会贡献一个状态。

现在问题是转移复杂度过高，因为这是一个DAG，跳fail次数可以被卡满。需要支持查询一个点在fail树上到根链上第一个存在某个转移的点，这个直接拿可持久化线段树冲trie图就能做。

不过我们有更简单的做法，直接对每个字符的转移把dfs序拿出来二分找就行了。

还有更更简单的做法，不过看起来好牛逼，完全不会（

-----

Tree Equation

CCPC2017 秦皇岛 J

定义两棵有根树的加法是把它们的根摁在一起，乘法是把后面那棵树代入前面那棵树的每个点。

给三棵树$$a,b,c$$，求两棵树$$x,y$$使得$$ax+by=c$$。$$n\leq 10^5$$。

注意到和的点数等于点数的和$$-1$$，积的点数等于点数的积，所以我们可能可以知道点数?好像不能。

考虑最大深度。你发现积的最大深度等于最大深度的和，和的最大深度等于最大深度的$$\max$$。

考虑$$c$$中的最大深度是哪边贡献的，如果是$$ax$$贡献的，那么我们就可以从这个最深的点向上跳$$x$$的深度，这个深度就是$$c$$的最大深度减去$$a$$的最大深度，此时的子树就是$$x$$，然后模拟即可。如果是$$by$$贡献的，也check一下就好了。

AHU冲啊，正确性非常正确，复杂度可以线性。

-----

Wind of Change

XX Open Cup, GP of Korea, Problem K

两棵树，边权，求一对不同的点，最小化它们在两棵树上的距离和。$$n\leq 2.5\times 10^5$$。

在第一棵树上点分治，每个分治块把dis拆成两个深度的和。现在问题变成在第二棵树上，每个点有点权，求点权+距离意义下的最近点对。

注意到这里是$$\min$$，所以不需要考虑是否在同一棵子树。

虚树冲啊，然后就结束了。简单dp即可。

要做到1$$\log$$，st表lca，排序的话每一层统一排序，换成二路分治结构归并排序，或者自顶向下划分，都是可以的。

爆力写挂 不能这么冲，原因是求的是$$\max$$，此时我们需要考虑两个点是否在同一棵子树了，简单想法是用线段树合并来进行虚树上的dp。更简单的做法是这个dp转移只会ban掉一个子树内的点，所以我们只需要设$$dp(u)=(x,y,z)$$表示最小值$$x$$，$$x$$所在的子树，以及和$$x$$不在同一个子树的最小值。还是一个$$\log$$。

但是 通道 要更强一些，先咕咕咕（

-----

Monster Hunter

树，除了$$1$$以外每个点有一个怪，每个怪会砍你$$a_i$$点血然后给你加$$b_i$$点血，如果你的血变成了负数你就没了，每个点的怪只会打一遍。求要打完所有怪，一开始至少需要多少血。$$n\leq 10^5$$。

先二分，然后你发现很可能不需要二分（

考虑菊花怎么做。

先选能回血的，按$$a$$从小到大选。

然后选扣血的，按$$b$$从大到小选。

第一部分显然，第二部分为什么是对的?

考虑邻项交换，我们把$$(i,j)$$换成$$(j,i)$$之后，前面能打过当且仅当$$x\geq\max(a_i,a_i-b_i+a_j)$$，后面能打过当且仅当$$x\geq\max(a_j,a_j-b_j+a_i)$$。

不妨设$$a_i\leq a_j$$，注意到$$b\leq a$$，也就是$$a_i-b_i\geq 0$$，所以第一个$$\max$$必然是$$a_j$$，第二个是$$a_j+\max(a_i-b_j,0)$$。所以如果$$a_i-b_j\geq 0$$，那么应该选择顺序$$(i,j)$$，否则两个没啥区别。为了让所有$$(j,i)$$都不出现$$a_i-b_j\geq 0$$，我们应该把

不是菊花的话，相当于有若干个 要打一个点，先打父亲 的限制。我们先把所有点排序，选一个最牛逼的，那么可以认为选了这个点的父亲之后，立刻就会选这个点，所以我们把这两个点合并。

怎么合并?$$(a_2,b_2)$$合并到$$(a_1,b_1)$$，此时最大扣血是$$\max(a_1,a_1-b_1+a_2)$$，而加血就是总的减去这个。

-----

Count the Sequences

给$$m,b,c,n$$，求满足

 - $$0\leq x_i\leq b^i-c$$

 - $$\sum x_i<n$$

的长$$m$$的序列$$x$$的个数。$$m\leq 50,2\leq b\leq 10^9,-b+2\leq c\leq b-1,1\leq n\leq b^{m+1}$$，$$n$$可能是高精度数。

据说这是经典容斥（

直接算看起来啥数据结构都维护不了，考虑先搞个好点的形式。

我们对这个上限进行容斥，钦定一些数超过$$b^i-c$$，那么设$$x$$为这些数的$$b^i-c+1$$之和(有$$0$$哦)，随便分配的方案数就可以加入一个辅助变量，然后隔板掉，它是$$\binom{n-1-x+m}{m}$$。设这个为$$f(x)$$。

$$f$$不好办，但是注意到它是$$m$$次多项式，所以考虑把每一项拆开，然后对于$$k=0,...,m$$，计算所有集合中的$$x^k$$之和。注意如果$$x$$实在太大，$$n-1-x+m$$变成了负数，我们也不希望要这个情况，于是我们还要求$$x\leq n-1$$。

考虑枚举集合的大小$$a$$，那么$$\sum\limits_{i\in S}(b^i-c+1)=\sum\limits_{i\in S}b^i-a(c+1)$$，所以我们求出$$n-1-a(c+1)$$的$$b$$进制分解，问题就变成钦定前面若干位相同，后面可以随便选，数位dp即可，转移可以用二项式定理硬冲。

直接做是$$m^5$$的，注意到对于相同的$$k$$，每个$$a$$钦定了前面若干位相同之后，后面随便选的部分是一样的，于是预处理一下就$$O(n^4)$$了。

-----

Dead Cacti Society

XX Open Cup, GP of Korea, Problem E

给一个仙人掌，边有边权，还有一套附加的点权和边权。你需要给每个环断一条边，如果断了边$$u\leftrightarrow v$$，那么会加两个点$$u^\prime,v^\prime$$，从$$u$$连到$$u^\prime$$，$$v$$连到$$v^\prime$$，边权分别是$$u,v$$的附加点权加上断掉的附加边权。最小化得到的树在边权意义下的直径。$$n\leq 10^5,m\leq 1.5\times 10^5$$。

先建个圆方树再说。

考虑一个圆方树dp，你发现我们需要决策留下哪条链。二分答案，然后直接按照类似于ARC088F的方法做即可。

具体一点，我们设$$dp(u)$$表示$$u$$子树满足限制的情况下，留给上面的最长链最短是多长。删掉每条边，得到子树内的直径和最大深度，把直径合法的方案，最大深度取一个$$\min$$即可，可以用各种方法解决。据说精细实现是线性的。

-----

Entanglement

给一个$$n\times m$$的矩阵和常数$$k$$，求有多少对长$$n,m$$，值域都在$$[1,k]$$的序列$$a,b$$，满足矩阵中每个位置$$(i,j)$$，和$$a_i,b_j$$中至少一个相等。$$n,m\leq 300$$。

考虑直接搜，考虑先确定$$a_1$$，如果它不等于第一行的某个数$$j$$，那么$$b_j$$必须是这个数。至于$$a_2$$，如果它不等于第二行的某个数$$j$$，并且$$b_j$$还没确定，那么$$b_j$$必须是这个数，否则要么不合法要么不用管。

考虑怎么求这个东西的复杂度，它是$$T(n,m)=T(n-1,0)+\sum_{x}T(n-1,c(x))+O(nm)$$，其中$$c(x)$$是$$x$$在这一行的出现次数，$$nm$$是我们确定一列之后需要把已经合法的标记上。

我们归纳证明这个复杂度不超过$$n^2m$$。因为$$c$$的总和是$$O(m)$$，所以递归树上每一层$$m$$的总和是不变的，一共有$$n$$层，所以总共就是$$O(n^2m)$$。

-----

Four Elements

XIX Open Cup, GP of C , Problem M

给一些值域区间，求有多少种方式从这些区间里面选出四个数(可重)，使得和为给定的一个$$s$$。$$n\leq 400,s\leq 8\times 10^8,l,r\leq 2\times 10^8$$。

先算不可重的。

给区间求交，然后考虑一个折半，我们先求选两个数的方案数。

问题是怎么求选两个数的方案数，你发现两个数要么在一个区间内，要么在两个区间中，第一种是二次的，第二种还是二次的。问题变成维护一个序列，支持区间加二次函数，最后求它倒过来和自己的点积。

注意到二次函数的和还是二次函数，这个函数最后就是$$n^2$$段，每一段还是二次函数，然后我们就爆力算这个分段函数并倒过来和自己点积即可，二次函数点积二次函数也是可以算的。

注意到可重，所以需要爆搜等价类来容斥，不过这里只有四个所以也可以手动讨论。