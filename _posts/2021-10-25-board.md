---
layout: post
title: 板子
subtitle: /fn
tags: 杂项
---

## _

general

```cpp
#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<vector>
using std::vector;
using std::sort;

inline int max(int x,int y){ return x>y?x:y; }
inline int min(int x,int y){ return x<y?x:y; }
inline void swap(int &x,int &y){ x^=y^=x^=y; }

int main()
{

	return 0;
}
```

for modular counting problems

```cpp
#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<vector>
using std::vector;
using std::sort;

const int P=;
inline int pow(int a,int n){ int c=1; for(;n;n>>=1,a=(long long)a*a%P) if(n&1) c=(long long)c*a%P; return c; }

inline int max(int x,int y){ return x>y?x:y; }
inline int min(int x,int y){ return x<y?x:y; }
inline void swap(int &x,int &y){ x^=y^=x^=y; }

int main()
{

	return 0;
}
```

## 01-Trie for Maximum Xor Sum

## ACAM

```cpp
const int N=200002;
int tr[N][26],fail[N],fa[N],sum[N];
int cnt;

inline int insert(int len,char *s)
{
	int c,u=0;
	for(int i=1;i<=len;i++)
	{
		c=s[i]-'a';
		if(!tr[u][c]) tr[u][c]=++cnt,fa[tr[u][c]]=u;
		u=tr[u][c];
	}
	return u;
}

struct Queue{ int head,tail,q[N]; inline void clear(){ head=1,tail=0; } inline void push(int x){ q[++tail]=x; } inline void pop(){ head++; } inline int front(){ return q[head]; } inline bool empty(){ return head>tail; } }q;

inline void ACAM()
{
	q.clear();
	for(int i=0;i<26;i++)
		if(tr[0][i]) q.push(tr[0][i]);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=0;i<26;i++)
			if(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]);
			else tr[u][i]=tr[fail[u]][i];
	}
}
```

## Better Function Names for Builtin Binary Operators

```cpp
#define popcnt(x) __builtin_popcount(x)
#define popcnt_ll(x) __builtin__popcountll(x)
#define lowbit_pos(x) __builtin_ffs(x)
#define lowbit_pos_ll(x) __builtin_ffsll(x)
#define lg(x) (31-__builtin_clz(x))
#define lg_ll(x) (63-__builtin_clzll(x))
```

## BiT

```cpp
const int N=2000020;
struct BiT{ int c[N]; inline void add(int x,int v){ x+=5; for(;x<=N;x+=lowbit(x)) c[x]+=v; } inline int sum(int x){ x+=5; int ans=0; for(;x;x-=lowbit(x)) ans+=c[x]; return ans; } };
```

## Bitset

## Boruvka

## Cipolla

```cpp
int w;
struct N{ int a,b; };
inline N operator * (const N &x,const N &y){ return {((long long)x.a*y.a+(long long)w*x.b%P*y.b)%P,((long long)x.a*y.b+(long long)x.b*y.a)%P}; }
inline int pow(N a,int n){ N c={1,0}; for(;n;n>>=1,a=a*a) if(n&1) c=c*a; return c; }
inline bool check(int x){ return pow({x,0},(P-1)>>1)==1; }
inline unsigned long long xor64(){ static unsigned long long x=19260817; return x^=x<<13,x^=x>>17,x^=x<<7; }
inline int sqrt(int n)
{
	if(!n) return 0;
	int a=xor64()%P,ans; while(!a||check(((long long)a*a-n+P)%P)) a=xor64%P;
	w=((long long)a*a-n+P)%P,ans=pow({a,1},(P+1)>>1); return min(ans,P-ans);
}
```

## Computional Geometry

## Cost Flow

Successive Shortest Path(Maximum Cost Maximum Flow)

```cpp
const int N=502,M=100002;

int s,t,cnt,n;

struct Edge{ int v,w,f,next; }e[2*M];
int h[N],ecnt=1;
inline void add_edge(int u,int v,double w,int f){ e[++ecnt]={v,w,f,h[u]},h[u]=ecnt;e[++ecnt]={u,-w,0,h[v]},h[v]=ecnt; }

struct Queue{ int head,tail,q[500002]; inline void clear(){ head=1,tail=0; } inline void push(int x){ q[++tail]=x; } inline void pop(){ head++; } inline int front(){ return q[head]; } inline bool empty(){ return head>tail; } }q;
long long dis[N];
bool inque[N];
int pre[N];
inline bool spfa()
{
	memset(pre,0,sizeof(pre)),memset(dis,0x3f,sizeof(dis));
	q.clear();
	dis[s]=0,inque[s]=1,q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=h[u];i;i=e[i].next)
			if(e[i].f&&dis[u]+e[i].w>dis[e[i].v]) dis[e[i].v]=dis[u]+e[i].w,pre[e[i].v]=i^1,(inque[e[i].v]?(void)0:q.push(e[i].v));
		inque[u]=0;
	}
	return dis[t]!=0x3f3f3f3f3f3f3f3fll;
}
inline long long add_flow()
{
	int f=0x3f3f3f3f;
	for(int u=t;u!=s;u=e[pre[u]].v) f=min(f,e[pre[u]^1].f);
	for(int u=t;u!=s;u=e[pre[u]].v) e[pre[u]].f+=f,e[pre[u]^1].f-=f;
	return dis[t]*f;
}
inline long long ssp(){ long long ans=0; while(spfa()) ans+=add_flow(); return ans; }
```

Capicity Scaling

Cost Scaling

## D&C

## Dinic

```cpp
struct Edge{ int v,f,next; }e[5000002];
int ecnt=1,h[500002],cur[500002];
inline void add_edge(int u,int v,int f){ e[++ecnt]={v,f,h[u]},h[u]=ecnt;e[++ecnt]={u,0,h[v]},h[v]=ecnt; }

int s,t;

int dis[500002];
struct Queue{ int head,tail,q[500002]; inline void clear(){ head=1,tail=0; } inline void push(int x){ q[++tail]=x; } inline void pop(){ head++; } inline int front(){ return q[head]; } inline bool empty(){ return head>tail; } }q;
inline bool bfs()
{
	q.clear();
	memset(dis,-1,sizeof(dis));
	q.push(s),dis[s]=0;
	while(!q.empty())
	{
		int u=q.front();q.pop();
		cur[u]=h[u];
		for(int i=h[u];i;i=e[i].next)
			if(dis[e[i].v]==-1&&e[i].f) q.push(e[i].v),dis[e[i].v]=dis[u]+1;
	}
	return dis[t]!=-1;
}
long long dfs(int u,long long f)
{
	if(!f) return 0;
	if(u==t) return f;
	long long sum=0,temp=0;
	for(int i=cur[u];i;i=e[i].next)
	{
		cur[u]=i;
		if(dis[e[i].v]==dis[u]+1){ temp=dfs(e[i].v,min(f,e[i].f)); sum+=temp,f-=temp; e[i].f-=temp,e[i^1].f+=temp; if(!f) return sum; }
	}
	return sum;
}
inline long long dinic(){ long long ans=0; while(bfs()) ans+=dfs(s,0x3f3f3f3f3f3f3f3fll); return ans; }
```

## Dijkstra

## Discretization

```cpp
using std::lower_bound;
inline void discretize(int n,int m,int *a,int *t){ for(int i=1;i<=n;i++) a[i]=lower_bound(t+1,t+m+1,a[i])-t; }
```

## Dominator Tree

## ExCRT

without __int128

```cpp
long long exgcd(long long a,long long b,long long &x,long long &y){ if(!b){ x=1,y=0;return a; } long long g=exgcd(b,a%b,y,x); y=y-a/b*x; return g; }
inline void mod(long long &x,const long long &m){ (x>=m)&&(x-=m); }
inline long long mul(long long a,long long b,long long m){ long long c=0; a%=m,b%=m,mod(a+=m,m),mod(b+=m,m); for(;b;b>>=1,mod(a+=a,m)) if(b&1) mod(c+=a,m); return c; }
inline int exCRT(long long a1,long long m1,long long a2,long long m2,long long &a,long long &m)//merge equations x=a1(mod m1), x=a2(mod m2), put the answer in x=a(mod m)
{
	long long x1,x2,c=a2-a1;
	long long g=exgcd(m1,m2,x1,x2);
	if(c%g) return 1;
	m=m1/g*m2;
	x1=mul(x1,c/g,m);
	mod(a=(a1+mul(m1,x1,m)),m);
	return 0;
}
```

with __int128

```cpp
long long exgcd(long long a,long long b,long long &x,long long &y){ if(!b){ x=1,y=0;return a; } long long g=exgcd(b,a%b,y,x); y=y-a/b*x; return g; }
inline void mod(long long &x,const long long &m){ (x>=m)&&(x-=m); }
inline int exCRT(long long a1,long long m1,long long a2,long long m2,long long &a,long long &m)//merge equations x=a1(mod m1), x=a2(mod m2), put the answer in x=a(mod m)
{
	long long x1,x2,c=a2-a1;
	long long g=exgcd(m1,m2,x1,x2);
	if(c%g) return 1;
	m=m1/g*m2;
	x1=(__int128)x1*(c/g)%m;
	mod(a=a1+(__int128)m1*x1%m,m);
	return 0;
}
```

## FFT

## FMT

subset prefix sum/delta

```cpp
inline void fmt(int n,int *A,int type)
{
	for(int l=2;l<=(1<<n);l<<=1)
	{
		int mid=l>>1;
		for(int p=0;p<(1<<n);p+=l)
			for(int i=0;i<mid;i++)
				A[p+mid+i]=A[p+mid+i]+type*A[p+i];//+ can be replaced by the operator you want
	}
}
```

subset suffix sum/delta

```cpp
inline void fmt(int n,int *A,int type)
{
	for(int l=2;l<=(1<<n);l<<=1)
	{
		int mid=l>>1;
		for(int p=0;p<(1<<n);p+=l)
			for(int i=0;i<mid;i++)
				A[p+mid+i]=A[p+mid+i]+type*A[p+i];//+ can be replaced by the operator you want
	}
}
```

for maximum and/or sum

for minimum and/or sum

## Gauss-Jordan Elimination

liner equations

```cpp
const int N=502;
const double eps=1e-4;//maybe you should change this

inline double abs(double x){ return x<0?-x:x; }
inline void swap(double &x,double &y){ double t=x;x=y;y=t; }
inline void swap(bool &x,bool &y){ x^=y^=x^=y; }

inline int Gauss(int n,int **a)//0: exactly one solution, 1: infinity solutions, 2: no solution; the solution is {x_i=a[i][0]/a[i][i]} for i=1 to n
{
	static bool used[N];
	memset(used,0,sizeof(bool)*(n+2));
	for(int k=1;k<=n;k++)
	{
		int p=0;
		for(int i=1;i<=n;i++) if(!used[i]&&abs(a[i][k])>eps&&(!p||a[i][k]>a[p][k])) p=i;
		if(!p) continue;
		used[p]=1;
		double coe=1/a[p][k];
		swap(used[p],used[k]);
		for(int i=0;i<=n;i++) a[p][i]*=coe,swap(a[p][i],a[k][i]);
		for(int i=1;i<=n;i++)
		{
			if(i==k||abs(a[i][k])<eps) continue;
			coe=1/a[i][k];
			for(int j=0;j<=n;j++) a[i][j]=a[i][j]*coe-a[k][j];
		}
	}
	bool flag=0;
	for(int i=1;i<=n;i++) if(abs(a[i][i])<eps){ flag=1; if(abs(a[i][0])>eps) return 2; }
	return flag;
}
```

matrix inversion(modular)

```cpp

```

determinant(modular)

```cpp
const int N=602;
inline int det(int n,int a[N][N])
{
	int ans=1;
	for(int k=1;k<=n&&ans;ans=(long long)ans*a[k][k]%P,k++)
		for(int i=k+1;i<=n;i++)
		{
			int x=k,y=i,coe,cnt=0;
			while(a[y][k]){ coe=a[x][k]/a[y][k]; for(int j=1;j<=n;j++) a[x][j]=(a[x][j]+(long long)(P-coe)*a[y][j])%P; swap(x,y); }//a[i][j]<P must be held
			if(!a[k][k]){ ans=P-ans; for(int j=1;j<=n;j++) swap(a[x][j],a[y][j]); }
		}
	return ans;
}
```

## Hash Table

static

```cpp
struct HashTable//map int to T
{
#define T int//int can be replaced by the class you want
#define T_0 0//0 can be replaced by the zero item of T
	inline unsigned long long xor64(){ static unsigned long long x=19260817; return x^=x<<13,x^=x>>17,x^=x<<7; }
	inline int abs(int x){ return x<0?-x:x; }
	const int M=1000003;//good primes: 1009, 10007, 100003, 1000003, 10000019
	int a[M];bool used[M];
	T b[M];
	int m,c1,c2,c3,c4;
	inline HashTable(){ c1=xor64()%(M-1)+1,c2=xor64()%(M-1)+1,c3=xor64()%(M-1)+1,c4=xor64()%(M-1)+1; }
	inline int hash(const int &x,const int &t){ return ((long long)c1*x+c2+t*(((long long)c3*x%m+c4)%(m-1)+1))%m; }
	//insert: negtive integer means key exists, and its abs is the position; find: -1 means key doesn't exist; erase: 0 means successful erased, -1 means key doesn't exist
	inline int insert(int x,T y){ if((size+1)*2+1>m) resize((size*2+1)*2+1); int p=hash(x,0),t=0; while(used[p]&&a[p]!=x) p=hash(x,++t); if(a[p]==x) return -p; used[p]=1,a[p]=x,b[p]=y,size++; return p; }
	inline int find(int x){ int p=hash(x,0),t=0; while(used[p]&&a[p]!=x) p=hash(x,++t); if(a[p]==x) return p; return -1; }
	inline int erase(int p){ return find(p)==-1?-1:used[find(p)]=0; }
	inline int& operator [] (int x){ return b[abs(insert(x,T_0))]; }
#undef T
#undef T_0
}h;
```

dynamic(i think it is hard to use :( )

```cpp
struct HashTable//map int to T
{
#define T int//int can be replaced by the class you want
#define T_0 0//0 can be replaced by the zero item of T
	inline void swap(int *&x,int *&y){ int *t=x;x=y;y=t; }
	inline void swap(bool *&x,bool *&y){ bool *t=x;x=y;y=t; }
	inline unsigned long long xor64(){ static unsigned long long x=19260817; return x^=x<<13,x^=x>>17,x^=x<<7; }
	inline bool is_prime(int x){ if(x==1) return 0; for(int i=2;i*i<=x;i++) if(x%i==0) return 0; return 1; }
	inline int abs(int x){ return x<0?-x:x; }
	//inline void swap(T *&x,T *&y){ T *t=x;x=y;y=t; }//if T is not int, this should be used
	int *a;bool *used;
	T *b;
	int m,c1,c2,c3,c4;
	int size;
	inline HashTable(){ a=NULL,b=NULL,used=NULL;  }
	inline int hash(const int &x,const int &t){ return ((long long)c1*x+c2+t*(((long long)c3*x%m+c4)%(m-1)+1))%m; }
	inline int _insert(int x,T y){ int p=hash(x,0),t=0; while(used[p]&&a[p]!=x) p=hash(x,++t); if(a[p]==x) return -p; used[p]=1,a[p]=x,b[p]=y; return p; }
	inline void resize(int n){ int last=m;m=n+!(n&1); while(!is_prime(m)) m+=2; int *ta=new int[m];T *tb=new T[m];bool *tused=new bool[m]; memset(tused,0,sizeof(bool)*m);swap(ta,a),swap(tb,b),swap(tused,used); c1=xor64()%(m-1)+1,c2=xor64()%(m-1)+1,c3=xor64()%(m-1)+1,c4=xor64()%(m-1)+1; for(int i=0;i<last;i++) if(tused[i]) _insert(ta[i],tb[i]); if(ta!=NULL) delete []ta,delete []tb,delete []tused; }
	//insert: negtive integer means key exists, and its abs is the position; find: -1 means key doesn't exist; erase: 0 means successful erased, -1 means key doesn't exist
	inline int insert(int x,T y){ if((size+1)*2+1>m) resize((size*2+1)*2+1); int p=hash(x,0),t=0; while(used[p]&&a[p]!=x) p=hash(x,++t); if(a[p]==x) return -p; used[p]=1,a[p]=x,b[p]=y,size++; return p; }
	inline int find(int x){ int p=hash(x,0),t=0; while(used[p]&&a[p]!=x) p=hash(x,++t); if(a[p]==x) return p; return -1; }
	inline int erase(int p){ return find(p)==-1?-1:used[find(p)]=0; }
	inline int& operator [] (int x){ return b[abs(insert(x,T_0))]; }
#undef T
#undef T_0
}h;
```

## Heaps

All heaps here are minimum heaps. Want maximum heap? Overload operator <.

Binary Heap: push, pop, top.

```cpp
template<class T>
struct BinaryHeap
{
	inline void swap(int &x,int &y){ x^=y^=x^=y; }
	const int N=1000002;
	T a[N];
	int cnt=0;
	#define lq(u) ((u)<<1)
	#define rq(u) ((u)<<1|1)
	#define fa(u) ((u)>>1)
	Heap(){ cnt=0; }
	inline T top(){ return a[1]; }
	inline void up(int u){ for(;u>1&&a[u]<a[fa(u)];u=fa(u)) swap(a[fa(u)],a[u]); }
	inline void down(int u){ for(;lq(u)<=cnt&&(a[lq(u)]<a[u]||(rq(u)<=cnt&&a[rq(u)]<a[u]));) (rq(u)<=cnt&&a[rq(u)]<a[lq(u)])?(swap(a[u],a[rq(u)]),u=rq(u)):(swap(a[u],a[lq(u)]),u=lq(u)); }
	inline void push(T x){ a[++cnt]=x; up(cnt); }
	inline void pop(){ swap(a[1],a[cnt]),cnt--; down(1); }
	inline bool empty(){ return !cnt; }
	#undef lq
	#undef rq
	#undef fa
};
template<class T>
struct EraseableBinaryHeap
{
	BinaryHeap<T> h1,h2;
	inline void push(T x){ h1.push(x); }
	inline void erase(T x){ h2.push(x); }
	inline T top(){ while(h1.top()==h2.top()) h1.pop(),h2.pop(); return h1.top(); }
	inline void pop(){ top(),h1.pop(); }
	inline bool empty(){ return top(),h1.empty(); }
};
```

Min-Max Heap: push, pop-min, pop-max, top-min, top-max.

```cpp
template<class T>
struct MinMaxHeap
{
	static const int N=2000002;
	T a[N];
	int cnt;
	#define lq(u) ((u)<<1)
	#define rq(u) ((u)<<1|1)
	#define fa(u) ((u)>>1)
	#define gfa(u) ((u)>>2)
	MinMaxHeap(){ cnt=0; }
	inline int min_pos(int u,int v){ return (v>cnt||a[u]<a[v])?u:v; }
	inline int max_pos(int u,int v){ return (v>cnt||a[v]<a[u])?u:v; }
	inline void swap(T &x,T &y){ T t=x;x=y;y=t; }
	#define dep(u) (30-__builtin_clz(u))
	inline void down_min(int u){ for(int t1,t2;lq(u)<=cnt;u=t2) t1=min_pos(lq(u),rq(u)),t2=min_pos(min_pos(lq(lq(u)),rq(lq(u))),min_pos(lq(rq(u)),rq(rq(u)))),t2<=cnt&&a[t2]<a[t1]?(a[t2]<a[u]?(swap(a[t2],a[u]),a[fa(t2)]<a[t2]?swap(a[t2],a[fa(t2)]):(void)0):(void)0):(a[t1]<a[u]?(swap(a[t1],a[u]),(void)(u=N)):(void)0); }
	inline void down_max(int u){ for(int t1,t2;lq(u)<=cnt;u=t2) t1=max_pos(lq(u),rq(u)),t2=max_pos(max_pos(lq(lq(u)),rq(lq(u))),max_pos(lq(rq(u)),rq(rq(u)))),t2<=cnt&&a[t1]<a[t2]?(a[u]<a[t2]?(swap(a[t2],a[u]),a[t2]<a[fa(t2)]?swap(a[t2],a[fa(t2)]):(void)0):(void)0):(a[u]<a[t1]?(swap(a[t1],a[u]),(void)(u=N)):(void)0); }
	inline void up_min(int u){ for(;gfa(u)&&a[u]<a[gfa(u)];u=gfa(u)) swap(a[u],a[gfa(u)]); }
	inline void up_max(int u){ for(;gfa(u)&&a[gfa(u)]<a[u];u=gfa(u)) swap(a[u],a[gfa(u)]); }
	inline void up(int u){ if(u==1) return; if(dep(u)&1) a[fa(u)]<a[u]?swap(a[fa(u)],a[u]),up_max(fa(u)):up_min(u); else a[u]<a[fa(u)]?swap(a[fa(u)],a[u]),up_min(fa(u)):up_max(u); }
	inline int size(){ return cnt; }
	inline bool empty(){ return !cnt; }
	inline T top_min(){ return a[1]; }
	inline T top_max(){ return cnt>=3?a[max_pos(2,3)]:(cnt>=2?a[2]:a[1]); }
	inline int top_max_pos(){ return cnt>=3?max_pos(2,3):cnt>=2?2:1; }
	inline void push(T x){ a[++cnt]=x,up(cnt); }
	inline void pop_min(){ a[1]=a[cnt--],down_min(1); }
	inline void pop_max(){ int p=top_max_pos(); a[p]=a[cnt--]; if(p<=cnt) down_max(p); }
	#undef lq
	#undef rq
	#undef fa
	#undef gfa
	#undef dep
};
```

Skew Heap: merge, push, erase(iterator), pop, top. Never used, maybe correct?

```cpp
template<class T>
struct SkewHeap
{
	const int N=1000002;
	struct Node{ T v;int lq,rq;bool del; Node(){ v=0x3f3f3f3f,lq=rq=0,del=0; } }t[N];
	int ncnt;
	inline int new_node(int _v=0x3f3f3f3f){ return t[++ncnt]={_v,0,0,0},ncnt; }
	#define lq(u) t[u].lq
	#define rq(u) t[u].rq
	inline int merge(int u,int v)
	{
		if(!u||!v) return u|v;
		if(t[u].v>t[v].v) swap(u,v);
		return rq(u)=merge(rq(u),v),swap(lq(u),rq(u)),u;
	}
	inline int push(int rt,T v){ int p=new_node(v); return merge(rt,p),p; }
	inline void erase(int u){ t[u].del=1; }
	inline T top(int &rt){ while(t[rt].del) rt=merge(lq(rt),rq(rt)); return t[rt].v; }
	inline void pop(int &rt){ top(rt),rt=merge(lq(rt),rq(rt)); }
	#undef lq
	#undef rq
};

//maybe you want an array to find roots of your heap?
```

Leftist Tree(just some modify on function merge). Never used, maybe correct?

```cpp
template<class T>
struct LeftistTree
{
	const int N=1000002;
	struct Node{ T v;int lq,rq,dis;bool del; Node(){ v=0x3f3f3f3f,lq=rq=0,dis=1,del=0; } }t[N];
	int ncnt;
	inline int new_node(int _v=0x3f3f3f3f){ return t[++ncnt]={_v,0,0,1,0},ncnt; }
	#define lq(u) t[u].lq
	#define rq(u) t[u].rq
	inline int merge(int u,int v)
	{
		if(!u||!v) return u|v;
		if(t[u].v>t[v].v) swap(u,v);
		rq(u)=merge(rq(u),v);
		if(t[lq(u)].dis<t[rq(u)].dis) swap(lq(u),rq(u));
		return t[u].dis=t[rq(u)].dis+1,u;
	}
	inline int push(int rt,T v){ int p=new_node(v); return merge(rt,p),p; }
	inline void erase(int u){ t[u].del=1; }
	inline T top(int &rt){ while(t[rt].del) rt=merge(lq(rt),rq(rt)); return t[rt].v; }
	inline void pop(int &rt){ top(rt),rt=merge(lq(rt),rq(rt)); }
	#undef lq
	#undef rq
};

//maybe you want an array to find roots of your heap?
```

## Inv(Number Theory) in Liner Time

```cpp
const int N=1000002;

inline void inv(int n,int *a,int *inv_a)
{
	static int pre[N],suf[N];
	pre[0]=suf[n+1]=1;
	for(int i=1;i<=n;i++) pre[i]=(long long)pre[i-1]*a[i]%P;
	for(int i=n;i;i--) suf[i]=(long long)suf[i+1]*a[i]%P;
	int t=pow(pre[n],P-2);
	for(int i=1;i<=n;i++) inv_a[i]=(long long)t*pre[i-1]%P*suf[i+1]%P;
}
```

## K-d Tree

2-dt(static)

```cpp
inline int max(const int x,const int y){ return x>y?x:y; }
inline int min(const int x,const int y){ return x<y?x:y; }

struct Point{ int x,y,val; }p[500002];
inline bool cmpx(Point x,Point y){ return x.x<y.x; }
inline bool cmpy(Point x,Point y){ return x.y<y.y; }

struct Node{ int xl,xr,yl,yr,sum; }t[1000002];
#define lq(u) ((u)<<1)
#define rq(u) ((u)<<1|1)

inline void push_up(int u){ t[u].sum=t[lq(u)].sum+t[rq(u)].sum; }
void build(int l,int r,int u,bool d)
{
	if(l==r){ t[u].xl=t[u].xr=p[l].x,t[u].yl=t[u].yr=p[l].y,t[u].sum=p[l].val;return; }
	int mid=l+r>>1;
	nth_element(p+l,p+mid,p+r+1,d?cmpx:cmpy);
	build(l,mid,lq(u),!d),build(mid+1,r,rq(u),!d);
	t[u].xl=min(t[lq(u)].xl,t[rq(u)].xl);
	t[u].yl=min(t[lq(u)].yl,t[rq(u)].yl);
	t[u].xr=max(t[lq(u)].xr,t[rq(u)].xr);
	t[u].yr=max(t[lq(u)].yr,t[rq(u)].yr);
	push_up(u);
}
int query(const int xl,const int xr,const int yl,const int yr,int u)
{
	if(xr<t[u].xl||t[u].xr<xl||yr<t[u].yl||t[u].yr<yl) return 0;
	if(xl<=t[u].xl&&t[u].xr<=xr&&yl<=t[u].yl&&t[u].yr<=yr) return t[u].sum;
	return query(xl,xr,yl,yr,lq(u))+query(xl,xr,yl,yr,rq(u));
}
```

## KMP

```cpp
inline void kmp(int m,char *s,int *fail)
{
	for(int i=2,j=0;i<=n;i++)
	{
		while(j&&s[i]!=s[j+1]) j=fail[j];
		if(s[i]==s[j+1]) j++;
		fail[i]=j;
	}
}
inline void match(int n,int m,char *t,char *s,int *fail,int *ans)//find t in s
{
	for(int i=1,j=0;i<=n;i++)
	{
		while(j&&t[i]!=s[j+1]) j=fail[j];
		if(t[i]==s[j+1]) j++;
		ans[i]=j;
	}
}
```

## Kosaraju

```cpp
const int N=10002,M=100002;

struct Edge{ int v,next; bool type; }e[M<<1];
int ecnt,h[N];
inline void add_edge(int u,int v){ e[++ecnt]={v,h[u],1},h[u]=ecnt;e[++ecnt]={u,h[v],0},h[v]=ecnt; }

int dfa[N],dcnt,c[N],ccnt;//dfa: dfs array, c: SCC which the node belongs to
bool vis[N];
vector<int> v[N];//nodes of each SCC
void dfs1(int u){ vis[u]=1; for(int i=h[u];i;i=e[i].next) if(e[i].type&&!vis[e[i].v]) dfs1(e[i].v); dfa[++dcnt]=u; }
void dfs2(int u,int _c){ c[u]=_c,v[_c].push_back(u); for(int i=h[u];i;i=e[i].next) if(!e[i].type&&!c[e[i].v]) dfs2(e[i].v,_c); }
inline void Kosaraju(int n)
{
	for(int i=1;i<=n;i++) if(!vis[i]) dfs1(i);
	for(int i=n;i>=1;i--) if(!c[dfa[i]]) dfs2(dfa[i],++ccnt);
}
```

## Kruskal

If you want to do something on the MST, try Kruskal Reconstruction Tree or just add a add_edge() to this code.

```cpp
const int N=100002,M=1000002;

struct Tuple{ int u,v,w; }t[M];
int tcnt;
inline void add_tuple(int u,int v,int w){ t[++tcnt]={u,v,w}; }
inline bool cmp(const Tuple &x,const Tuple &y){ return x.w>y.w; }

int f[N];
int find(int x){ return x==f[x]?x:f[x]=find(f[x]); }
inline void merge(int x,int y){ f[find(x)]=find(y); }
inline void init(){ for(int i=1;i<=(n<<1)-1;i++) f[i]=i; }

inline long long kru(int n,int m,Tuple *t)//get weight sum of the mst
{
	init();
	sort(t+1,t+tcnt+1,cmp);
	long long ans=0;
	for(int i=1,cnt=0;i<=m&&cnt<n;i++)
		if(find(t[i].u)!=find(t[i].v)) merge(t[i].u,t[i].v),ans+=t[i].w;
	return ans;
}
```

## Kruskal Reconstruction Tree

Maybe you should put this in a namespace named Kru.

```cpp
const int N=100002,M=1000002;

struct Tuple{ int u,v,w; }t[M];
int tcnt;
inline void add_tuple(int u,int v,int w){ t[++tcnt]={u,v,w}; }
inline bool cmp(const Tuple &x,const Tuple &y){ return x.w>y.w; }

int f[N<<1];
int find(int x){ return x==f[x]?x:f[x]=find(f[x]); }
inline void merge(int x,int y){ f[find(x)]=find(y); }
inline void init(){ for(int i=1;i<=(n<<1)-1;i++) f[i]=i; }

int lq[N<<1],rq[N<<1],w[N<<1];
inline void kru(int n,int m,Tuple *t)
{
	init();
	sort(t+1,t+tcnt+1,cmp);
	for(int i=1,cnt=0;i<=m&&cnt<n;i++)
		if(find(t[i].u)!=find(t[i].v))
		{
			cnt++;
			int now=n+ncnt;
			w[now]=t[i].w;
			lq[now]=find(t[i].u),rq[now]=find(t[i].v);
			fa[0][find(t[i].u)]=fa[0][find(t[i].v)]=now;
			merge(t[i].u,now),merge(t[i].v,now);
		}
}
```

## LCT

```cpp
const int N=100002;
struct LCT
{
	struct Node{ int q[2],fa,val,rev; }t[N];
	
	#define q(u,x) t[u].q[x]
	#define fa(u) t[u].fa
	//push_up and push_down should be changed in different problems
	inline void push_up(int u){ t[u].val=t[q(u,0)].val^t[q(u,1)].val^v[u]; }
	inline void add_rev(int u){ swap(q(u,0),q(u,1)),t[u].rev^=1; }
	inline void push_down(int u){ if(t[u].rev) add_rev(q(u,0)),add_rev(q(u,1)),t[u].rev=0; }
	inline bool is_top(int u){ return q(fa(u),0)!=u&&q(fa(u),1)!=u; }
	void push_downs(int u){ if(!is_top(u)) push_downs(fa(u));push_down(u); }
	inline int get(int u){ return q(fa(u),1)==u; }
	inline void rotate(int u)
	{
		int v=fa(u),w=fa(v),a=get(u),b=get(v);
		if(!is_top(v)) q(w,b)=u;
		fa(u)=w;
		q(v,a)=q(u,!a),fa(q(u,!a))=v;
		q(u,!a)=v,fa(v)=u;
		push_up(v),push_up(u);
	}
	inline void splay(int u)
	{
		push_downs(u);
		for(int v;!is_top(u);)
		{
			v=fa(u);
			if(!is_top(v))
				if(get(u)!=get(v)) rotate(u);
				else rotate(v);
			rotate(u);
		}
	}
	inline int access(int u)
	{
		int v=0;
		for(;u;v=u,u=fa(u)) splay(u),q(u,1)=v,push_up(u);
		return v;
	}
	inline void make_root(int u){ access(u),splay(u),add_rev(u); }
	inline int find_root(int u){ access(u),splay(u);while(q(u,0)) u=q(u,0);return splay(u),u; }
	inline void split(int u,int v){ make_root(u),access(v),splay(v); }
	inline void link(int u,int v){ make_root(u),fa(u)=v; }
	inline void cut(int u,int v){ split(u,v);if(q(v,0)==u&&q(u,1)==0) q(v,0)=fa(u)=0; }
	
	inline void change(int u,int val){ splay(u),v[u]=val,push_up(u); }//change node u's value
	inline int query(int u,int v){ split(u,v);return t[v].val; }//chain query
};
```

## Li-Chao Tree

minimum

```cpp
struct Function{ long long k,b; inline long long operator () (int x){ return k*x+b; } }null;
inline void swap(Function &x,Function &y){ Function t=x;x=y;y=t; }
inline long long min(long long x,long long y){ return x<y?x:y; }

const int N=1000002;
struct Node{ int l,r; Function f; }t[4*N];
#define lq(u) ((u)<<1)
#define rq(u) ((u)<<1|1)

inline void build(int l,int r,int u){ t[u].l=l,t[u].r=r,t[u].f=null; if(l==r) return; int mid=(l+r)>>1; build(l,mid,lq(u)),build(mid+1,r,rq(u)); }
void change(Function f,int u){ int mid=(t[u].l+t[u].r)>>1; if(f(mid)<t[u].f(mid)) swap(f,t[u].f); if(t[u].l==t[u].r) return; if(f(t[u].l)<t[u].f(t[u].l)) change(f,lq(u)); if(f(t[u].r)<t[u].f(t[u].r)) change(f,rq(u)); }
long long query(int x,int u){ if(!u) return 0x3f3f3f3f3f3f3f3f; if(t[u].l==t[u].r) return t[u].f(x); int mid=(t[u].l+t[u].r)>>1; return min(t[u].f(x),query(x,(x<=mid)?lq(u):rq(u))); }
```

for maximum, just change < to > and min to max, or overload operator <.

## List

```cpp
#define List std::list
```

But std::list is hard to use, there is my code, never used, maybe correct?

```cpp
struct List
{
	struct Node{ T v; Node *pre,*nxt; };
	Node *head,*tail;
	List(){ head=tail=new Node(); tail->v=T_0,head->nxt=tail,tail->pre=head; }
	inline Node* begin(){ return head; }
	inline Node* end(){ return tail; }
	inline Node* insert(T _v,Node *p){ Node* u=new Node(); u->v=_v,u->pre=p,u->nxt=p->nxt,p->nxt->pre=u,p->nxt=u; return u; }
	inline void erase(Node *u){ u->pre->nxt=u->nxt,u->nxt->pre=u->pre; delete u; }
};
```

## Manacher

## Merge Sort

## Miller-Rabin



## NTT

我一看，为什么现在的法法塔不用rev了?

哦原来是什么转置原理。懂了。

```cpp
const int P=998244353,g=3;
inline int pow(int a,int n){ int c=1; for(;n;n>>=1,a=(long long)a*a%P) if(n&1) c=(long long)c*a%P; return c; }
const int inv_g=pow(g,P-2);
inline void mod(int &x){ if(x>=P) x-=P; }

const int N=1<<21;
int W[N],inv_W[N];
struct Init{ inline Init(int n=N){ for(int i=1,c=1,Wn,inv_Wn;i<n;i<<=1,c++){ W[i]=inv_W[i]=1,Wn=pow(g,(P-1)>>c),inv_Wn=pow(inv_g,(P-1)>>c); for(int j=1;j<i;j++) W[i+j]=(long long)W[i+j-1]*Wn%P,inv_W[i+j]=(long long)inv_W[i+j-1]*inv_Wn%P; } } }_init;
inline void dft(int n,int *A){ for(int l=n>>1,x,y;l;l>>=1) for(int p=0;p<n;p+=(l<<1)) for(int i=0;i<l;i++) x=A[p+i],y=A[p+l+i],mod(A[p+i]=x+y),A[p+l+i]=(long long)(x-y+P)*W[l+i]%P; }
inline void idft(int n,int *A){ for(int l=1,x,y;l<n;l<<=1) for(int p=0;p<n;p+=(l<<1)) for(int i=0;i<l;i++) x=A[p+i],y=(long long)inv_W[l+i]*A[p+l+i]%P,mod(A[p+i]=x+y),mod(A[p+l+i]=x-y+P); for(int i=0,inv_n=pow(n,P-2);i<n;i++) A[i]=(long long)A[i]*inv_n%P; }
```

## PAM

## Poly

反正OI又用不到这个，不需要背，我就写能写出来的最快的了（

loj #150 挑战多项式，提交时rk21(直接飞了，为什么他们常数那么小)。dft/idft 1E(n)(废话), mul 6E(n), inv 10E(n), ln/div 13E(n), sqrt 11E(n), inv_sqrt 12E(n), exp 18E(n), pow 31E(n)。

inv是贺的，所以码风不太一样（

命名规范大概是，数组名前面加T表示是用于dft的，0表示来自上一轮迭代。

```cpp
const int N=262144;//N should be twice of your max poly length

const int P=998244353,g=3,inv_2=(P+1)/2;
inline void mod(int &x){ (x>=P)&&(x-=P); }
inline void mod2(int &x){ (x>=(P<<1))&&(x-=(P<<1)),(x>=P)&&(x-=P); }
inline void mod_(int &x){ (x<0)&&(x+=P); }
inline int pow(int a,int n){ int c=1; for(;n;n>>=1,a=(long long)a*a%P) if(n&1) c=(long long)c*a%P; return c; }
const int inv_g=pow(g,P-2);

namespace Cipolla//modular square root
{

int w;
struct N{ int a,b; };
inline N operator * (const N &x,const N &y){ return {((long long)x.a*y.a+(long long)w*x.b%P*y.b)%P,((long long)x.a*y.b+(long long)x.b*y.a)%P}; }
inline int pow(N a,int n){ N c={1,0}; for(;n;n>>=1,a=a*a) if(n&1) c=c*a; return c.a; }
inline bool check(int x){ return pow({x,0},(P-1)>>1)==1; }
inline unsigned long long xor64(){ static unsigned long long x=19260817; return x^=x<<13,x^=x>>17,x^=x<<7; }
inline int sqrt(int n)
{
	if(!n) return 0;
	int a=xor64()%P,ans; while(!a||check(((long long)a*a-n+P)%P)) a=xor64()%P;
	w=((long long)a*a-n+P)%P,ans=pow({a,1},(P+1)>>1); return min(ans,P-ans);
}

}

namespace Poly
{

//include dft/idft, deriv/integ, 6E(n) mul, 10E(n) inv, 13E(n) div/ln, 11E(n) sqrt, 12E(n) inv_sqrt 18E(n) exp, 31E(n) pow
//input and output array can be the same because I will copy input at first?

int fac[N],inv_i[N];
int W[N<<1],inv_W[N<<1];

struct Init{
	inline Init(int n=N<<1)
	{
		for(int i=1,c=1,Wn,inv_Wn;i<n;i<<=1,c++)
		{
			W[i]=inv_W[i]=1,Wn=pow(g,(P-1)>>c),inv_Wn=pow(inv_g,(P-1)>>c);
			for(int j=1;j<i;j++)
				W[i+j]=(long long)W[i+j-1]*Wn%P,inv_W[i+j]=(long long)inv_W[i+j-1]*inv_Wn%P;
		}
		inv_i[1]=1;
		for(int i=2;i<n;i++) inv_i[i]=(long long)(P-P/i)*inv_i[P%i]%P;
	}
}_init;

//dif-dit fft
inline void dft(int n,int *A)
{
	for(int l=n>>1,x,y;l;l>>=1)
		for(int p=0;p<n;p+=(l<<1))
			for(int i=0;i<l;i++)
				x=A[p+i],y=A[p+l+i],mod(A[p+i]=x+y),A[p+l+i]=(long long)(x-y+P)*W[l+i]%P;
}//A[n] means F(w_{bitrev(n)})
inline void idft(int n,int *A)
{
	for(int l=1,x,y;l<n;l<<=1)
		for(int p=0;p<n;p+=(l<<1))
			for(int i=0;i<l;i++)
				x=A[p+i],y=(long long)inv_W[l+i]*A[p+l+i]%P,mod(A[p+i]=x+y),mod(A[p+l+i]=x-y+P);
	for(int i=0,inv_n=inv_i[n];i<n;i++) A[i]=(long long)A[i]*inv_n%P;
}

inline void mul(int n,int *A,int *B,int *C){ static int T1[N],T2[N]; memcpy(T1,A,sizeof(int)*n),memcpy(T2,B,sizeof(int)*n),dft(n,T1),dft(n,T2); for(int i=0;i<n;i++) C[i]=(long long)T1[i]*T2[i]%P; idft(n,C); }

inline void inv(int n,int *_F,int *G)//10E(n), calc G=1/F
{
	static int F[N],T[N],TG[N];
	memcpy(F,_F,sizeof(int)*n);
	memset(G,0,sizeof(int)*n),memset(TG,0,sizeof(int)*n),G[0]=pow(F[0],P-2);
	for(int l=2,mid=1;l<=n;l<<=1,mid<<=1)
	{
		memcpy(T,F,sizeof(int)*l);
		memcpy(TG,G,sizeof(int)*mid);
		memset(G+mid,0,sizeof(int)*mid);
		dft(l,G),dft(l,T);
		for(int i=0;i<l;i++) T[i]=(long long)G[i]*T[i]%P;
		idft(l,T);
		memset(T,0,sizeof(int)*mid);
		dft(l,T);
		for(int i=0;i<l;i++) T[i]=(long long)G[i]*T[i]%P;
		idft(l,T);
		memcpy(G,TG,sizeof(int)*l);
		for(int i=mid;i<l;i++) G[i]=T[i]?P-T[i]:0;
	}
}

inline void deriv(int n,int *A){ for(int i=0;i<n;i++) A[i]=(long long)A[i+1]*(i+1)%P; A[n-1]=0; }
inline void integ(int n,int *A){ for(int i=n-1;i>0;i--) A[i]=(long long)A[i-1]*inv_i[i]%P; A[0]=0; }

inline void div(int n,int *_H,int *_F,int *Q)//13E(n), calc Q=H/F
{
	static int F[N],H[N],G0[N],Q0[N],TG0[N],TH0[N],TF[N],TQ0[N],T[N];
	memset(G0,0,sizeof(int)*n),memset(Q0,0,sizeof(int)*n),memset(TG0,0,sizeof(int)*n),memset(TH0,0,sizeof(int)*n),memset(TF,0,sizeof(int)*n),memset(TQ0,0,sizeof(int)*n),memset(T,0,sizeof(int)*n);
	memcpy(F,_F,sizeof(int)*n),memcpy(H,_H,sizeof(int)*n);
	if(n==1){ Q[0]=F[0]*pow(H[0],P-2); return; }
	int mid=n>>1;
	inv(mid,F,G0);

	memcpy(TG0,G0,sizeof(int)*mid),memcpy(TH0,H,sizeof(int)*mid),dft(n,TG0),dft(n,TH0);
	for(int i=0;i<n;i++) Q0[i]=(long long)TG0[i]*TH0[i]%P;
	idft(n,Q0);
	memset(Q0+mid,0,sizeof(int)*mid),memcpy(Q,Q0,sizeof(int)*mid);
	
	memcpy(TF,F,sizeof(int)*n),memcpy(TQ0,Q0,sizeof(int)*mid),dft(n,TF),dft(n,TQ0);
	for(int i=0;i<n;i++) T[i]=(long long)TF[i]*TQ0[i]%P;
	idft(n,T),memset(T,0,sizeof(int)*mid);
	for(int i=mid;i<n;i++) mod(T[i]+=P-H[i]);

	dft(n,T);
	for(int i=0;i<n;i++) T[i]=(long long)T[i]*TG0[i]%P;
	idft(n,T);
	for(int i=mid;i<n;i++) Q[i]=T[i]?P-T[i]:0;
}
inline void ln(int n,int *F,int *G){ static int T[N]; memcpy(T,F,sizeof(int)*n),deriv(n,T),div(n,T,F,G),integ(n,G); }

inline void half_dft(int n,int *TF,int *TF0)
{
	static int rev_n[N],rev_2n[N];
	for(int i=0;i<(n<<1);i++) rev_2n[i]=(rev_2n[i>>1]>>1)|((i&1)?n:0);
	for(int i=0;i<n;i++) rev_n[i]=(rev_n[i>>1]>>1)|((i&1)?(n>>1):0);
	for(int i=0;i<n;i++) TF0[rev_n[i]]=TF[rev_2n[i<<1]];
}

inline void exp(int n,int *_F,int *G)//18E(n)
{
	static int F[N],T[N],H[N],H0[N],G0[N],TH0[N],TH[N],TG0[N],TG00[N],FP[N],TFP[N],GP0[N];
	memset(T,0,sizeof(int)*n),memset(H,0,sizeof(int)*n),memset(H0,0,sizeof(int)*n),memset(G0,0,sizeof(int)*n),memset(TH0,0,sizeof(int)*n),memset(TH,0,sizeof(int)*n),memset(TG0,0,sizeof(int)*n),memset(TG00,0,sizeof(int)*n),memset(TFP,0,sizeof(int)*n),memset(GP0,0,sizeof(int)*n);
	memcpy(F,_F,sizeof(int)*n),memcpy(FP,F,sizeof(int)*n),deriv(n,FP);
	G[0]=1,H[0]=1;
	if(n>1) G[1]=F[1],TG0[0]=1,dft(2,TG0);
	for(int l=2,mid=1;l<n;l<<=1,mid<<=1)
	{
		memcpy(H0,H,sizeof(int)*mid),memcpy(G0,G,sizeof(int)*l);
		
		memcpy(TH0,H0,sizeof(int)*mid),memset(TH0+mid,0,sizeof(int)*(mid+l)),dft(l<<1,TH0);
		memcpy(TG0,G0,sizeof(int)*l),memset(TG0+l,0,sizeof(int)*l),dft(l<<1,TG0);
		for(int i=0;i<(l<<1);i++) H[i]=(long long)TH0[i]*TH0[i]%P*TG0[i]%P;
		idft(l<<1,H),memset(H+l,0,sizeof(int)*l);
		for(int i=0;i<l;i++) mod_(H[i]=(H0[i]<<1)-H[i]),mod(H[i]);
		
		memcpy(TFP,FP,sizeof(int)*(l-1)),dft(l,TFP);
		half_dft(l,TG0,TG00);
		for(int i=0;i<l;i++) T[i]=(long long)TG00[i]*TFP[i]%P;
		idft(l,T);
		memcpy(GP0,G0,sizeof(int)*l),deriv(l,GP0);
		for(int i=0;i<(l<<1);i++) mod(T[i]=GP0[i]+P-T[i]);
		memcpy(T+l,T,sizeof(int)*(l-1)),memset(T,0,sizeof(int)*(l-1));
		
		memcpy(TH,H,sizeof(int)*l),memset(TH+l,0,sizeof(int)*l),dft(l<<1,TH);
		dft(l<<1,T);
		for(int i=0;i<(l<<1);i++) T[i]=(long long)T[i]*TH[i]%P;
		idft(l<<1,T);
		memcpy(T+(l<<1),T,sizeof(int)*(l-1)),memset(T,0,sizeof(int)*(l-1));
		
		for(int i=0;i<l-1;i++) mod(T[i]+=FP[i]);
		integ(l<<1,T);
		for(int i=0;i<(l<<1);i++) mod(T[i]=F[i]+P-T[i]);
		
		dft(l<<1,T);
		for(int i=0;i<(l<<1);i++) T[i]=(long long)T[i]*TG0[i]%P;
		idft(l<<1,T);
		memcpy(T+(l<<1),T,sizeof(int)*l),memset(T,0,sizeof(int)*l);
		
		for(int i=0;i<(l<<1);i++) mod(G[i]=G0[i]+T[i]);
	}
}

inline void inv_sqrt(int n,int *_F,int *_H,int *_TF=NULL)//12E(n)
{
	static int F[N],TF[N<<1],T[N<<1],H[N];
	memcpy(F,_F,sizeof(int)*n);
	H[0]=pow(Cipolla::sqrt(F[0]),P-2);
	for(int l=1;l<n;l<<=1)
	{
		memcpy(TF,F,sizeof(int)*(l<<1)),memset(TF+(l<<1),0,sizeof(int)*(l<<1)),dft(l<<2,TF);
		memcpy(T,H,sizeof(int)*l),memset(T+l,0,sizeof(int)*((l<<1)+l)),dft(l<<2,T);
		for(int i=0;i<(l<<2);i++) T[i]=(long long)T[i]*T[i]%P*T[i]%P*TF[i]%P;
		idft(l<<2,T),memset(T+(l<<1),0,sizeof(int)*(l<<1));
		for(int i=0;i<(l<<1);i++) T[i]=(long long)(T[i]+P-H[i])*inv_2%P;
		memset(T,0,sizeof(int)*l);
		for(int i=0;i<(l<<1);i++) mod(H[i]=H[i]+P-T[i]);
	}
	memcpy(_H,H,sizeof(int)*n);
	if(_TF!=NULL) memcpy(_TF,TF,sizeof(int)*(n<<1));
}
inline void sqrt(int n,int *_F,int *G)//11E(n)
{
	static int H0[N],TH0[N],F[N],TF[N],G0[N],TG0[N],T[N];
	memcpy(F,_F,sizeof(int)*n);
	if(n==1){ G[0]=Cipolla::sqrt(F[0]); return; }
	inv_sqrt(n>>1,_F,H0,TF);
	
	memcpy(TH0,H0,sizeof(int)*(n>>1)),dft(n,TH0);
	for(int i=0;i<n;i++) G0[i]=(long long)TH0[i]*TF[i]%P;
	idft(n,G0),memset(G0+(n>>1),0,sizeof(int)*(n>>1));
	
	memcpy(TG0,G0,sizeof(int)*(n>>1)),dft(n>>1,TG0);
	for(int i=0;i<(n>>1);i++) T[i]=(long long)TG0[i]*TG0[i]%P;
	idft(n>>1,T);
	for(int i=0;i<n;i++) mod(T[i]=T[i]+P-F[i]);
	for(int i=0;i<(n>>1);i++) mod(T[i+(n>>1)]+=T[i]),T[i]=0;
	
	dft(n,T);
	for(int i=0;i<n;i++) T[i]=(long long)T[i]*TH0[i]%P;
	idft(n,T);
	memset(T,0,sizeof(int)*(n>>1));
	
	for(int i=0;i<n;i++) G[i]=(G0[i]+(long long)(P-T[i])*inv_2)%P;
}

inline void pow(int n,int *_F,int k,int *G)
{
	static int F[N],T[N];
	memcpy(F,_F,sizeof(int)*n);
	int p=0,coe,inv_0;
	while(p<n&&!F[p]) p++;
	if(p==n){ memset(G,0,sizeof(int)*n); return; }
	long long shift=(long long)k*p;
	if(shift>=n){ memset(G,0,sizeof(int)*n); return; }
	coe=::pow(F[p],k),inv_0=::pow(F[p],P-2);
	for(int i=0;i<n;i++) F[i]=(long long)F[i]*inv_0%P;
	memcpy(T,F+p,sizeof(int)*(n-p));
	memset(T+(n-p),0,sizeof(int)*p);
	ln(n,T,T);
	for(int i=0;i<n;i++) T[i]=(long long)T[i]*k%P;
	exp(n,T,T);
	memset(G,0,sizeof(int)*shift);
	for(int i=shift;i<n;i++) G[i]=(long long)T[i-shift]*coe%P;
}

}
```

## Prime Sieves

只筛质数

```cpp
const int N=1000002;
bool b[N];
int prime[N/10],pcnt;
inline void sieve(int n){ for(int i=2;i<=n;i++){ if(!b[i]) prime[++pcnt]=i; for(int j=1;j<=pcnt&&i*prime[j]<=n;j++){ b[i*prime[j]]=1; if(!(i%prime[j])) break; } } }
```

常见积性函数($$\varphi,\mu,d,\mathrm{id}_k$$)

```cpp
const int N=20000002;
bool b[N],prime[N/10],pcnt;
int mu[N],phi[N],d[N];
inline void sieve(int n)
{
	mu[1]=phi[1]=d[1]=1;
	for(int i=2;i<=n;i++)
}
```

分段埃筛

```cpp
const int N=1000002;
bool b[N];
int prime[N/10],pcnt;
inline void sieve(int n){ for(int i=2;i<=n;i++){ if(!b[i]) prime[++pcnt]=i; for(int j=1;j<=pcnt&&i*prime[j]<=n;j++){ b[i*prime[j]]=1; if(!(i%prime[j])) break; } } }

const int K=1e7,C=1e3;//en this means maxn is 1e10

inline long long max(long long x,long long y){ return x>y?x:y; }
inline long long sieve(long long l,long long r)//count p in [l,r]
{
	static bool _b[K+10];
	#define b(i) _b[i-l]
	for(long long i=l;i<=r;i++) b(i)=0;
	for(int i=1;(long long)prime[i]*prime[i]<=r;i++)
		for(long long j=max(prime[i]<<1,(l+prime[i]-1)/prime[i]*prime[i]);j<=r;j+=prime[i]) b(j)=1;
	long long ans=0;
	for(long long i=l,temp;i<=r;i++) if(!b(i)) ans++;
	return ans;
}

long long table[C+2];
inline void calc_table()
{
	freopen("t.out","w",stdout);
	sieve(1000000),printf("0,");
	for(int i=1;i<=C;i++)
		table[i]=table[i-1]+sieve(max(1,(long long)(i-1)*K),(long long)i*K-1),printf("%lld,",table[i]),fprintf(stderr,"%d\n",i);
}
inline long long query(long long n){ return table[n/K]+sieve(max(n/K*K,1),n); }
```

## Queue

```cpp
const int N=2000002;
struct Queue{ int head,tail,q[N]; inline void clear(){ head=1,tail=0; } inline Queue(){ head=1,tail=0; } inline void push(int x){ q[++tail]=x; } inline void pop(){ head++; } inline int front(){ return q[head]; } inline bool empty(){ return head>tail; } };
```

## Quick Sort

```cpp
#define quick_sort sort
```

牛逼!

## SA

## SAM

## Simplex

## Simpson

```cpp
inline double f(double x){  }
inline double calc(double l,double r){ return (f(l)+f(r)+4*f((l+r)/2))*(r-l)/6; }
inline double simpson(double l,double r,double A,double eps)
{
	if(eps<1e-100){ fprintf(stderr,"Sorry, Simpson can't fuck it.\n");exit(0); }
	if(r-l<eps) return A;
	double mid=(l+r)/2;
	double L=calc(l,mid),R=calc(mid,r);
	if(fabs(L+R-A)<eps) return A;
	return simpson(l,mid,L,eps/2)+simpson(mid,r,R,eps/2);
}
```

## Segment Tree(Basic)

```cpp
const int N=200002;
struct Node{ int l,r; }t[4*N];
#define lq(u) ((u)<<1)
#define rq(u) ((u)<<1|1)
inline void push_up(int u){  }
inline void add_tag(int u){  }
inline void push_down(int u){ add_tag(lq(u),t[u].tag),add_tag(rq(u),t[u].tag),t[u].tag=0; }
void build(int l,int r,int u){ t[u].l=l,t[u].r=r;if(l==r){ ;return; }int mid=t[u].l+t[u].r>>1;build(l,mid,lq(u)),build(mid+1,r,rq(u)),push_down(u); }
void change(int l,int r,int u,int v){ if(l<=t[u].l&&t[u].r<=r){ add_tag(u,v);return; }int mid=t[u].l+t[u].r>>1;push_down(u);if(l<=mid) change(l,r,lq(u),v);if(mid+1<=r) change(l,r,rq(u),v);push_up(u); }
int query(int l,int r,int u){ if(l<=t[u].l&&t[u].r<=r) return;int mid=t[u].l+t[u].r>>1;push_down(u);return (l<=mid?query(l,r,lq(u):0))+(mid+1<=r?query(l,r,rq(u)):0); }
```

## SPFA

## Split-merge Treap

```cpp
#include<stdio.h>
#include<algorithm>
using std::sort;

inline unsigned long long xor64(){ static unsigned long long x=19260817; return x^=x<<13,x^=x>>17,x^=x<<7; }

struct Node{ int val,size; int lq,rq; }t[1100002];
#define lq(u) t[u].lq
#define rq(u) t[u].rq
int ncnt;
inline int new_node(int _val,int _size=1,int _lq=0,int _rq=0){ return t[++ncnt]={_val,_size,_lq,_rq},ncnt; }
inline void push_up(int u){ t[u].size=t[lq(u)].size+t[rq(u)].size+1; }
inline bool cmp(int u,int v){ return xor64()%(t[u].size+t[v].size)<t[u].size; }

void split(int u,int k,int &x,int &y)//split by val
{
	if(!u){ x=y=0;return; }
	if(t[u].val<=k) split(rq(u),k,rq(u),y),x=u;
	else split(lq(u),k,x,lq(u)),y=u;
	push_up(u);
}
int merge(int u,int v)
{
	if(!u||!v) return u|v;
	if(cmp(u,v)){ rq(u)=merge(rq(u),v),push_up(u);return u; }
	else { lq(v)=merge(u,lq(v)),push_up(v);return v; }
}

inline void insert(int &rt,int x)
{
	int u,v=new_node(x),w;
	split(rt,x,u,w),rt=merge(u,merge(v,w));
}
inline void erase(int &rt,int x)
{
	int u,v,w;
	split(rt,x,rt,w),
	split(rt,x-1,u,v),
	v=merge(lq(v),rq(v)),
	rt=merge(u,merge(v,w));
}
int rank(int u,int x){ if(!u) return 1;return t[u].val>=x?rank(lq(u),x):t[lq(u)].size+1+rank(rq(u),x); }
int kth(int u,int k){ if(t[lq(u)].size+1==k) return t[u].val;return t[lq(u)].size>=k?kth(lq(u),k):kth(rq(u),k-t[lq(u)].size-1); }
inline int pre(int u,int x){ return kth(u,rank(u,x)-1); }
inline int suc(int u,int x){ return kth(u,rank(u,x+1)); }
```

## ST Table

```cpp
const int N=200002;
int f[20][N],lg[N];
inline void init(int n,int *a){ for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1; for(int i=1;i<=n;i++) f[0][i]=a[i]; for(int k=1;k<=20;k++)for(int i=1;i<=n;i++) f[k][i]=min(f[k-1][i],f[k-1][i+(1<<k-1)]); }
inline int query(int l,int r){ int k=lg[r-l+1]; return min(f[k][l],f[k][r-(1<<k)+1]); }
```

## Stack

```cpp
const int N=2000002;
struct Stack{ int cnt,s[N]; inline void clear(){ cnt=0; } inline Stack(){ clear(); } inline void push(int x){ s[++cnt]=x; } inline void pop(){ cnt--; } inline int top(){ return s[cnt]; } inline bool empty(){ return !cnt; } };
```

## Subsequence AM

## Tarjan for DCC

## Union-find Set

路径压缩

```cpp
int f[N];
inline void clear(int n){ for(int i=1;i<=n;i++) f[i]=i; }
int find(int x){ return f[x]==x?x:f[x]=find(f[x]); }
inline void merge(int x,int y){ f[find(x)]=find(y); }
```

wrong 1 times/hanx

启发式合并

```cpp
const int N=2000002;
int f[N],size[N];
inline void clear(int n){ for(int i=1;i<=n;i++) f[i]=i,size[i]=1; }
inline int find(int x){ while(x!=f[x]) x=f[x]; return x; }
inline void merge(int x,int y){ if((x=find(x))!=(y=find(y))) size[x]>size[y]?f[y]=x:f[x]=y;  }
```

## Xor Liner Base

## Xorshift64

```cpp
inline unsigned long long xor64(){ static unsigned long long x=19260817; return x^=x<<13,x^=x>>17,x^=x<<7; }
```

## Z Algo

```cpp
inline void Z(int n,char *s,int *z)
{
	z[1]=n;
	for(int i=2,l=1,r=1;i<=n;i++)
	{
		if(i<=r) z[i]=min(z[i-l+1],r-i+1);
		while(i+z[i]<=n&&s[i+z[i]]==s[z[i]+1]) z[i]++;
		if(i+z[i]-1>r) r=i+z[i]-1,l=i;
	}
}
```

