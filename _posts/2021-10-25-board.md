---
layout: post
title: 板子
subtitle: /fn
tags: 杂项
---

## _

general

```cpp
#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<vector>
using std::vector;
using std::sort;

inline int max(int x,int y){ return x>y?x:y; }
inline int min(int x,int y){ return x<y?x:y; }
inline void swap(int &x,int &y){ x^=y^=x^=y; }

int main()
{

	return 0;
}
```

for modular counting problems

```cpp
#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<vector>
using std::vector;
using std::sort;

const int P=;
inline int pow(int a,int n){ int c=1; for(;n;n>>=1,a=(long long)a*a%P) if(n&1) c=(long long)c*a%P; return c; }

inline int max(int x,int y){ return x>y?x:y; }
inline int min(int x,int y){ return x<y?x:y; }
inline void swap(int &x,int &y){ x^=y^=x^=y; }

int main()
{

	return 0;
}
```

## 01-Trie for Maximum Xor Sum

## ACAM

```cpp
const int N=200002;
int tr[N][26],fail[N],fa[N],sum[N];
int cnt;

inline int insert(int len,char *s)
{
	int c,u=0;
	for(int i=1;i<=len;i++)
	{
		c=s[i]-'a';
		if(!tr[u][c]) tr[u][c]=++cnt,fa[tr[u][c]]=u;
		u=tr[u][c];
	}
	return u;
}

struct Queue{ int head,tail,q[N]; inline void clear(){ head=1,tail=0; } inline void push(int x){ q[++tail]=x; } inline void pop(){ head++; } inline int front(){ return q[head]; } inline bool empty(){ return head>tail; } }q;

inline void ACAM()
{
	q.clear();
	for(int i=0;i<26;i++)
		if(tr[0][i]) q.push(tr[0][i]);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=0;i<26;i++)
			if(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]);
			else tr[u][i]=tr[fail[u]][i];
	}
}
```

## Bell Numbers

## Bernoulli Numbers

## Better Function Names for Builtin Binary Operators

```cpp
#define popcnt(x) __builtin_popcount(x)
#define popcnt_ll(x) __builtin__popcountll(x)
#define lowbit_pos(x) __builtin_ffs(x)
#define lowbit_pos_ll(x) __builtin_ffsll(x)
#define lg(x) (31-__builtin_clz(x))
#define lg_ll(x) (63-__builtin_clzll(x))
```

## BiT

```cpp
const int N=2000020;
struct BiT{ int c[N]; inline void add(int x,int v){ x+=5; for(;x<=N;x+=lowbit(x)) c[x]+=v; } inline int sum(int x){ x+=5; int ans=0; for(;x;x-=lowbit(x)) ans+=c[x]; return ans; } };
```

## Bitset

## Boruvka

## Cipolla

```cpp
int w;
struct N{ int a,b; };
inline N operator * (const N &x,const N &y){ return {((long long)x.a*y.a+(long long)w*x.b%P*y.b)%P,((long long)x.a*y.b+(long long)x.b*y.a)%P}; }
inline int pow(N a,int n){ N c={1,0}; for(;n;n>>=1,a=a*a) if(n&1) c=c*a; return c; }
inline bool check(int x){ return pow({x,0},(P-1)>>1)==1; }
inline unsigned long long xor64(){ static unsigned long long x=19260817; return x^=x<<13,x^=x>>17,x^=x<<7; }
inline int sqrt(int n)
{
	if(!n) return 0;
	int a=xor64()%P,ans; while(!a||check(((long long)a*a-n+P)%P)) a=xor64%P;
	w=((long long)a*a-n+P)%P,ans=pow({a,1},(P+1)>>1); return min(ans,P-ans);
}
```

## Computional Geometry

## Cost Flow

Successive Shortest Path(Maximum Cost Maximum Flow)

```cpp
const int N=502,M=100002;

int s,t,cnt,n;

struct Edge{ int v,w,f,next; }e[2*M];
int h[N],ecnt=1;
inline void add_edge(int u,int v,double w,int f){ e[++ecnt]={v,w,f,h[u]},h[u]=ecnt;e[++ecnt]={u,-w,0,h[v]},h[v]=ecnt; }

struct Queue{ int head,tail,q[500002]; inline void clear(){ head=1,tail=0; } inline void push(int x){ q[++tail]=x; } inline void pop(){ head++; } inline int front(){ return q[head]; } inline bool empty(){ return head>tail; } }q;
long long dis[N];
bool inque[N];
int pre[N];
inline bool spfa()
{
	memset(pre,0,sizeof(pre)),memset(dis,0x3f,sizeof(dis));
	q.clear();
	dis[s]=0,inque[s]=1,q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=h[u];i;i=e[i].next)
			if(e[i].f&&dis[u]+e[i].w>dis[e[i].v]) dis[e[i].v]=dis[u]+e[i].w,pre[e[i].v]=i^1,(inque[e[i].v]?(void)0:q.push(e[i].v));
		inque[u]=0;
	}
	return dis[t]!=0x3f3f3f3f3f3f3f3fll;
}
inline long long add_flow()
{
	int f=0x3f3f3f3f;
	for(int u=t;u!=s;u=e[pre[u]].v) f=min(f,e[pre[u]^1].f);
	for(int u=t;u!=s;u=e[pre[u]].v) e[pre[u]].f+=f,e[pre[u]^1].f-=f;
	return dis[t]*f;
}
inline long long ssp(){ long long ans=0; while(spfa()) ans+=add_flow(); return ans; }
```

Capicity Scaling

Cost Scaling

## D&C

## Dinic

```cpp
struct Edge{ int v,f,next; }e[5000002];
int ecnt=1,h[500002],cur[500002];
inline void add_edge(int u,int v,int f){ e[++ecnt]={v,f,h[u]},h[u]=ecnt;e[++ecnt]={u,0,h[v]},h[v]=ecnt; }

int s,t;

int dis[500002];
struct Queue{ int head,tail,q[500002]; inline void clear(){ head=1,tail=0; } inline void push(int x){ q[++tail]=x; } inline void pop(){ head++; } inline int front(){ return q[head]; } inline bool empty(){ return head>tail; } }q;
inline bool bfs()
{
	q.clear();
	memset(dis,-1,sizeof(dis));
	q.push(s),dis[s]=0;
	while(!q.empty())
	{
		int u=q.front();q.pop();
		cur[u]=h[u];
		for(int i=h[u];i;i=e[i].next)
			if(dis[e[i].v]==-1&&e[i].f) q.push(e[i].v),dis[e[i].v]=dis[u]+1;
	}
	return dis[t]!=-1;
}
long long dfs(int u,long long f)
{
	if(!f) return 0;
	if(u==t) return f;
	long long sum=0,temp=0;
	for(int i=cur[u];i;i=e[i].next)
	{
		cur[u]=i;
		if(dis[e[i].v]==dis[u]+1){ temp=dfs(e[i].v,min(f,e[i].f)); sum+=temp,f-=temp; e[i].f-=temp,e[i^1].f+=temp; if(!f) return sum; }
	}
	return sum;
}
inline long long dinic(){ long long ans=0; while(bfs()) ans+=dfs(s,0x3f3f3f3f3f3f3f3fll); return ans; }
```

## Dijkstra

## Discretization

```cpp
using std::lower_bound;
inline void discretize(int n,int m,int *a,int *t){ for(int i=1;i<=n;i++) a[i]=lower_bound(t+1,t+m+1,a[i])-t; }
```

## Dominator Tree

## ExCRT

without __int128

```cpp
long long exgcd(long long a,long long b,long long &x,long long &y){ if(!b){ x=1,y=0;return a; } long long g=exgcd(b,a%b,y,x); y=y-a/b*x; return g; }
inline void mod(long long &x,const long long &m){ (x>=m)&&(x-=m); }
inline long long mul(long long a,long long b,long long m){ long long c=0; a%=m,b%=m,mod(a+=m,m),mod(b+=m,m); for(;b;b>>=1,mod(a+=a,m)) if(b&1) mod(c+=a,m); return c; }
inline int exCRT(long long a1,long long m1,long long a2,long long m2,long long &a,long long &m)//merge equations x=a1(mod m1), x=a2(mod m2), put the answer in x=a(mod m)
{
	long long x1,x2,c=a2-a1;
	long long g=exgcd(m1,m2,x1,x2);
	if(c%g) return 1;
	m=m1/g*m2;
	x1=mul(x1,c/g,m);
	mod(a=(a1+mul(m1,x1,m)),m);
	return 0;
}
```

with __int128

```cpp
long long exgcd(long long a,long long b,long long &x,long long &y){ if(!b){ x=1,y=0;return a; } long long g=exgcd(b,a%b,y,x); y=y-a/b*x; return g; }
inline void mod(long long &x,const long long &m){ (x>=m)&&(x-=m); }
inline int exCRT(long long a1,long long m1,long long a2,long long m2,long long &a,long long &m)//merge equations x=a1(mod m1), x=a2(mod m2), put the answer in x=a(mod m)
{
	long long x1,x2,c=a2-a1;
	long long g=exgcd(m1,m2,x1,x2);
	if(c%g) return 1;
	m=m1/g*m2;
	x1=(__int128)x1*(c/g)%m;
	mod(a=a1+(__int128)m1*x1%m,m);
	return 0;
}
```

## FFT

## FMT

subset prefix sum/delta

```cpp
inline void fmt(int n,int *A,int type)
{
	for(int l=2;l<=(1<<n);l<<=1)
	{
		int mid=l>>1;
		for(int p=0;p<(1<<n);p+=l)
			for(int i=0;i<mid;i++)
				A[p+mid+i]=A[p+mid+i]+type*A[p+i];//+ can be replaced by the operator you want
	}
}
```

subset suffix sum/delta

```cpp
inline void fmt(int n,int *A,int type)
{
	for(int l=2;l<=(1<<n);l<<=1)
	{
		int mid=l>>1;
		for(int p=0;p<(1<<n);p+=l)
			for(int i=0;i<mid;i++)
				A[p+mid+i]=A[p+mid+i]+type*A[p+i];//+ can be replaced by the operator you want
	}
}
```

for maximum and/or sum

for minimum and/or sum

## Gauss-Jordan Elimination

liner equations

```cpp
const int N=502;
const double eps=1e-4;//maybe you should change this

inline double abs(double x){ return x<0?-x:x; }
inline void swap(double &x,double &y){ double t=x;x=y;y=t; }
inline void swap(bool &x,bool &y){ x^=y^=x^=y; }

inline int Gauss(int n,int **a)//0: exactly one solution, 1: infinity solutions, 2: no solution; the solution is {x_i=a[i][0]/a[i][i]} for i=1 to n
{
	static bool used[N];
	memset(used,0,sizeof(bool)*(n+2));
	for(int k=1;k<=n;k++)
	{
		int p=0;
		for(int i=1;i<=n;i++) if(!used[i]&&abs(a[i][k])>eps&&(!p||a[i][k]>a[p][k])) p=i;
		if(!p) continue;
		used[p]=1;
		double coe=1/a[p][k];
		swap(used[p],used[k]);
		for(int i=0;i<=n;i++) a[p][i]*=coe,swap(a[p][i],a[k][i]);
		for(int i=1;i<=n;i++)
		{
			if(i==k||abs(a[i][k])<eps) continue;
			coe=1/a[i][k];
			for(int j=0;j<=n;j++) a[i][j]=a[i][j]*coe-a[k][j];
		}
	}
	bool flag=0;
	for(int i=1;i<=n;i++) if(abs(a[i][i])<eps){ flag=1; if(abs(a[i][0])>eps) return 2; }
	return flag;
}
```

matrix inversion(modular)

```cpp

```

determinant(modular)

```cpp
const int N=602;
inline int det(int n,int a[N][N])
{
	int ans=1;
	for(int k=1;k<=n&&ans;ans=(long long)ans*a[k][k]%P,k++)
		for(int i=k+1;i<=n;i++)
		{
			int x=k,y=i,coe,cnt=0;
			while(a[y][k]){ coe=a[x][k]/a[y][k]; for(int j=1;j<=n;j++) a[x][j]=(a[x][j]+(long long)(P-coe)*a[y][j])%P; swap(x,y); }//a[i][j]<P must be held
			if(!a[k][k]){ ans=P-ans; for(int j=1;j<=n;j++) swap(a[x][j],a[y][j]); }
		}
	return ans;
}
```

## Hash Table

static

```cpp
struct HashTable//map int to T
{
#define T int//int can be replaced by the class you want
#define T_0 0//0 can be replaced by the zero item of T
	inline unsigned long long xor64(){ static unsigned long long x=19260817; return x^=x<<13,x^=x>>17,x^=x<<7; }
	inline int abs(int x){ return x<0?-x:x; }
	const int M=1000003;//good primes: 1009, 10007, 100003, 1000003, 10000019
	int a[M];bool used[M];
	T b[M];
	int m,c1,c2,c3,c4;
	inline HashTable(){ c1=xor64()%(M-1)+1,c2=xor64()%(M-1)+1,c3=xor64()%(M-1)+1,c4=xor64()%(M-1)+1; }
	inline int hash(const int &x,const int &t){ return ((long long)c1*x+c2+t*(((long long)c3*x%m+c4)%(m-1)+1))%m; }
	//insert: negtive integer means key exists, and its abs is the position; find: -1 means key doesn't exist; erase: 0 means successful erased, -1 means key doesn't exist
	inline int insert(int x,T y){ if((size+1)*2+1>m) resize((size*2+1)*2+1); int p=hash(x,0),t=0; while(used[p]&&a[p]!=x) p=hash(x,++t); if(a[p]==x) return -p; used[p]=1,a[p]=x,b[p]=y,size++; return p; }
	inline int find(int x){ int p=hash(x,0),t=0; while(used[p]&&a[p]!=x) p=hash(x,++t); if(a[p]==x) return p; return -1; }
	inline int erase(int p){ return find(p)==-1?-1:used[find(p)]=0; }
	inline int& operator [] (int x){ return b[abs(insert(x,T_0))]; }
#undef T
#undef T_0
}h;
```

dynamic

```cpp
struct HashTable//map int to T
{
#define T int//int can be replaced by the class you want
#define T_0 0//0 can be replaced by the zero item of T
	inline void swap(int *&x,int *&y){ int *t=x;x=y;y=t; }
	inline void swap(bool *&x,bool *&y){ bool *t=x;x=y;y=t; }
	inline unsigned long long xor64(){ static unsigned long long x=19260817; return x^=x<<13,x^=x>>17,x^=x<<7; }
	inline bool is_prime(int x){ if(x==1) return 0; for(int i=2;i*i<=x;i++) if(x%i==0) return 0; return 1; }
	inline int abs(int x){ return x<0?-x:x; }
	//inline void swap(T *&x,T *&y){ T *t=x;x=y;y=t; }//if T is not int, this should be used
	int *a;bool *used;
	T *b;
	int m,c1,c2,c3,c4;
	int size;
	inline HashTable(){ a=NULL,b=NULL,used=NULL;  }
	inline int hash(const int &x,const int &t){ return ((long long)c1*x+c2+t*(((long long)c3*x%m+c4)%(m-1)+1))%m; }
	inline int _insert(int x,T y){ int p=hash(x,0),t=0; while(used[p]&&a[p]!=x) p=hash(x,++t); if(a[p]==x) return -p; used[p]=1,a[p]=x,b[p]=y; return p; }
	inline void resize(int n){ int last=m;m=n+!(n&1); while(!is_prime(m)) m+=2; int *ta=new int[m];T *tb=new T[m];bool *tused=new bool[m]; memset(tused,0,sizeof(bool)*m);swap(ta,a),swap(tb,b),swap(tused,used); c1=xor64()%(m-1)+1,c2=xor64()%(m-1)+1,c3=xor64()%(m-1)+1,c4=xor64()%(m-1)+1; for(int i=0;i<last;i++) if(tused[i]) _insert(ta[i],tb[i]); if(ta!=NULL) delete []ta,delete []tb,delete []tused; }
	//insert: negtive integer means key exists, and its abs is the position; find: -1 means key doesn't exist; erase: 0 means successful erased, -1 means key doesn't exist
	inline int insert(int x,T y){ if((size+1)*2+1>m) resize((size*2+1)*2+1); int p=hash(x,0),t=0; while(used[p]&&a[p]!=x) p=hash(x,++t); if(a[p]==x) return -p; used[p]=1,a[p]=x,b[p]=y,size++; return p; }
	inline int find(int x){ int p=hash(x,0),t=0; while(used[p]&&a[p]!=x) p=hash(x,++t); if(a[p]==x) return p; return -1; }
	inline int erase(int p){ return find(p)==-1?-1:used[find(p)]=0; }
	inline int& operator [] (int x){ return b[abs(insert(x,T_0))]; }
#undef T
#undef T_0
}h;
```

## Heaps

All heaps here is minimum heap. Want maximum heap? Change < to > or just overload operator <.

Binary Heap: push, pop, top.

```cpp
inline void swap(int &x,int &y){ x^=y^=x^=y; }
const int N=1000002;
struct Heap
{
#define T int
	T a[N];
	int cnt=0;
	#define lq(u) ((u)<<1)
	#define rq(u) ((u)<<1|1)
	#define fa(u) ((u)>>1)
	inline T top(){ return a[1]; }
	inline void up(int u){ for(;u>1&&a[fa(u)]>a[u];u=fa(u)) swap(a[fa(u)],a[u]); }
	inline void down(int u){ for(;lq(u)<=cnt&&(a[lq(u)]<a[u]||(rq(u)<=cnt&&a[rq(u)]<a[u]));) (rq(u)<=cnt&&a[rq(u)]<a[lq(u)])?(swap(a[u],a[rq(u)]),u=rq(u)):(swap(a[u],a[lq(u)]),u=lq(u)); }
	inline void push(T x){ a[++cnt]=x; up(cnt); }
	inline void pop(){ swap(a[1],a[cnt]),cnt--; down(1); }
	inline bool empty(){ return !cnt; }
#undef T
	#undef lq
	#undef rq
	#undef fa
}q;
```

Skew Heap: merge, push, erase(iterator), pop, top. Never used, maybe correct?

```cpp
const int N=1000002;
#define T int
struct Node{ T v;int lq,rq;bool del; Node(){ v=0x3f3f3f3f,lq=rq=0,del=0; } }t[N];
int ncnt;
inline int new_node(int _v=0x3f3f3f3f){ return t[++ncnt]={_v,0,0,0},ncnt; }
#define lq(u) t[u].lq
#define rq(u) t[u].rq
inline int merge(int u,int v)
{
	if(!u||!v) return u|v;
	if(t[u].v>t[v].v) swap(u,v);
	return rq(u)=merge(rq(u),v),swap(lq(u),rq(u)),u;
}
inline int push(int rt,T v){ int p=new_node(v); return merge(rt,p),p; }
inline void erase(int u){ t[u].del=1; }
inline T top(int &rt){ while(t[rt].del) rt=merge(lq(rt),rq(rt)); return t[rt].v; }
inline void pop(int &rt){ top(rt),rt=merge(lq(rt),rq(rt)); }
#undef T
#undef lq
#undef rq

int rt[N];
```

Leftist Tree(just some modify on function merge). Never used, maybe correct?

```cpp
const int N=1000002;
#define T int
struct Node{ T v;int lq,rq,dis;bool del; Node(){ v=0x3f3f3f3f,lq=rq=0,dis=1,del=0; } }t[N];
int ncnt;
inline int new_node(int _v=0x3f3f3f3f){ return t[++ncnt]={_v,0,0,1,0},ncnt; }
#define lq(u) t[u].lq
#define rq(u) t[u].rq
inline int merge(int u,int v)
{
	if(!u||!v) return u|v;
	if(t[u].v>t[v].v) swap(u,v);
	rq(u)=merge(rq(u),v);
	if(t[lq(u)].dis<t[rq(u)].dis) swap(lq(u),rq(u));
	return t[u].dis=t[rq(u)].dis+1,u;
}
inline int push(int rt,T v){ int p=new_node(v); return merge(rt,p),p; }
inline void erase(int u){ t[u].del=1; }
inline T top(int &rt){ while(t[rt].del) rt=merge(lq(rt),rq(rt)); return t[rt].v; }
inline void pop(int &rt){ top(rt),rt=merge(lq(rt),rq(rt)); }
#undef T
#undef lq
#undef rq

int rt[N];
```

## K-d Tree

2-dt(static)

```cpp
inline int max(const int x,const int y){ return x>y?x:y; }
inline int min(const int x,const int y){ return x<y?x:y; }

struct Point{ int x,y,val; }p[500002];
inline bool cmpx(Point x,Point y){ return x.x<y.x; }
inline bool cmpy(Point x,Point y){ return x.y<y.y; }

struct Node{ int xl,xr,yl,yr,sum; }t[1000002];
#define lq(u) ((u)<<1)
#define rq(u) ((u)<<1|1)

inline void push_up(int u){ t[u].sum=t[lq(u)].sum+t[rq(u)].sum; }
void build(int l,int r,int u,bool d)
{
	if(l==r){ t[u].xl=t[u].xr=p[l].x,t[u].yl=t[u].yr=p[l].y,t[u].sum=p[l].val;return; }
	int mid=l+r>>1;
	nth_element(p+l,p+mid,p+r+1,d?cmpx:cmpy);
	build(l,mid,lq(u),!d),build(mid+1,r,rq(u),!d);
	t[u].xl=min(t[lq(u)].xl,t[rq(u)].xl);
	t[u].yl=min(t[lq(u)].yl,t[rq(u)].yl);
	t[u].xr=max(t[lq(u)].xr,t[rq(u)].xr);
	t[u].yr=max(t[lq(u)].yr,t[rq(u)].yr);
	push_up(u);
}
int query(const int xl,const int xr,const int yl,const int yr,int u)
{
	if(xr<t[u].xl||t[u].xr<xl||yr<t[u].yl||t[u].yr<yl) return 0;
	if(xl<=t[u].xl&&t[u].xr<=xr&&yl<=t[u].yl&&t[u].yr<=yr) return t[u].sum;
	return query(xl,xr,yl,yr,lq(u))+query(xl,xr,yl,yr,rq(u));
}
```

## KMP

```cpp
inline void kmp(int m,char *s,int *fail)
{
	for(int i=2,j=0;i<=n;i++)
	{
		while(j&&s[i]!=s[j+1]) j=fail[j];
		if(s[i]==s[j+1]) j++;
		fail[i]=j;
	}
}
inline void match(int n,int m,char *t,char *s,int *fail,int *ans)//find t in s
{
	for(int i=1,j=0;i<=n;i++)
	{
		while(j&&t[i]!=s[j+1]) j=fail[j];
		if(t[i]==s[j+1]) j++;
		ans[i]=j;
	}
}
```

## Kosaraju

```cpp
const int N=10002,M=100002;

struct Edge{ int v,next; bool type; }e[M<<1];
int ecnt,h[N];
inline void add_edge(int u,int v){ e[++ecnt]={v,h[u],1},h[u]=ecnt;e[++ecnt]={u,h[v],0},h[v]=ecnt; }

int dfa[N],dcnt,c[N],ccnt;//dfa: dfs array, c: SCC which the node belongs to
bool vis[N];
vector<int> v[N];//nodes of each SCC
void dfs1(int u){ vis[u]=1; for(int i=h[u];i;i=e[i].next) if(e[i].type&&!vis[e[i].v]) dfs1(e[i].v); dfa[++dcnt]=u; }
void dfs2(int u,int _c){ c[u]=_c,v[_c].push_back(u); for(int i=h[u];i;i=e[i].next) if(!e[i].type&&!c[e[i].v]) dfs2(e[i].v,_c); }
inline void Kosaraju(int n)
{
	for(int i=1;i<=n;i++) if(!vis[i]) dfs1(i);
	for(int i=n;i>=1;i--) if(!c[dfa[i]]) dfs2(dfa[i],++ccnt);
}
```

## Kruskal

If you want to do something on the MST, try Kruskal Reconstruction Tree or just add a add_edge() to this code.

```cpp
const int N=100002,M=1000002;

struct Tuple{ int u,v,w; }t[M];
int tcnt;
inline void add_tuple(int u,int v,int w){ t[++tcnt]={u,v,w}; }
inline bool cmp(const Tuple &x,const Tuple &y){ return x.w>y.w; }

int f[N];
int find(int x){ return x==f[x]?x:f[x]=find(f[x]); }
inline void merge(int x,int y){ f[find(x)]=find(y); }
inline void init(){ for(int i=1;i<=(n<<1)-1;i++) f[i]=i; }

inline long long kru(int n,int m,Tuple *t)//get weight sum of the mst
{
	init();
	sort(t+1,t+tcnt+1,cmp);
	long long ans=0;
	for(int i=1,cnt=0;i<=m&&cnt<n;i++)
		if(find(t[i].u)!=find(t[i].v)) merge(t[i].u,t[i].v),ans+=t[i].w;
	return ans;
}
```

## Kruskal Reconstruction Tree

Maybe you should put this in a namespace named Kru.

```cpp
const int N=100002,M=1000002;

struct Tuple{ int u,v,w; }t[M];
int tcnt;
inline void add_tuple(int u,int v,int w){ t[++tcnt]={u,v,w}; }
inline bool cmp(const Tuple &x,const Tuple &y){ return x.w>y.w; }

int f[N<<1];
int find(int x){ return x==f[x]?x:f[x]=find(f[x]); }
inline void merge(int x,int y){ f[find(x)]=find(y); }
inline void init(){ for(int i=1;i<=(n<<1)-1;i++) f[i]=i; }

int lq[N<<1],rq[N<<1],w[N<<1];
inline void kru(int n,int m,Tuple *t)
{
	init();
	sort(t+1,t+tcnt+1,cmp);
	for(int i=1,cnt=0;i<=m&&cnt<n;i++)
		if(find(t[i].u)!=find(t[i].v))
		{
			cnt++;
			int now=n+ncnt;
			w[now]=t[i].w;
			lq[now]=find(t[i].u),rq[now]=find(t[i].v);
			fa[0][find(t[i].u)]=fa[0][find(t[i].v)]=now;
			merge(t[i].u,now),merge(t[i].v,now);
		}
}
```

## LCT

```cpp
const int N=100002;
struct LCT
{
	struct Node{ int q[2],fa,val,rev; }t[N];
	
	#define q(u,x) t[u].q[x]
	#define fa(u) t[u].fa
	//push_up and push_down should be changed in different problems
	inline void push_up(int u){ t[u].val=t[q(u,0)].val^t[q(u,1)].val^v[u]; }
	inline void add_rev(int u){ swap(q(u,0),q(u,1)),t[u].rev^=1; }
	inline void push_down(int u){ if(t[u].rev) add_rev(q(u,0)),add_rev(q(u,1)),t[u].rev=0; }
	inline bool is_top(int u){ return q(fa(u),0)!=u&&q(fa(u),1)!=u; }
	void push_downs(int u){ if(!is_top(u)) push_downs(fa(u));push_down(u); }
	inline int get(int u){ return q(fa(u),1)==u; }
	inline void rotate(int u)
	{
		int v=fa(u),w=fa(v),a=get(u),b=get(v);
		if(!is_top(v)) q(w,b)=u;
		fa(u)=w;
		q(v,a)=q(u,!a),fa(q(u,!a))=v;
		q(u,!a)=v,fa(v)=u;
		push_up(v),push_up(u);
	}
	inline void splay(int u)
	{
		push_downs(u);
		for(int v;!is_top(u);)
		{
			v=fa(u);
			if(!is_top(v))
				if(get(u)!=get(v)) rotate(u);
				else rotate(v);
			rotate(u);
		}
	}
	inline int access(int u)
	{
		int v=0;
		for(;u;v=u,u=fa(u)) splay(u),q(u,1)=v,push_up(u);
		return v;
	}
	inline void make_root(int u){ access(u),splay(u),add_rev(u); }
	inline int find_root(int u){ access(u),splay(u);while(q(u,0)) u=q(u,0);return splay(u),u; }
	inline void split(int u,int v){ make_root(u),access(v),splay(v); }
	inline void link(int u,int v){ make_root(u),fa(u)=v; }
	inline void cut(int u,int v){ split(u,v);if(q(v,0)==u&&q(u,1)==0) q(v,0)=fa(u)=0; }
	
	inline void change(int u,int val){ splay(u),v[u]=val,push_up(u); }//change node u's value
	inline int query(int u,int v){ split(u,v);return t[v].val; }//chain query
};
```

## Li-Chao Tree

minimum

```cpp
struct Function{ long long k,b; inline long long operator () (int x){ return k*x+b; } }null;
inline void swap(Function &x,Function &y){ Function t=x;x=y;y=t; }
inline long long min(long long x,long long y){ return x<y?x:y; }

const int N=1000002;
struct Node{ int l,r; Function f; }t[4*N];
#define lq(u) ((u)<<1)
#define rq(u) ((u)<<1|1)

inline void build(int l,int r,int u){ t[u].l=l,t[u].r=r,t[u].f=null; if(l==r) return; int mid=(l+r)>>1; build(l,mid,lq(u)),build(mid+1,r,rq(u)); }
void change(Function f,int u){ int mid=(t[u].l+t[u].r)>>1; if(f(mid)<t[u].f(mid)) swap(f,t[u].f); if(t[u].l==t[u].r) return; if(f(t[u].l)<t[u].f(t[u].l)) change(f,lq(u)); if(f(t[u].r)<t[u].f(t[u].r)) change(f,rq(u)); }
long long query(int x,int u){ if(!u) return 0x3f3f3f3f3f3f3f3f; if(t[u].l==t[u].r) return t[u].f(x); int mid=(t[u].l+t[u].r)>>1; return min(t[u].f(x),query(x,(x<=mid)?lq(u):rq(u))); }
```

for maximum, just change < to > and min to max, or overload operator <.

## List

```cpp
#define List std::list
```

But std::list is hard to use, there is my code, never used, maybe correct?

```cpp
struct List
{
	struct Node{ T v; Node *pre,*nxt; };
	Node *head,*tail;
	List(){ head=tail=new Node(); tail->v=T_0,head->nxt=tail,tail->pre=head; }
	inline Node* begin(){ return head; }
	inline Node* end(){ return tail; }
	inline Node* insert(T _v,Node *p){ Node* u=new Node(); u->v=_v,u->pre=p,u->nxt=p->nxt,p->nxt->pre=u,p->nxt=u; return u; }
	inline void erase(Node *u){ u->pre->nxt=u->nxt,u->nxt->pre=u->pre; delete u; }
};
```

## Manacher

## Merge Sort

## NTT

我一看，为什么现在的法法塔不用rev了?

哦原来是什么转置原理。懂了。

```cpp
const int P=998244353,g=3;
inline int pow(int a,int n){ int c=1; for(;n;n>>=1,a=(long long)a*a%P) if(n&1) c=(long long)c*a%P; return c; }
const int inv_g=pow(g,P-2);
inline void mod(int &x){ if(x>=P) x-=P; }

int W[1<<21],inv_W[1<<21];
inline void init(int n){ for(int i=1,c=1,Wn,inv_Wn;i<n;i<<=1,c++){ W[i]=inv_W[i]=1,Wn=pow(g,(P-1)>>c),inv_Wn=pow(inv_g,(P-1)>>c); for(int j=1;j<i;j++) W[i+j]=(long long)W[i+j-1]*Wn%P,inv_W[i+j]=(long long)inv_W[i+j-1]*inv_Wn%P; } }
inline void dft(int n,int *A){ for(int l=n>>1,x,y;l;l>>=1) for(int p=0;p<n;p+=(l<<1)) for(int i=0;i<l;i++) x=A[p+i],y=A[p+l+i],mod(A[p+i]=x+y),A[p+l+i]=(long long)(x-y+P)*W[l+i]%P; }
inline void idft(int n,int *A){ for(int l=1,x,y;l<n;l<<=1) for(int p=0;p<n;p+=(l<<1)) for(int i=0;i<l;i++) x=A[p+i],y=(long long)inv_W[l+i]*A[p+l+i]%P,mod(A[p+i]=x+y),mod(A[p+l+i]=x-y+P); for(int i=0,inv_n=pow(n,P-2);i<n;i++) A[i]=(long long)A[i]*inv_n%P; }
```

## PAM

## Poly

反正OI又用不到这个，不需要背，我就写能写出来的最快的了（

loj #150 挑战多项式

dfs/idft 1E(n), mul 6E(n), inv 10E(n), ln/div 13E(n), sqrt 24E(n), exp 30E(n), pow 44E(n)

```cpp
#include<stdio.h>
#include<string.h>

inline int min(int x,int y){ return x<y?x:y; }
inline void swap(int &x,int &y){ x^=y^=x^=y; }

const int N=262144;

const int P=998244353,g=3,inv_2=(P+1)/2;
inline void mod(int &x){ (x>=P)&&(x-=P); }
inline int pow(int a,int n){ int c=1; for(;n;n>>=1,a=(long long)a*a%P) if(n&1) c=(long long)c*a%P; return c; }
const int inv_g=pow(g,P-2);

namespace Cipolla//modular square root
{

int w;
struct N{ int a,b; };
inline N operator * (const N &x,const N &y){ return {((long long)x.a*y.a+(long long)w*x.b%P*y.b)%P,((long long)x.a*y.b+(long long)x.b*y.a)%P}; }
inline int pow(N a,int n){ N c={1,0}; for(;n;n>>=1,a=a*a) if(n&1) c=c*a; return c.a; }
inline bool check(int x){ return pow({x,0},(P-1)>>1)==1; }
inline unsigned long long xor64(){ static unsigned long long x=19260817; return x^=x<<13,x^=x>>17,x^=x<<7; }
inline int sqrt(int n)
{
	if(!n) return 0;
	int a=xor64()%P,ans; while(!a||check(((long long)a*a-n+P)%P)) a=xor64()%P;
	w=((long long)a*a-n+P)%P,ans=pow({a,1},(P+1)>>1); return min(ans,P-ans);
}

}

namespace Poly
{

//contain dft/idft, deriv/integ, 6E(n) mul, 10E(n) inv, 13E(n) div/ln
//input and output array can't be the same

int fac[N],inv_fac[N],inv_i[N];
int W[N],inv_W[N];

struct Init{
	inline Init(int n=N)
	{
		for(int i=1,c=1,Wn,inv_Wn;i<n;i<<=1,c++)
		{
			W[i]=inv_W[i]=1,Wn=pow(g,(P-1)>>c),inv_Wn=pow(inv_g,(P-1)>>c);
			for(int j=1;j<i;j++)
				W[i+j]=(long long)W[i+j-1]*Wn%P,inv_W[i+j]=(long long)inv_W[i+j-1]*inv_Wn%P;
		}
		for(int i=1;i<=n;i++) inv_i[i]=pow(i,P-2);
	}
}_init;

inline void dft(int n,int *A)
{
	for(int l=n>>1,x,y;l;l>>=1)
		for(int p=0;p<n;p+=(l<<1))
			for(int i=0;i<l;i++)
				x=A[p+i],y=A[p+l+i],mod(A[p+i]=x+y),A[p+l+i]=(long long)(x-y+P)*W[l+i]%P;
}
inline void idft(int n,int *A)
{
	for(int l=1,x,y;l<n;l<<=1)
		for(int p=0;p<n;p+=(l<<1))
			for(int i=0;i<l;i++)
				x=A[p+i],y=(long long)inv_W[l+i]*A[p+l+i]%P,mod(A[p+i]=x+y),mod(A[p+l+i]=x-y+P);
	for(int i=0,inv_n=pow(n,P-2);i<n;i++) A[i]=(long long)A[i]*inv_n%P;
}

inline void mul(int n,int *A,int *B,int *C){ static int T1[N],T2[N]; memcpy(T1,A,sizeof(int)*n),memcpy(T2,B,sizeof(int)*n),dft(n,T1),dft(n,T2); for(int i=0;i<n;i++) C[i]=(long long)T1[i]*T2[i]%P; idft(n,C); }

inline void inv(int n,int *A,int *B)//10E(n), calc B=1/A
{
	static int T[N],TB[N];
	memset(B,0,sizeof(int)*n),memset(TB,0,sizeof(int)*n),B[0]=pow(A[0],P-2);
	for(int l=2,mid=1;l<=n;l<<=1,mid<<=1)
	{
		memcpy(T,A,sizeof(int)*l);
		memcpy(TB,B,sizeof(int)*mid);
		memset(B+mid,0,sizeof(int)*mid);
		dft(l,B),dft(l,T);
		for(int i=0;i<l;i++) T[i]=(long long)B[i]*T[i]%P;
		idft(l,T);
		memset(T,0,sizeof(int)*mid);
		dft(l,T);
		for(int i=0;i<l;i++) T[i]=(long long)B[i]*T[i]%P;
		idft(l,T);
		memcpy(B,TB,sizeof(int)*l);
		for(int i=mid;i<l;i++) B[i]=T[i]?P-T[i]:0;
	}
}

inline void deriv(int n,int *A){ for(int i=0;i<n;i++) A[i]=(long long)A[i+1]*(i+1)%P; A[n-1]=0; }
inline void integ(int n,int *A){ for(int i=n-1;i>0;i--) A[i]=(long long)A[i-1]*inv_i[i]%P; A[0]=0; }

inline void div(int n,int *A,int *B,int *C)//13E(n)(inv 5E(n)+fft 8E(n)), calc C=A/B
{
	static int A0[N],TA[N],TB[N],B0[N],T[N];
	int mid=n>>1;
	
	inv(mid,B,T),memcpy(B0,T,sizeof(int)*mid);
	dft(n,T),dft(n,B0);
	for(int i=0;i<n;i++) T[i]=(long long)T[i]*B0[i]%P;
	idft(n,T),memset(T+mid,0,sizeof(int)*mid);
	
	memcpy(C,T,sizeof(int)*mid),memcpy(TB,B,sizeof(int)*n);
	dft(n,T),dft(n,TB);
	for(int i=0;i<n;i++) T[i]=(long long)T[i]*TB[i]%P;
	idft(n,T),memset(T,0,sizeof(int)*mid);
	for(int i=mid;i<n;i++) mod(T[i]+=P-A[i]);
	dft(n,T);
	for(int i=0;i<n;i++) T[i]=(long long)T[i]*B0[i]%P;
	idft(n,T);
	for(int i=mid;i<n;i++) mod(C[i]+=P-T[i]);
}

inline void ln(int n,int *A,int *B){ static int T[N]; memcpy(T,A,sizeof(int)*n),deriv(n,T),div(n,T,A,B),integ(n,B); }

}

int n,A[N],B[N];

int main()
{
	scanf("%d",&n);
	for(int i=0;i<n;i++) scanf("%d",&A[i]);
	int l=1024;
	while(l<=(n<<1)) l<<=1;
	Poly::ln(l,A,B);
	for(int i=0;i<n;i++) printf("%d ",B[i]);
	return 0;
}
```

这里专门介绍一下牛顿迭代的常数优化吧。摘抄自negiizhao的blog。

-----

记号

长度$$n$$总是某个$$2^k$$。

$$\mathrm{E}(n)$$表示做长度为$$n$$的dft的时间。显然有$$\mathrm{E}(2n)=2\mathrm{E}(n)+O(n)$$，一般来说线性的部分我们可以忽略。

$$\mathrm{M}(n)$$表示做长度为$$n$$的普通卷积(答案长度是$$2n$$)的时间，有$$\mathrm{M}(n)=6\mathrm{E}(n)+O(n)$$。

$$\mathcal{F}_l(F)$$表示$$F$$的长度为$$l$$的dft。

-----

先补一点前置知识

我对多项式取模没什么感觉。可以结合线性递推来理解它。

比如说我们要求斐波那契数$$f_n$$，做法是把$$f_n$$展开变成$$f_{n-1}+f_{n-2}$$，然后把$$f_{n-1}$$展开变成$$f_{n-2}+f_{n-3}$$，不停展开最高次项，直到只剩下$$f_0$$和$$f_1$$。

你发现这个事情很好玩，它实际上是一个类似于竖式除法的过程，我们每次消掉最高的项。更进一步地，我们实际上是在用斐波那契数的特征多项式$$z^2-z-1$$去除$$z^n$$。

所以说，对一个多项式取模，实际上是描述了每一项对低次一些的项的贡献。把这个除数多项式的最高次项系数变为$$-1$$，后面的系数就直接变成了贡献的系数。

-----

倒数 inv

要求$$G=\frac{1}{F}$$，朴素的迭代式是$$G\equiv G_0-(FG_0-1)G_0\equiv 2G_0-FG_0^2\pmod{z^{2n}}$$。

直接做，每轮需要$$\mathrm{M}(n)$$计算$$G_0^2$$，$$\mathrm{M}(2n)$$计算$$FG_0^2$$，总共就是$$18\mathrm{E}(n)$$。这是等比数列求和，所以总的还是$$18\mathrm{E}(n)$$(为什么不是$$36$$?因为我们最后一次是从$$\frac{n}{2}$$迭代到$$n$$)。

考虑$$G\equiv G_0-(FG_0-1)G_0\pmod{z^{2n}}$$这个式子，注意到$$(F\bmod{z^{2n}})G_0-1$$的长度是在$$3n$$以内的，并且它的$$0$$到$$n-1$$次项必然是$$0$$，所以我们实际上可以用长度为$$2n$$的循环卷积计算这个东西，循环卷积中溢出的部分恰好是$$0$$到$$n-1$$次，我们把这一段清零即可。

同理，$$((FG_0-1)\bmod{z^{2n}})G_0$$的长度是在$$3n$$以内的，它的$$0$$到$$n-1$$次项也必然是$$0$$，所以也只需要长度为$$2n$$的循环卷积。这样总共需要$$6\mathrm{E}(2n)=12\mathrm{E}(n)$$。

注意到其中有两次对$$G_0$$的长度为$$2n$$的dft，可以省略一次，总共是$$10\mathrm{E}(n)$$。

-----

除法/对数 div/ln

给$$F,H$$，$$G=1/H$$，要求$$Q=\frac{H}{F}=HG$$。对数和除法只差$$O(n)$$。

直接做就是$$10\mathrm{E}(n)$$求出$$G$$，然后硬乘，总共是$$16\mathrm{E}(n)$$。

考虑用牛迭展开$$Q\bmod{z^{2n}}$$，有$$Q\equiv Q_0-(FQ_0-H)G_0\pmod{z^{2n}}$$。

可以用上面的倒数，$$10\mathrm{E}(n)$$求出$$G_0$$，然后用$$6\mathrm{E}(n)$$求出$$Q_0\equiv H_0G_0\pmod{z^n}$$。

然后两次乘法的性质和倒数基本相同，用倒数中的方法$$12\mathrm{E(n)}$$即可计算$$(FQ_0-H)G_0$$。总共是$$28\mathrm{E}(n)$$。具体地，$$(F\bmod{z^{2n}})Q_0-H$$长度不超过$$3n$$，阶至少是$$n$$，所以可以用循环卷积计算，$$(((F\bmod{z^{2n}})Q_0-H)\bmod{z^{2n}})G_0$$是一样的。

注意到我们求$$Q_0$$的时候已经对$$G_0$$做了长为$$2n$$的dft，所以可以省去一次，变成$$26\mathrm{E}(n)$$，于是做长度为$$n$$的除法就需要$$13\mathrm{E}(n)$$。

-----

平方根 sqrt

给$$F$$，求$$G^2=F$$。

令$$H=\frac{1}{G}$$，迭代式为$$G\equiv G_0-\frac{G_0^2-F}H_0{2}\pmod{z^{2n}}$$。

直接做就是每轮一次$$10\mathrm{E}(n)$$的倒数，然后需要$$\mathrm{M}(n)+\mathrm{M}(2n)$$的乘法，总共是$$28\mathrm{E}(n)$$。

考虑一个牛逼做法，我们牛迭算$$H_0$$，它满足方程$$FH^2-1=0$$，迭代式为$$H\equiv H_0-\frac{FH_0^3-H_0}{2}\pmod{z^{2n}}$$。注意到$$FH_0^3-H_0$$的长度不超过$$5n$$，阶至少是$$n$$，可以用长度为$$4n$$的循环卷积计算，需要$$12\mathrm{E}(n)$$。于是算$$H\bmod{z^n}$$总共需要$$12\mathrm{E}(n)$$。这一步同时搞定了$$\mathcal{F}_{2n}(F\bmod{z^n})$$。

然后还是使用$$G$$的迭代式$$G\equiv G_0-\frac{G_0^2-F}H_0{2}\pmod{z^{2n}}$$。

容易知道$$G_0=FH_0$$，而前面算了$$\mathcal{F}_{2n}(F\bmod{z^n})$$，于是爆算是$$4\mathrm{E}(n)$$的。这一步同时搞定了$$\mathcal{F}_{2n}(G_0),\mathcal{F}_{2n}(H_0)$$。

于是计算$$G_0^2$$只需要$$2\mathrm{E}(n)$$的idft。

注意到$$G_0^2-F$$的阶至少是$$n$$，于是计算$$(G_0^2-F)H_0$$可以做长$$2n$$的循环卷积，而我们已经拿到了$$\mathcal{F}_{2n}(H_0)$$，所以只需要$$4\mathrm{E}(n)$$。

这总共是$$22\mathrm{E}(n)$$的，于是长度为$$n$$的平方根需要$$11\mathrm{E}(n)$$。

-----

指数 exp

重头戏（

有些人的exp比别人的inv还快（

给$$F$$，求$$G=\exp F$$。

令$$H=\frac{1}{G}$$，直接做，迭代式为

$$
G\equiv G_0-G_0\left(\int G_0^\prime H_0-F\right)\pmod{z^{2n}}
$$

，调用一次除法，一次长$$4n$$的乘法，需要$$38\mathrm{E}(n)$$。不过如果你用爆力的方法，调用一次逆，一次长$$2n$$的乘法，一次长$$4n$$的乘法，会变成$$54\mathrm{E}(n)$$。

有一个简单方法可以做到$$16.5\mathrm{E}(n)$$。我看不懂论文哥在写啥，但是论文好像讲的还可以¿

![img](/img/2021-10-25-board/exp.png)

其中$$f=\exp(h),g=\frac{1}{f}$$。呃他在说什么?不知道（

首先还需要一点前置知识，也就是如果我们知道了$$\mathcal{F}_n$$，计算$$\mathcal{F}_{2n}$$只需要$$E(n)$$的时间，因为dft实际上是一组点值。我们考虑少了的那一部分，实际上只需要先代入一次本原单位根$$\omega_{2n}$$更新系数，然后做dft即可。最后把两边做一层dft合并起来，这是线性的。

我们来看伪代码。第一行，$$fg^2$$的

## Prime Sieves

只筛质数

```cpp
const int N=20000002;
bool b[N],prime[N/10],pcnt;
inline void sieve(int n){ for(int i=2;i<=n;i++){ if(!b[i]) prime[++pcnt]=i; for(int j=1;j<=pcnt;j++){ b[i*prime[j]]=1; if(!(i%prime[j])) break; } } }
```

常见积性函数($$\varphi,\mu,d,\mathrm{id}_k$$)

```cpp
const int N=20000002;
bool b[N],prime[N/10],pcnt;
int mu[N],phi[N],d[N];
inline void sieve(int n)
{
	mu[1]=phi[1]=d[1]=1;
	for(int i=2;i<=n;i++)
}
```

分段埃筛

## Queue

```cpp
const int N=2000002;
struct Queue{ int head,tail,q[N]; inline void clear(){ head=1,tail=0; } inline Queue(){ head=1,tail=0; } inline void push(int x){ q[++tail]=x; } inline void pop(){ head++; } inline int front(){ return q[head]; } inline bool empty(){ return head>tail; } };
```

## Quick Sort

```cpp
#define quick_sort sort
```

牛逼!

## SA

## SAM

## Simplex

## Simpson

```cpp
inline double f(double x){  }
inline double calc(double l,double r){ return (f(l)+f(r)+4*f((l+r)/2))*(r-l)/6; }
inline double simpson(double l,double r,double A,double eps)
{
	if(eps<1e-100){ fprintf(stderr,"Sorry, Simpson can't fuck it.\n");exit(0); }
	if(r-l<eps) return A;
	double mid=(l+r)/2;
	double L=calc(l,mid),R=calc(mid,r);
	if(fabs(L+R-A)<eps) return A;
	return simpson(l,mid,L,eps/2)+simpson(mid,r,R,eps/2);
}
```

## Segment Tree(Basic)

```cpp
const int N=200002;
struct Node{ int l,r; }t[4*N];
#define lq(u) ((u)<<1)
#define rq(u) ((u)<<1|1)
inline void push_up(int u){  }
inline void add_tag(int u){  }
inline void push_down(int u){ add_tag(lq(u),t[u].tag),add_tag(rq(u),t[u].tag),t[u].tag=0; }
void build(int l,int r,int u){ t[u].l=l,t[u].r=r;if(l==r){ ;return; }int mid=t[u].l+t[u].r>>1;build(l,mid,lq(u)),build(mid+1,r,rq(u)),push_down(u); }
void change(int l,int r,int u,int v){ if(l<=t[u].l&&t[u].r<=r){ add_tag(u,v);return; }int mid=t[u].l+t[u].r>>1;push_down(u);if(l<=mid) change(l,r,lq(u),v);if(mid+1<=r) change(l,r,rq(u),v);push_up(u); }
int query(int l,int r,int u){ if(l<=t[u].l&&t[u].r<=r) return;int mid=t[u].l+t[u].r>>1;push_down(u);return (l<=mid?query(l,r,lq(u):0))+(mid+1<=r?query(l,r,rq(u)):0); }
```

## SPFA

## Split-merge Treap

## ST Table

```cpp
const int N=200002;
int f[20][N],lg[N];
inline void init(int n,int *a){ for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1; for(int i=1;i<=n;i++) f[0][i]=a[i]; for(int k=1;k<=20;k++)for(int i=1;i<=n;i++) f[k][i]=min(f[k-1][i],f[k-1][i+(1<<k-1)]); }
inline int query(int l,int r){ int k=lg[r-l+1]; return min(f[k][l],f[k][r-(1<<k)+1]); }
```

## Stack

```cpp
const int N=2000002;
struct Stack{ int cnt,s[N]; inline void clear(){ cnt=0; } inline Stack(){ clear(); } inline void push(int x){ s[++cnt]=x; } inline void pop(){ cnt--; } inline int top(){ return s[cnt]; } inline bool empty(){ return !cnt; } };
```

## Stirling Numbers

$$O(n^2)$$，of the first kind



$$O(n\log n)$$，of the first kind



$$O(n^2)$$，of the second kind



$$O(n\log n)$$，of the second kind



## Subsequence AM

## Tarjan for DCC

## Union-find Set

路径压缩

```cpp
int f[N];
inline void clear(int n){ for(int i=1;i<=n;i++) f[i]=i; }
int find(int x){ return f[x]==x?x:f[x]=find(f[x]); }
inline void merge(int x,int y){ f[find(x)]=find(y); }
```

wrong 1 times/hanx

启发式合并

```cpp
const int N=2000002;
int f[N],size[N];
inline void clear(int n){ for(int i=1;i<=n;i++) f[i]=i,size[i]=1; }
inline int find(int x){ while(x!=f[x]) x=f[x]; return x; }
inline void merge(int x,int y){ if((x=find(x))!=(y=find(y))) size[x]>size[y]?f[y]=x:f[x]=y;  }
```

## Xor Liner Base

## Xorshift64

```cpp
inline unsigned long long xor64(){ static unsigned long long x=19260817; return x^=x<<13,x^=x>>17,x^=x<<7; }
```

## Z Algo

```cpp
inline void Z(int n,char *s,int *z)
{
	z[1]=n;
	for(int i=2,l=1,r=1;i<=n;i++)
	{
		if(i<=r) z[i]=min(z[i-l+1],r-i+1);
		while(i+z[i]<=n&&s[i+z[i]]==s[z[i]+1]) z[i]++;
		if(i+z[i]-1>r) r=i+z[i]-1,l=i;
	}
}
```

