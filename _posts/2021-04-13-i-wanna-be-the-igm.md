---
layout: post
title: IGM养成计划 题目整理
subtitle: 定个小目标，今年上Newbie
tags: 题选做 cf
---

打算今年上个IGM（

所以来刷穿CF了，选了Rating 2600+，按通过人数降序。

然而发现刷不穿，甚至完全做不动。那就多见点经典题吧!

如果真有人想看这个的话，请结合CF的题库来阅读，当然选和我一样的tag。

如果做法只有几个意义不明的字，说明这题太简单或者太经典。

-----

13E : 弹 飞 绵 羊

-----

321E : 题意不是很清晰。

考虑直接dp，设$$dp(i,j)$$表示前$$i$$个人上$$j$$条船的最小代价，枚举最后多少个人上了最后一条船就可以转移。复杂度是$$O(kn^2)$$，无法接受。

发现满足四边形不等式，所以可以使用决策单调性分治，复杂度降为$$O(kn\log n)$$，可以通过。

还可以wqs二分，优化到$$O(n\log n\log k)$$，不过没有必要。

-----

10D : L C I S

-----

3D : 上古场评分偏高?

考虑一开始全搞成 ) ，然后从左往右扫，遇到不合法也就是 ) 多于 ( 那就把一些 ) 换成 ( ，于是我们计算换的代价增量也就是$$a_i-b_i$$，然后开一个堆维护前面最小的代价就好了。注意无解的情况。

-----

455D : 平衡树。

考虑每种值开一棵平衡树，维护这个值的所有编号并按下标排序，那么每次查询就是找到一棵树的一个区间，修改就是把最后一位的数拿出来重新插入到正确位置(其它的相对位置不会改变)。

发现并不容易维护查询所需的下标。我们可以考虑另开一棵平衡树维护编号——下标的对应关系，那么每次修改就是在这棵树上拿出来一个元素并重新插入，查询就是查rank。可以使用你喜欢的平衡树，复杂度是$$O(n+q\log^2 n)$$。

使用分块，可以获得小得多的代码复杂度。

-----

622F : 拉插板子。

-----

1344C : 好题。

先建图，从大的连向小的。

发现如果有$$i<j$$并且$$i,j$$有边，不妨假设$$x_i<x_j$$，那么我们可以填$$\forall x_i,\exists x_j,x_i<x_j$$或者$$\exists x_i,\exists x_j,x_i<x_j$$，但是不能填$$\forall x_i,\forall x_j,x_i<x_j$$或者$$\exists x_i,\forall x_j,x_i<x_j$$。$$x_i>x_j$$同理。

所以得到做法 : 一个点可以填$$\forall$$，当且仅当所有和它有偏序关系的点，也就是它能到达的和能到达它的点，编号都比它大。

怎么求这样的点?实际上我们可以只求出来最小的，这个可以记搜搞定。

-----

631E : 简单题。

枚举每个数，考虑把它移到哪里去。

显然要对往前往后分开讨论，我们不妨先考虑往前。

发现中间那些数的贡献可以用前缀和简单表示出来，如果我们把$$i$$移动到$$j$$，那么价值变化量是$$(i-j)a_i+s_{i-1}-s_{j-1}$$，拆开得到$$ia_i+s_{i-1}-s_{j-1}-ja_i$$，去掉与$$j$$无关的项，发现是一个关于$$a_i$$的一次函数，可以用李超树维护。反着是类似的。

-----

1325E : 妙题。

每个数的因数个数不超过7，说明什么?

质因数个数不超过$$2$$。我们先给所有次数模$$2$$，然后建一张图，每条边连接每个数的两个质因数。这样一个环就表示一个方案。

只有一个质因数怎么办?可以连向$$1$$。

然后就变成了无向无权图最小环，Floyd绝对没前途，直接bfs可以做到$$O(n^2)$$。

等等，复杂度好像没那么高。因为每个数的两个质因子乘起来不超过1e6，所以我们得到的图好像会简单一些。

如果两个数都超过了1e3，那么它们不可能有边，所以每个环上一定有一个1e3以内的点，所以只需枚举到1e3即可。复杂度$$O(\frac{n\sqrt{v}}{\log v})$$。

-----

6D : 显然可以爆搜。

更好的做法是进行dp，设$$dp(i,j,k)$$表示干掉了前$$i-1$$个人，第$$i-1$$个打了$$j$$发，第$$i$$个打了$$k$$发，最小的总发数。转移枚举第$$i-2$$个人打了多少发。

-----

555E : 不会边双。收录进 连通性相关问题。

-----

613D : 消 耗 战

-----

1110F : 这个性质就很迷惑。

当然可以爆力点分治。

有个好玩的做法，说的是发现询问的叶子区间在dfn上也是区间。考虑直接维护这个答案，我们离线下来dfs这棵树，每次从一个点走到儿子的贡献就是给子树里面的点都减去这条边的边权，子树外面的加上边权；反之亦然。所以我们拿线段树维护所有叶子，然后支持区间加减区间$$\min$$即可。

-----

715C : 点分治。

考虑如何合并，如果一条$$u$$到分治中心、数值为$$x$$的路径和分治中心到$$v$$、数值为$$y$$的路径拼起来膜$$m$$得$$0$$，则有$$(x\cdot10^{\mathrm{len}(y)}+y)\bmod{m}=0$$，移项得到$$x\equiv -y\cdot 10^{-\mathrm{len}(y)}\pmod{m}$$，然后因为$$10\perp m$$，那个逆元可以exgcd，就做完了。

-----

383E : 子集前缀和。

有一个不好，我们算一个都没有的方案数。

容易想到把是不是元音字母表示成一个二进制状压的集合，然后一个都没有说的就是选的元音字母是串中没有的字母的子集，于是我们可以愉快的直接上子集前缀和了。

-----

741D : 重新排列可以变成回文串，等价于最多一个字符出现一次。

用二进制把每个字符的出现次数压起来，那么出现两次可以消去，于是我们可以用异或表示路径合并。

先差分一下试试，设$$f(u)$$表示$$u$$到根路径的上面的状压的结果，那么$$u,v$$合法当且仅当$$\mathrm{popcnt}(f(u)\operatorname{xor}f(v))\leq 1$$。

然后你发现一共只有$$23$$种可能的状态是合法的，也就是全$$0$$和有一个$$1$$。爆力枚举这些情况。

考虑一个点的答案比它儿子们答案的$$\max$$多的部分就是它作为$$\mathrm{lca}$$的部分，所以我们用$$\mathrm{dist}$$的公式，于是可以开一堆桶存每个状态的最大$$\mathrm{dep}$$。

直接枚举一个情况，然后枚举一个点找另一个点，复杂度是$$O(n^2\sigma)$$。

考虑树上启发式合并或者说静态链分治，我们每次拿着一棵轻子树去当前的数据结构中查，查完了合并进来，这样复杂度就是$$O(n\log n\sigma)$$了。

-----

662C : 看到这个$$20$$的数据范围你就想到爆搜，但是怎么搜?

呃我们枚举每一行的翻转情况，翻完行之后考虑一列如果$$1$$超过一半那么它翻，否则它不翻。这样它最后的贡献就是$$01$$个数的较小值。

我们设$$f(x)$$表示二进制状态$$x$$中$$01$$个数的较小值，这个东西很容易计算。

考虑写一个式子，设$$a_i$$表示每列的情况，枚举$$b$$表示行翻转的情况，设这种情况下的答案是$$Ans(b)$$，那么我们得到

$$
Ans(b)=\sum_{i=1}^n f(a_i\operatorname{xor}b)
$$

好像一个异或卷积?我们设$$c_i$$表示$$a_j=i$$的$$j$$个数，就变成

$$
Ans(b)=\sum_{i} c_if(i\operatorname{xor}b)
$$

然后你发现$$Ans$$是$$c$$和$$f$$的异或卷积，法哇塔就完了。

-----

896C : 经典。

-----

932F : 李超树合并优化dp，经典。

-----

19D : 直接线段树分治。

-----

1439C : 不错题。

考虑每一段连续的购买，一个结论是每段之后手里的钱至少少一半，因此段数是$$O(\log v)$$。

考虑一段的结尾，设这一段长度是$$s$$，这一段后面第一个是$$t$$，拿着$$y$$元，那么显然有

$$
\begin{aligned}
y&\geq s\\
y-s&<t\\
t\leq s
\end{aligned}
$$

然后要证的就是$$2(y-s)\leq y$$。

$$
\begin{aligned}
2(y-s)&\leq y\\
2y-2s&\leq y\\
y&\leq 2s\\
y-s&\leq s\\
y-s&\leq t
\end{aligned}
$$

然后就证完了。如何找到这些区间?

考虑一个类似于吉老师线段树的做法，我们线段树每个点维护区间最小值和区间和。

进入一个结点的时候，

 - 如果区间最小值都买不动，直接返回

 - 否则，如果可以买完整个区间，更新答案，直接返回

 - 否则，递归到左右儿子

。我们每一段连续的购买的代价显然都是$$O(\log n)$$，所以我们得到了一个$$O(\log n\log v)$$单次的上界。实际上这个界很松。

修改就随便做了，改变的一定是一段区间，二分左端点然后推平即可。

我居然写了代码，在[这里](https://codeforces.com/contest/1439/submission/113607726)。

-----

2C : Fucking computational geometry.

-----

1375G : 已经收录于 cf思维题选㗅 和 换根dp。

-----

438E : 小朋友和二叉树!

-----然后我们硬想，祖父的$$dp$$就是 父亲的除掉祖父之外的邻接点的$$f+1$$之和 加上 以$$u$$为根祖父的$$f$$值$$+1$$ 。

然后把前面那个式子拆开，变成 以祖父为根$$u$$的$$f$$值$$+1$$ 加上 父亲的除掉祖父和$$u$$之外的邻接点的$$f+1$$之和。后面那部分在这次换根中不变。

然后$$u$$的$$dp$$就是 以祖父为根$$u$$的$$f$$值$$+1$$ 加上 父亲的除掉$$u$$之外的邻接点的$$f+1$$之和。

235C : 

SAM支持从模式串前面删字符，所以破环成链，拿一个滑动窗口去扫即可。

具体怎么删?

考虑SAM每个点匹配的是它里面 **最长子串** 的满足 **长度在某个值以上** 的所有 **后缀**。具体一点，这个 某个值 就是$$\mathrm{maxlen}(\mathrm{parent}(u))+1$$。

那么删掉最前面的字符得到的串，一定是删之前串的后缀，所以如果状态变化了，一定是因为长度太短，跳到了$$\mathrm{parent}$$。判断一下就好了。

注意题意说的是文本串中每个子串只算一次，所以我们需要给走过的点打上标记，如果重复走了那就不再计入答案。

这里有个实现的小trick，就是`vis`数组存储的是上一次被标记时是在第几次询问，然后`vis[u]=1`变成`vis[u]=当前询问编号`，就可以实现简单的清空。

-----

527E : 

考虑如果入度出度都是偶数，那么总度数是偶数，那么有欧拉回路。

我们先把度数是奇数的点配对连边，然后这个图就有欧拉回路了。

考虑如果我们让回路上相邻两条边定向相反，那么这两边之间的点要么被贡献$$2$$的入度，要么是$$2$$的出度，这样最后一定是偶数。

但是如果这个欧拉回路是奇环，也就是总边数是奇数，那我们就没法这么定向了。此时随便选一个点加一个自环即可。

-----

1406E : 有趣题。

1e5以内有多少个质数?打个表你发现是9592。这可真不少?

一个最简单的做法是，我们直接枚举每一个质数，删掉它的倍数，然后再查询它的倍数个数；同时模拟没有$$x$$的删数过程，如果输出有不同，说明$$x$$具有当前删的质数作为质因子。

这样操作次数是2*9592+1，并且我们还没考虑质因子的次数呢，这不太行。

考虑这个删的过程有很多是没啥用的，因为我们实际上只需要sqrt(1e5)=316以内，前65个质数就可以筛掉1e5以内所有合数。同时，在后面这9527=9592-65个质数中，$$x$$最多只可能包含一个作为质因子，并且次数一定是$$1$$。不妨先考虑这些大质数。

发现尽管只可能包含一个，我们还是不得不全删一遍。

考虑一个分块，我们把这些大质数分成根号块，每次删光一块然后查询1的倍数个数，就可以得知$$x$$是否包含这一块的质数。如果包含，那么我们就重新一个一个枚举这一块里的质数进行查询。如果每98个一块，一共有98块，总共查询次数是9527(每个质数删一次)+98(每块查一次1的倍数个数)+98(暴力遍历一块)=9723。还剩276次(除去最后的回答)。

对于小质数，我们删光它们，然后暴力枚举质数幂查询来尝试分解。316以内有147个质数幂，我们的询问次数是65+147=212。最后总询问次数是9936，卡的真紧啊!

-----

940F : zrz秒了啊!

考虑答案是根号阶的。最坏情况下出现次数是$$1,2,3,...$$，这样大约$$\sqrt{2n}$$项加起来就会超过$$n$$，这是一个自然根号。

然后就变成了，$$O(1)$$查询区间中有没有出现恰好$$k$$次的数，$$O(\sqrt{n})$$单点修改。

看到这个单点修改复杂度肯定先考虑分块。然后你发现并不是很好直接统计那个查询所需的信息，因为数很多。

想了114514年你发现还是不会做......然后去看题解。

这**是个带修莫队?CF真是奇迹oj，4s 1e5 $$O(n^{\frac{5}{3}})$$随便跑（

-----

想940F的时候我查了查静态区间mex怎么做，发现做法还挺好玩。

从左往右扫序列，维护$$last(i)$$表示数$$i$$最后一次出现的位置，那么每次加入一个数只会改变一个数的$$last$$，可以用主席树维护。

然后每次询问我们找到右端点对应的版本，二分出最小的$$k$$使得$$last(k)<l$$，这个可以通过维护区间$$\min$$实现。

-----

从这里开始是通过人数1000-了。可能将来会变化（

-----

1208F : 位运算真是奇妙。完全不会。

这题的技巧，在CF上一篇著名的blog称其为SOS dp(Sum Over Subsets dp)，不过硬要说就是子集前缀和一类的东西。

枚举一个$$i$$，然后从高到低按位贪心，维护一个当前最优的$$s=a_j\operatorname{and}a_k$$。这个$$s$$的含义是，存在一个$$a_j\operatorname{and}a_k$$包含$$s$$。

如果$$a_i$$这一位是$$1$$，那么$$s$$这一位是$$0,1$$都随意。根据$$s$$的含义直接赋$$0$$即可。

如果$$a_i$$这一位是$$0$$，那么我们希望$$s$$这一位是$$1$$。

所以我们的问题变成快速检查一个$$s$$是否可行，也就是是否存在一个$$a_j\operatorname{and}a_k$$包含$$s$$。

容易想到做一个位运算卷积，我们做一个fwt-and即可。

但是这里还有一个限制，也就是$$i<j<k$$。发现我们可以做子集后缀和的时候直接维护这一状态最大的$$j,k$$，这就非常好。

-----

1416D : 简单题。

考虑删边连通性的经典性质，也就是删除时间的最大生成树连通性和原图连通性相同。

所以我们可以把这个问题转成树上问题。

然后每次Extract-max操作就是找到路径瓶颈大于当前值的所有点，你发现这是Kru重构树上的一棵子树，建立Kru重构树然后线段树维护即可。

-----

364D : 你发现这个数据范围并不能全做一遍质因数分解。

那怎么办呢?不会办。

去看了一眼题解，知道是随机算法~~没有$途~~!

核心是，每个数有$$\frac{1}{2}$$的概率在最优方案中被选中。这就很适合随机化。

考虑如果知道了一个数$$x$$在最优方案中被选中了，那么答案一定是这个数的因数。我们分解因数，然后求一遍这个数和所有数的$$\gcd$$，复杂度是$$O(\sqrt{v}+n\log v)$$，其中$$d(v)$$是$$v$$以内最大的$$d$$，大约是6000。有点慢?不过CF 4s那还可以接受。

然后我们得到一个数组$$c$$，$$c(i)$$表示$$x$$的第$$i$$个因数在那一堆$$\gcd$$里面出现了几次。做一遍因数后缀和，也就是求出$$f(d)=\sum_{d\vert n}c(n)$$，这个可以很容易地写出一个$$O(d^2(v))$$的暴力。然后求出最大的$$d$$满足$$f(d)$$至少是一半即可。

跑10遍，刚好不会T飞。

-----

547E : 重工业。

对这一大串模式串建立ACAM，然后把文本串一个一个拿上去匹配。

回忆一下只有一个文本串怎么做。我们每次做一个到根的链加。

那么这里有区间的限制了，我们就不能直接加了，我们需要每个点开一个数组维护每一个文本串加了什么。

这个数组有两种搞法，一种是离线差分之后变成前缀信息，然后用线段树或BiT维护；一种是打上标记最后线段树合并。就做完了。

我不喜欢离线，所以写了第二种（

-----

1270G : 收录于 CF思维题选㗅。

-----

750E : 收录于 ddp。

-----

1439B : 收录于 CF思维题选㗅。

-----

526F : 草，没看到是排列?

先按横坐标排序，我们得到一个数组，称为$$y$$好了。

考虑之前的限制，现在就是$$r-l+1=k$$且$$\max(y_i)-\min(y_i)+1=k$$，也就是$$r-l=\max(y_i)-\min(y_i)$$。

这就非常好，看到$$\min,\max$$你立马就能想到笛卡尔树。

我们进行启发式分裂，每次找到最小值分成两半，枚举小的一边，用类楼房重建线段树维护另一边。呃具体地，`calc(u,k,x)`表示左边有前缀最大值$$k$$，求$$\max-r=x$$的个数。这样可以做到$$O(n\log^3 n)$$，实在是拖拉机，并且是瞎扯的还不一定正确。

这是我和zrz的一点想法。

首先这个启发式分裂+类楼房重建线段树就很奇怪，我们直接看题解。(语无伦次)

题解给了三种做法，分治，以及线段树+单调栈。

分治好!我们分两种情况讨论。讲的可能不是很清楚。

考虑四个数组$$leftmax,leftmin,rightmax,rightmin$$，大家懂的都懂。

 - 最大/最小值在同侧，不妨假设在左边

 限制是$$leftmax_l-leftmin_r=r-l$$，并且$$leftmax_l\geq rightmax_r,leftmin_l\leq rightmin_r$$。

我们可以扫这俩所在的那一边，不妨假设是左边，然后同时扫右边，维护满足第二个限制的最右右端点。

然后按照第一个限制求出右端点，如果这个右端点在上面的右指针以内那么合法。

 - 最大/最小值在异侧，不妨假设最大值在左边

限制是$$leftmax_l-rightmin_r=r-l$$，并且$$leftmax_l\geq rightmax_r,leftmin_l\geq rightmin_r$$。

第一个限制移项可得$$leftmax_l+l=rightmin_r+r$$。

枚举一个左端点，发现第二个限制中，前半部分表示的是右半边的一个**前缀**，后半部分是一个**后缀**，所以可行的右端点是一个**区间**。

所以我们同时维护这个区间，把区间中所有点的$$rightmax_r+r$$扔进一个桶，每次直接查询有多少个可行的。~~three pointers~~

这个玄学分治复杂度就是$$O(n\log n)$$。

加强版是997E，静态区间查询。这个分治法好像不是很能扩展到那里去?

考虑直接枚举右端点，然后用线段树维护每个左端点到右端点的$$(\max-\min)-(r-l)$$。为什么是枚举右端点?因为要从左往右扫的话，右端点右移是增加，左移是删除，而$$\min/\max$$不容易删除。

我们要维护的东西就非常好 : 它是非负的。线段树每个点维护最小值和最小值个数即可。

然后右移一次会更新一堆$$\min,\max$$，可以用单调栈求出影响的区间，然后直接推平即可。注意每次进出栈会带来一次线段树操作，所以复杂度是$$O(n\log n)$$。

-----

1391E : 收录于 CF思维题选㗅。

-----

1370F2 : 我以为是3F，结果是2F?

首先一看就知道询问次数是$$\lceil\lg n\rceil+1$$。

做法挺奇妙的。

先问一次所有点，就可以得到一个位于两个特殊点路径上的点，以及这个路径的长度$$l$$。不妨称为特殊路径。这需要$$1$$次询问。

考虑以这个点为根dfs，我们就得到了两个特殊点深度和的限制。

二分较深的点的深度，我们每次询问所有深度为$$mid$$的点，如果有一个点在特殊路径上，那么我们得到的距离就是特殊路径长度，否则是别的东西。画一个图就会很好理解为什么要二分。这个询问次数是$$\lceil\lg n\rceil$$。

然后我们需要一次询问获得较深的点，然后再一次询问就可以获得较浅的点。这样询问次数总共是$$\lceil\lg n\rceil+3$$。

哪里可以砍掉两次询问?

 - 打表发现，二分过程中肯定会询问到较深的特殊点，所以我们二分出深度之后可以直接获得较深的特殊点。

 - 较深的特殊点的深度上界是$$l$$，而下界不必是$$0$$，可以是$$\lceil\frac{l}{2}\rceil$$，这样省去了第一次二分。

于是总询问次数就是$$\lceil\lg n\rceil+1$$，可以通过。

-----

906D : 扩展欧拉定理。

扩展欧拉定理用于在模合数时，代替费马小定理给指数取模。

会这个的话，区间长度可以直接砍到$$\log v$$的级别，直接暴力即可。

注意每次求一堆$$\varphi$$的复杂度不能承受，我们可以直接预处理$$\varphi(p),\varphi(\varphi(p)),...$$。

复杂度是$$O(n\log v)$$。

-----

17E : 完全不会。

考虑Manacher求出回文子串数量，然后用总对数减去不相交的对数。

不相交的对数是什么?如果$$r_s<l_t$$，那么$$s,t$$不相交。

我们枚举一个$$r$$，计算有多少个回文子串的$$l$$在它右边。发现Manacher中每个位置统计到的回文子串长度是一个区间，左端点也是一个区间，所以我们可以用差分-前缀和来支持这个区间加。刚才要的东西就是这个的后缀和。

复杂度$$O(n)$$。

为什么会有把相交变成不相交的想法?相交有八个条件，不相交只有一个条件(因为只对于左边的统计右边的)。

-----

19E : 有意思。

考虑删掉一条边变成二分图，要么是本来就是二分图，要么是删掉这一条边的时候所有奇环都没了。

所以如果我们可以求出所有奇环的交，就很好了。

然后我就想起来一道题叫 SP2878/UVA1364 Knights of the Round Table。这个题的结论说的是一个边双里面如果有奇环，那么每个点都在一个奇环中。于是我就在奇怪的思路上越走越远!然后就去看题解了。

先随便跑一棵dfs树，然后对于每条非树边，它确定了一个环。

这些环我们称为 本原环(称呼并不广泛~~，不过在你谷有12个人给这篇题解点了赞~~)。不同的dfs顺序可能得到不同的本原环，不过没有关系。

[WC2011] 最大XOR和路径 指出，**定理** 每个简单环都是若干本原环的对称差。

**证明** 考虑一个简单环经过的所有非树边，它们确定的本原环的对称差就是这个环。需要一点想象力。

同时我们有这样的推论 : 每个非简单环都是若干简单环的并，所以它们都是若干本原环的并和对称差。

然后可以从一条路径开始，这样对称差得到两点间所有简单路径。

这个结论经常用于 无向图，简单路径 和 异或 相关问题。

**定理** 如果没有奇本原环，那么没有奇环。

**证明** 没有奇本原环，说明每条非树边端点都不同色，而每条树边端点已经不同色了，所以说明可以二分图染色，也就是没有奇环。

所以如果没有奇本原环，直接输出$$0$$。如果只有一个奇本原环，那么我们随便删一条边就好了。

如果有很多奇本原环，刚才我们就知道需要求出所有奇环的交。

所有奇环的交一定是所有奇本原环的交，但是这不够充分，我们需要继续考虑删掉奇本原环的一条边还有奇环的情况。

容易想到删一条边只可能对经过它的本原环产生影响。

画画图发现只有一种情况 : 一个奇本原环和一个偶本原环同时经过这条边时，这条边删了还是会有奇环。

所以我们分开统计奇偶，对每个本原环做一个树上的链加，最后没有被偶本原环加并且被所有奇本原环加了的边就是答案。

其实这个题大家都见过，就是线段树分治板子题 二分图 啊!

实际上不用线段树分治，可以直接用cdq分治做，类似 消失之物。

据说dfs树是解决环相关问题的利器，哪天整理一下。

-----

650D : 说起来我之前还扯过一个静态区间LIS的莫队，好像也假了/kk

先把LIS抽象成平面上的问题，然后这个我们预处理$$pre,suf$$分别表示从每个位置开始的前后缀LIS，就变成了矩形max，主席树或者离线BiT都可以。

-----

487E : T o u r i s t s

-----

1446D1 : 这个题一看就知道复杂度是$$O(nv+v^3)$$之类的东西。

有个我想不到的结论 : 答案区间中的众数们，其中一定有至少一个是整个序列的众数。当然这是众数唯一的情况，众数不唯一直接输出$$n$$。

证明很简单，如果不是的话，我们进行调整，不断扩大这个区间，整个序列的众数在区间中的出现次数一定会反超区间中原有的所有数，那么我们找到区间中众数出现次数和整个序列众数在区间中出现次数这个两个函数的交点，那里的区间合法并且更长。

$$v$$是这么的小!我们考虑直接枚举另一个众数。

枚举之后，每个数只有三种情况 : 是整个序列的众数，是枚举的数，是别的数。我们要做的就是找一个最长的区间使得前两种数量相同。

第三种不用管，因为用与刚才的结论类似的证法可以证明，我们这样扩展下去会得到一个更长的区间，以第三种那个数作为第二个众数。

当然考虑把整个序列的众数全改成$$-1$$，枚举的数改成$$1$$，别的改成$$0$$，问题转化成最长的和为$$0$$的区间。前缀和，然后开一堆桶，每个桶存下标的$$\min$$。复杂度$$O(nv)$$。

-----

1446D2 : 值域变大了，怎么办?

不管值域多大，刚才的结论还是正确的。

枚举一个数不一定还有前途了，因为我们的枚举看起来很难改进，数据结构维护想了想好像十分困难，分块也分不动。

考虑一个枚举，我们枚举全局众数的出现次数$$t$$!然后用双指针去扫，对每个$$l$$求出最大的$$r$$使得区间中没有出现次数超过$$t$$的数。同时我们维护一个计数数组，看一看有没有出现恰好$$t$$次的数，如果有就拿去更新答案。

这东西是$$O(n^2)$$的，不过你发现这两个算法好像有点互补。进行根号分治，对于出现次数超过$$B=\Theta(\sqrt{n})$$的数我们跑Easy中的算法，对于出现次数不超过$$B$$的我们跑上面这个算法，复杂度就是$$O(n\
sqrt{n})$$了。

-----

700C : 一眼最小割+wqs二分。看起来跑不过并且不一定对。

你仔细看!发现复杂度是$$O(nm)$$!

但是枚举一条边，另一条求割边是不行的，因为这样是$$O(m^2)$$。

考虑求出一条$$s\rightsquigarrow t$$，那么这条路径上一定有至少一条边要割，我们枚举这条边然后跑割边就行了，复杂度$$O(nm)$$。

-----

1363F : 考虑这个操作实际上干了这么一件事 : 把一个字符插入到前面。

考虑一个dp，我们设$$dp(i,j)$$表示$$s$$的前$$i$$个字符加上$$j-i$$个操作过来的字符，匹配$$t$$的前$$j$$个字符的最小操作次数。

考虑转移，我们枚举第$$j$$个字符怎么来的 : 

 - 从前$$i$$个字符挤过来。那么一定是第$$i$$个，所以条件是$$s_i=t_j$$，$$dp(i,j):=\min(dp(i,j),dp(i-1,j-1))$$

 - 从后面操作过来。那么我们随便选一个，条件是后面有一个$$t_j$$，$$dp(i,j):=\min(dp(i,j),dp(i,j-1)+1)$$

 - 往前移，把工作交给前面。$$dp(i,j):=\min(dp(i,j),dp(i-1,j)+1)$$

。你发现一个小问题，那就是往前移和后面移过来的其实是一个东西，但是我们计算了两次。这不好!所以我们去掉其中一个的$$+1$$即可，事实证明去掉哪一个都可以。

-----

521D : 首先我们知道，操作顺序一定是赋值$$\rightarrow$$加法$$\rightarrow$$乘法。

先考虑乘法，因为求的是乘积最大，对一个数进行乘法相当于对最后的答案进行乘法，所以我们一定会选取最大的若干个乘法操作。

然后考虑赋值和加法。

首先赋值也是一种加法。

我们取个$$\ln$$拆开贡献，然后开个堆每次选取最优的。不过这个加法操作会更新一大堆加法操作!这就很不好。

实际上只有最大的那个加法操作有用，所以我们可以每次选了最大的之后更新 选取次大的带来的$$\ln$$变化量。复杂度$$O(n\log n)$$。

你发现实际上计算这个$$\ln$$的变化量所做的就是把加法变成乘法，所以我这个跟题解做法是一样的。

-----

576D : 众所周知1000才是Floyd的数据范围（恼

考虑如果$$d$$很小，那么分层图就好了。

但是$$d$$不小!

考虑实际上只有$$m$$层是新开辟了一些边，此后最多再有$$2m$$层就可以走完这次开辟的新边，为了奇怪的走法我们把它增加到$$3m$$，总之只有$$O(m^2)$$层是有用的，别的层中总是可以在一条边上来回走。bfs即可，复杂度$$O(m^3)$$，不过没写，不知道正确性。

正解是矩阵快速幂+倍增。每次我们尝试一直走到下一条边开放，如果在此之前就能到达我们就倍增找到最短时间，否则继续尝试走到再下一条边开放。用bitset存储矩阵，复杂度是$$O(\frac{n^3m}{w}\log v)$$。

-----

1278F : 这个$$x^k$$来者不善。

直接写式子!

$$
\sum_{x=0}^nx^k\binom{n}{x}(\frac{1}{m})^x(1-\frac{1}{m})^{n-x}
$$

然后考虑怎么算。这个$$n$$大上天了啊!

不过这让你想起一道题叫 组合数问题，或者 如何优雅地求和。那个题也是$$n$$大上天，但是$$k$$很小啊!

我们硬推!

$$
\begin{aligned}
&\sum_{x=0}^nx^k\binom{n}{x}\left(\frac{1}{m}\right)^x\left(1-\frac{1}{m}\right)^{n-x}\\
=&\sum_{x=0}^n\sum_{i=0}^k{k\brace i}x^\underline{i}\binom{n}{x}\left(\frac{1}{m}\right)^x\left(1-\frac{1}{m}\right)^{n-x}\\
=&\sum_{i=0}^k{k\brace i}n^\underline{i}\sum_{x=0}^n\binom{n-i}{x-i}\left(\frac{1}{m}\right)^x\left(1-\frac{1}{m}\right)^{n-x}\\
=&\sum_{i=0}^k{k\brace i}n^\underline{i}\sum_{x=0}^{n-i}\binom{n-i}{x}\left(\frac{1}{m}\right)^{x+i}\left(1-\frac{1}{m}\right)^{n-x-i}\\
=&\sum_{i=0}^k{k\brace i}n^\underline{i}\left(\frac{1}{m}\right)^i\sum_{x=0}^{n-i}\binom{n-i}{x}\left(\frac{1}{m}\right)^x\left(1-\frac{1}{m}\right)^{n-i-x}\\
=&\sum_{i=0}^k{k\brace i}n^\underline{i}\left(\frac{1}{m}\right)^i
\end{aligned}
$$

就做完了，复杂度$$O(k^2)$$。利用带项式科技快速求一行斯特林数，可以做到$$O(k\log k)$$。鰰给出了一个$$O(k)$$做法，我不懂。