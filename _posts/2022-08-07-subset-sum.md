---
layout: post
title: subset sum，Graham-Joux算法
subtitle: /fn
tags: 搜索
---

subset sum也就是判定一个集合是否存在一个和为$$k$$的子集的问题。译自 A new generic algorithm for hard knapsacks http://www.joux.biz/publications/Knapsacks.pdf 。

关于subset sum，大家都会直接折半，然后排序双指针。

-----

众所周知时间复杂度不低于空间复杂度，所以我们首先介绍Shamir和Schroeppel的算法，它把空间降到了四次根号。考虑我们把遍历所有子集和的过程再次折半，我们把前一半和后一半的所有子集和都求出来并排序，前一半称为$$l$$而后一半称为$$r$$，然后我们对每个$$l_i$$维护一个$$r_j$$，每次找到最小的$$l_i+r_j$$把它输出并$$j:=j+1$$，使用堆即可。

一个不需要在排序之外的地方多$$\log$$的想法是，我们还是先折两半，随机一个膜数$$m=\Theta(2^{\frac{n}{4}})$$，枚举左边的和膜$$m$$的值，此时右边的也确定了。接下来我们可以对两边再折半，生成具有我们所要的膜$$m$$的值的所有方案，这是单次$$\tilde{O}(2^{\frac{n}{4}})$$的。然后由于膜数是随机的，期望生成$$O(2^{\frac{n}{4}})$$个数，所以空间就是期望$$O(2^{\frac{n}{4}})$$。

这里和以后都认为数非常大，以至于它们膜一个随机数是均匀分布的。

-----

首先给出一个大约$$\tilde{O}(2^{0.42n})$$的算法。

注意到shamir-schroeppel中膜考虑$$m$$的值很有趣。发现我们这里直接把序列折两半其实是不好的，因为如果答案包含很多个元素，那么有很多种方法把它分成若干部分。这里我们钦点答案有不超过$$\frac{n}{2}$$个元素，如果它实际上超过了，我们可以并行跑正着和反着的问题，这需要实现一个调度器，不过它总是可以实现的吧。

钦点$$32\mid n$$，考虑把答案分成四部分，每部分有$$\frac{n}{8}$$个元素。取$$m=\Theta(2^{\frac{n}{3}})$$，然后随机三个$$m$$以内的数作为前三部分，此时第四部分也确定了。然后我们要生成在原序列中具有我们所要的膜$$m$$的值的所有方案。

考虑使用类似于shamir-schroeppel算法中的方法。我们把序列分成$$32$$块，每一块跑出来所有的子集和，