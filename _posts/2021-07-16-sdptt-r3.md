---
layout: post
title: 三轮省集
subtitle: /kk/kk/kk
tags: 课
---

## Day1

### 模拟赛

T1

原来是简单题/ll

给一个$$m$$次多项式$$f$$，$$a_0$$和$$b,c$$，求

$$
a_n=a_{n-1}+f(n)a_{\frac{n+b}{c}}
$$

。$$m\leq 20,n\leq 10^{18},b<c-1$$，膜$$1004535809$$。

考虑大力拆$$n$$次 : 

$$
a_n=a_0+\sum_{i=1}^nf(i)a_{\lfloor\frac{i+b}{c}\rfloor}
$$

，然后呢?好像没有什么性质。

为了简洁先记$$t(i)=\lfloor\frac{i+b}{c}\rfloor$$，$$r(i)=ic-b$$是最小的使得$$t(r(i))=i$$的数，然后再拆一层，交换求和号 : 

$$
\begin{aligned}
&\sum_{i=1}^nf(i)a_{t(i)}\\
=&\sum_{i=1}^nf(i)\left(a_0+\sum_{j=1}^{t(i)}f(j)a_{t(j)}\right)\\
=&\sum_{i=1}^nf(i)a_0+\sum_{i=1}^nf(i)\sum_{j=1}^{t(i)}f(j)a_{t(j)}\\
=&\sum_{i=1}^nf(i)a_0+\sum_{j=1}^{t(n)}f(j)a_{t(j)}\sum_{i=r(j)}^nf(i)
\end{aligned}
$$

然后就很好玩了。你发现后面的东西看起来就像......呃是一个多项式。

它是$$f(j)(S_f(n)-S_f(r(j)-1))$$，这东西是$$2m+1$$次的。你发现$$t(n)$$是折半的，每一轮多一个$$O(m)$$次，所以递归到最后剩下次数是$$O(m\log n)$$的可以接受。

然后问题就是怎么求这个，显然乱插就可以了。复杂度$$O(m^2\log^3 n)$$。

-----

T2

二分图最小边覆盖，构造方案。简单题。

-----

T3

有一棵未知的$$n$$个点的二叉树，你可以问$$5\times 10^6$$次，每次问一个点对的距离。$$n\leq 10^5$$。

好玩题。

看起来像是$$\log$$，自然想到树分治。

各种分治需要使用$$size$$，但是我们显然搞不定这个东西，所以考虑链分治(长链剖分)。呃这不是根号吗?问题不大，想完再说，再说了总能水到很多分(出题人表示有60)。

先找到最深的点，这个全问一遍就好了。然后我们对于每个点要找到它在这条链上还是在链上某个点的轻子树上。

再把每个点跟最深的点问一遍，因为我们已经知道了深度，由$$\mathrm{dis}(u,v)=\mathrm{dep}(u)+\mathrm{dep}(v)-2\mathrm{dep}(\mathrm{lca}(u,v))$$就可以得到$$\mathrm{lca}(u,v)$$的深度，由于这个$$\mathrm{lca}$$一定在$$1$$的重链上，我们可以确定$$\mathrm{lca}$$。把这个点挂到这个$$\mathrm{lca}$$上，表示它在这个点的轻子树上，当然特判掉它就是这个点的情况。

然后递归每棵轻子树，我们的复杂度就是$$O(n\sqrt{n})$$了!

但是它再怎么说还是60pts。考虑怎么套用到重链剖分。

如果我们已经知道了这棵树的重链剖分结构，那就可以随便做了。所以相当于要动态维护重链剖分。

实际上有两个做法，硬上动态重链剖分(也就是用平衡树维护所有重链，这里只需要挂一个叶子所以比较简单)，或者直接套用lct。啊你说怎么用lct?每次问完access一下摊掉就好了。不过注意维护的时候，每个点不是 在轻子树，而是 在某个子树。

至于怎么证明动态维护这个东西得到的询问次数界还是一个$$\log$$?我也不会，但是感性理解很对。

-----

期望得分20+100+10=130，实际得分20+100+0=120，海星罢。

### 讲课

非传统!

-----

退火

-----

造计算机

把需要的运算列出来，全都拆成基本运算，然后尝试用给出的运算实现这些基本运算......

对于某些奇怪的函数要敏感。

-----

二分

猜数游戏，告诉你$$\leq$$还是$$>$$。多次询问，你的操作次数只有$$q(\lg(n+1)+0.1)$$。$$n\leq 10^9$$。

确定性死定了，因为如果某次问到了多一次的位置，那么一直问这个你就死了。

考虑这个东西听起来很离谱，你发现随机扰动并不可行，因为有些位置多问一次的概率就是更大。

考虑我们进行一个纯粹的随机，直接找到所有数然后随机一棵决策树，也就是钦定一些点深度大$$1$$。

但是这个太慢了，不过我们可以随机一个区间钦定它大$$1$$。

这样的决策树是可以快速计算的，具体方式我也不是很清楚，反正一听就可以快速计算。

不过据说直接这么做还过不了，需要加一些别的奇技淫巧。

-----

无标号树

有一个1e18以内的数，你要把它编码成一个$$100$$个点以内的无标号树，然后解码。

两个做法。基本想法是，先搞一条链，用两个奇怪的东西标记开头结尾，然后往上挂东西来表示信息。

但是直接挂$$2$$进制是不够的。

考虑这个挂东西相当于挂任意无标号有根树，你发现选取$$4$$进制的时候恰好就可以用$$3$$个点表示一位，然后你就过了。事实上选取更大的进制可以得到更大的表示范围，不过那就意义不大了。

另一种做法是，$$2$$进制里面我们不再是用挂上表示$$1$$，而是用挂上表示$$01$$中较少的，再加一个标记表示哪个更少。

-----

图

给你一个$$n$$个点的有标号无向图，你要把它编码成一个$$n+12$$个点的无标号无向图，然后解码。$$n\leq 1000$$。

简单想法是用$$10$$个点表示每一位，有这一位的就连边，这样就存下了编码信息。

然后需要找到这些点。可以找一个度数巨大的点，它跟所有点连边，唯独不和这$$10$$个点连边。那么我们就可以知道这些点是哪些了。

然后要确定它们的顺序。首先肯定需要用一条链串起来，现在需要考虑哪个在前面。

你发现$$1000<1023$$，所以代表最高位的点，连的边一定少的可怜，所以度数更大的那个点就是最低位。

-----

IOI2020 网络站点

有一棵树，你需要写两个程序A,B，A负责对它重编号成一个排列，B每次要接受$$u,v$$和$$u$$的所有邻接点，回答$$u$$走到$$v$$的路径上经过的邻接点是哪一个，这里给出点都是给出A的重编号。部分分是编号在$$n^2$$内即可，当然编号不能重复。

考虑部分分做法显然是直接把括号序压进去。

然后呢?如何优化?

考虑如果记进栈序，就会导致不能区分父亲和最后一个儿子，出栈序相反。

考虑按照奇偶性分层，奇数层记进栈序，偶数层记出栈序。

你发现我们可以根据与邻接点的大小关系判断是奇数层还是偶数层，从而得到所有邻接点的括号。做完了。

太妙了!

