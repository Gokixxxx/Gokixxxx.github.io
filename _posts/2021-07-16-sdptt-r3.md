---
layout: post
title: 三轮省集
subtitle: /kk/kk/kk
tags: 课
---

## Day1

### 模拟赛

T1

原来是简单题/ll

给一个$$m$$次多项式$$f$$，$$a_0$$和$$b,c$$，求

$$
a_n=a_{n-1}+f(n)a_{\lfloor\frac{n+b}{c}\rfloor}
$$

。$$m\leq 20,n\leq 10^{18},b<c-1$$，膜$$1004535809$$。

考虑大力拆$$n$$次 : 

$$
a_n=a_0+\sum_{i=1}^nf(i)a_{\lfloor\frac{i+b}{c}\rfloor}
$$

，然后呢?好像没有什么性质。

为了简洁先记$$t(i)=\lfloor\frac{i+b}{c}\rfloor$$，$$r(i)=ic-b$$是最小的使得$$t(r(i))=i$$的数，然后再拆一层，交换求和号 : 

$$
\begin{aligned}
&\sum_{i=1}^nf(i)a_{t(i)}\\
=&\sum_{i=1}^nf(i)\left(a_0+\sum_{j=1}^{t(i)}f(j)a_{t(j)}\right)\\
=&\sum_{i=1}^nf(i)a_0+\sum_{i=1}^nf(i)\sum_{j=1}^{t(i)}f(j)a_{t(j)}\\
=&\sum_{i=1}^nf(i)a_0+\sum_{j=1}^{t(n)}f(j)a_{t(j)}\sum_{i=r(j)}^nf(i)
\end{aligned}
$$

然后就很好玩了。你发现后面的东西看起来就像......呃是一个多项式。

它是$$f(j)(S_f(n)-S_f(r(j)-1))$$，这东西是$$2m+1$$次的。你发现$$t(n)$$是折半的，每一轮多一个$$O(m)$$次，所以递归到最后剩下次数是$$O(m\log n)$$的可以接受。

然后问题就是怎么求这个，显然乱插就可以了。复杂度$$O(m^2\log^3 n)$$。

-----

T2

二分图最小边覆盖，构造方案。简单题。

-----

T3

有一棵未知的$$n$$个点的二叉树，你可以问$$5\times 10^6$$次，每次问一个点对的距离。$$n\leq 10^5$$。

好玩题。

看起来像是$$\log$$，自然想到树分治。

各种分治需要使用$$size$$，但是我们显然搞不定这个东西，所以考虑链分治(长链剖分)。呃这不是根号吗?问题不大，想完再说，再说了总能水到很多分(出题人表示有60)。

先找到最深的点，这个全问一遍就好了。然后我们对于每个点要找到它在这条链上还是在链上某个点的轻子树上。

再把每个点跟最深的点问一遍，因为我们已经知道了深度，由$$\mathrm{dis}(u,v)=\mathrm{dep}(u)+\mathrm{dep}(v)-2\mathrm{dep}(\mathrm{lca}(u,v))$$就可以得到$$\mathrm{lca}(u,v)$$的深度，由于这个$$\mathrm{lca}$$一定在$$1$$的重链上，我们可以确定$$\mathrm{lca}$$。把这个点挂到这个$$\mathrm{lca}$$上，表示它在这个点的轻子树上，当然特判掉它就是这个点的情况。

然后递归每棵轻子树，我们的复杂度就是$$O(n\sqrt{n})$$了!

但是它再怎么说还是60pts。考虑怎么套用到重链剖分。

如果我们已经知道了这棵树的重链剖分结构，那就可以随便做了。所以相当于要动态维护重链剖分。

实际上有两个做法，硬上动态重链剖分(也就是用平衡树维护所有重链，这里只需要挂一个叶子所以比较简单)，或者直接套用lct。啊你说怎么用lct?每次问完access一下摊掉就好了。不过注意维护的时候，每个点不是 在轻子树，而是 在某个子树。

至于怎么证明动态维护这个东西得到的询问次数界还是一个$$\log$$?我也不会，但是感性理解很对。

-----

期望得分20+100+10=130，实际得分20+100+0=120，海星罢。

### 讲课

非传统!

-----

退火

-----

造计算机

把需要的运算列出来，全都拆成基本运算，然后尝试用给出的运算实现这些基本运算......

对于某些奇怪的函数要敏感。

-----

二分

猜数游戏，告诉你$$\leq$$还是$$>$$。多次询问，你的操作次数只有$$q(\lg(n+1)+0.1)$$。$$n\leq 10^9$$。

确定性死定了，因为如果某次问到了多一次的位置，那么一直问这个你就死了。

考虑这个东西听起来很离谱，你发现随机扰动并不可行，因为有些位置多问一次的概率就是更大。

考虑我们进行一个纯粹的随机，直接找到所有数然后随机一棵决策树，也就是钦定一些点深度大$$1$$。

但是这个太慢了，不过我们可以随机一个区间钦定它大$$1$$。

这样的决策树是可以快速计算的，具体方式我也不是很清楚，反正一听就可以快速计算。

不过据说直接这么做还过不了，需要加一些别的奇技淫巧。

-----

无标号树

有一个1e18以内的数，你要把它编码成一个$$100$$个点以内的无标号树，然后解码。

两个做法。基本想法是，先搞一条链，用两个奇怪的东西标记开头结尾，然后往上挂东西来表示信息。

但是直接挂$$2$$进制是不够的。

考虑这个挂东西相当于挂任意无标号有根树，你发现选取$$4$$进制的时候恰好就可以用$$3$$个点表示一位，然后你就过了。事实上选取更大的进制可以得到更大的表示范围，不过那就意义不大了。

另一种做法是，$$2$$进制里面我们不再是用挂上表示$$1$$，而是用挂上表示$$01$$中较少的，再加一个标记表示哪个更少。

-----

图

给你一个$$n$$个点的有标号无向图，你要把它编码成一个$$n+12$$个点的无标号无向图，然后解码。$$n\leq 1000$$。

简单想法是用$$10$$个点表示每一位，有这一位的就连边，这样就存下了编码信息。

然后需要找到这些点。可以找一个度数巨大的点，它跟所有点连边，唯独不和这$$10$$个点连边。那么我们就可以知道这些点是哪些了。

然后要确定它们的顺序。首先肯定需要用一条链串起来，现在需要考虑哪个在前面。

你发现$$1000<1023$$，所以代表最高位的点，连的边一定少的可怜，所以度数更大的那个点就是最低位。

-----

IOI2020 网络站点

有一棵树，你需要写两个程序A,B，A负责对它重编号成一个排列，B每次要接受$$u,v$$和$$u$$的所有邻接点，回答$$u$$走到$$v$$的路径上经过的邻接点是哪一个，这里给出点都是给出A的重编号。部分分是编号在$$n^2$$内即可，当然编号不能重复。

考虑部分分做法显然是直接把括号序压进去。

然后呢?如何优化?

考虑如果记进栈序，就会导致不能区分父亲和最后一个儿子，出栈序相反。

考虑按照奇偶性分层，奇数层记进栈序，偶数层记出栈序。

你发现我们可以根据与邻接点的大小关系判断是奇数层还是偶数层，从而得到所有邻接点的括号。做完了。

太妙了!

## Day2

### 模拟赛

T1

排列计数，对于每个位置有$$\leq a_i$$或者$$\geq a_i$$的限制。$$n\leq 5000$$。

考虑只有 必须在一个前缀里面 的限制的话很好做，那么我们可以把后缀容斥掉，变成$$(\leq n)-(\leq a_i-1)$$，然后做一个dp处理就好了。

另一个做法是奇妙的 延迟选择，并不人类可读。

-----

T2

点分治法法塔，然后多点求值。出题人\*\*\*\*

-----

T3

A输入一个长$$n$$的01串，输出一个长$$m$$的01串，其中有$$k$$位被指定了。B要根据A输出的串计算原串。$$n+k+50\leq m$$。

这不是人类可想做法，但是是人类可读做法，需要灵机一动。

虽然A,B不能进行交流，但是它们可以获得一些相同的静态信息，比如生成相同的随机数。

考虑我们随机$$m$$个长$$n$$的01串，B按照A输出的串把这些01串$$\mathrm{xor}$$起来得到原串。

有一些位置必须是$$1$$，也就是说有一些串一定存在，当然还有一些串一定不存在，那么要用剩下的串把这个搞成原串。显然线性基。

$$n+k+50\leq m$$这件事说明满秩概率非常高，据说是$$1-\frac{1}{2^{50}}$$。bitset优化即可。

### 讲课

构造!

-----

01串

给定$$n$$，构造一个长$$2^n$$的循环01串，使得它所有长$$n$$的子串互不相同。$$n\leq 20$$。

考虑把所有长$$n$$的01串建一个点，然后连边，这样就可以跑一个哈密顿回路了!

然而这不是很好，我们可以把长$$n-1$$的01串建成点，这样长$$n$$的01串就是边了(仔细理解一下)，这样就可以跑一个欧拉回路了!

-----

IMO2010 T5

你有$$6$$个盒子，一开始每个盒子有一个硬币。你可以每次选择

 - 从盒子$$i$$拿走一个硬币，给盒子$$i+1$$放上两个硬币

 - 从盒子$$i$$拿走一个硬币，交换盒子$$i+1,i+2$$

。构造方案使得最后一个盒子有$$2010^{2010^{2010}}$$个硬币。

考虑定义操作1是把$$(x,0)$$变成$$(0,2x)$$。这太慢了

定义操作2是把$$(x,0,0)$$变成$$(0,2^x,0)$$，这样有个指数级就可以增长快点了。做法是这样的 : 

$$
(x,0,0)\rightarrow(x-1,0,4)\rightarrow(x-2,4,0)\rightarrow(x-2,0,8)\rightarrow(x-3,8,0)\rightarrow...\rightarrow(0,2^x,0)
$$

类似的可以定义操作3是把$$(x,0,0,0)$$变成$$(0,2^2^2...,0,0)$$，构造留作练习（

剩下的事情非常简单，只需要凑出一个不小的数，然后用上面的东西(比如可以凑一个$$6$$，$$2^{2^{2^{2^{2^{2}}}}}$$比$$2010^{2010^{2010}}$$大多了)，最后使劲浪费swap造出$$(0,0,0,\frac{2010^{2010^{2010}}}{4},0,0)$$，再来两次就做完了。

-----

IMO2020 T3

有$$4n$$个球，每个球有颜色，每种颜色恰好有四个球。把球分成两部分，使得每一部分每种颜色都有两个球，同时两部分编号和相同。

简单题。考虑对于每个球跟它编号加起来是$$4n$$的那个球连边，然后你发现遇到了僵局。

把每种颜色缩起来，然后就变成给边定向，让每种颜色出入度都是$$2$$。

这是经典问题，跑一个欧拉回路，然后对于奇数位置的边顺着定向，偶数位置的逆着定向就好了。

-----

奇偶归并排序

-----

IOI2021 位移寄存器

你有$$100$$个$$2000$$位寄存器，支持mov，位运算和加法，一开始有$$n$$个$$k$$位整数压起来存在寄存器$$0$$，存储格式都是补码，你需要设计一个操作顺序使得最后寄存器$$0$$存着这些数从小到大排序的结果。$$n\leq 100,k\leq 10$$，操作不超过$$4000$$次。

这个看起来确实是造计算机题。

我们几乎不能把这些数先都拆出来，不然就没有多的寄存器用了。

考虑既然没有比较，我们就不比较了，可以尝试直接实现一个 比较器，然后就可以每次提取两个要比较的数，随便写一个简单排序网络。

取$$\min,\max$$就是取$$\abs$$，因为$$2\max(a,b)=a+b+\abs(a-b)$$。

然后就是要实现补码和绝对值。

补码好说，绝对值呢?

考虑用一个掩码提取符号位，然后先减去shift到最低位的符号位，再shift几遍把这个符号位膨胀成$$k$$位(更好的做法是减$$1$$取反再and掩码)，再xor上去实现取反。这就把补码还原了。

有一些步骤是支持并行的，也就是说可以直接在这个压位里面完成，而不需要把操作数提取出来。这样我们就完成了$$O(n)$$甚至$$O(\log^2 n)$$的排序。当然这里操作次数并不松，使用更快的奇偶归并排序要更轻松。

据说比较器写的好可以用奇偶移项卡到1500以内......

更多内容参见Matrix67的博客。

-----

IOI2021 分糖果

有一个序列，一开始全是$$0$$，每个位置有一个$$c_i$$表示它的范围是$$[0,c_i]$$，超出这个范围就会自动贴到边界。支持区间加减，问最后这个序列是什么。$$n,q\leq 2\times 10^5$$。

扫描线。问题变成，维护一个操作序列，支持单点修改操作数，查询最后的结果。

考虑我们找到最后一次贴边，然后剩下的部分就是求和了。

这个怎么找?考虑一个

-----

IOI2021 钥匙

-----

IOI2021 地牢游戏

地牢是一个树，每个点有一个敌人，敌人有攻击力$$a_i$$，权值$$b_i$$和指针$$x_i$$。

有一个人从点$$x$$降落，一开始她的能力值是$$w$$，她会和走到的每个点的敌人战斗，如果$$w\geq a_i$$，她的$$w$$会增加$$a_i$$并且她会走到父亲，否则$$w$$增加$$b_i$$并走到$$x_i$$指向的点。多次查询几步走到根。$$n\leq 4\times 10^5,q\leq 5\times 10^4,v\leq 10^7$$。

考虑这么一件事 : 为什么是加上$$a_i$$?

你发现 打败了之前打不败的敌人 这件事只会发生$$\log$$次。

考虑把这个过程分成$$\log$$段，第$$i$$段是能力值在$$2^i$$到$$2^{i+1}$$之前的过程。我们认为上一段就能打赢的敌人是永远打不赢的，它的$$b$$是原来的$$a$$，$$x$$指向父亲，这样问题就变成了 第一次在哪里打赢了。

这个就可以做了，你发现每个点有一条出边，这就是一个内向基环树森林。考虑分成树上和环上的两端。

 - 对于树上，设$$d$$表示到环的和，那么从$$u$$出发，走到一个点$$v$$的时候，$$v$$不会被干掉当且仅当$$d_u-d_{\mathrm{fa}(v)}+w\leq a_v$$，移项一下就变成维护$$\min$$了，树剖+线段树即可。

 - 对于环上，可以先计算转多少圈才会停下，然后算停在哪，可以用线段树维护这个环。

然后我们离线下来统一做这个事情就好了，或者如果你喜欢的话也可以炸空间地实现成在线。复杂度是$$O(n\log v+q\log n\log v)$$。

-----

IOI2018 doll



-----

IOI2018 highway

神题。给一张无向无权图和$$a<b$$，有两个未知点$$s,t$$，你每次可以把每条边边权赋成$$a,b$$中的一个，查询$$s,t$$的最短路。你需要在$$50$$次之内找到$$s,t$$。$$n\leq 90000,m\leq 130000$$。

