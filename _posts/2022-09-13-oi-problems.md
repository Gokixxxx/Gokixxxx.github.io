---
layout: post
title: oi题选做
subtitle: 麻麻麻
tags: 问题集
show: true
---

从这一篇开始我要使用两个\$作为latex的标识符。

## polish oi

poi大概是，有三轮，r1五题，r2 r3都是有D0 D1 D2，D0一题，D1 D2两题。

#### VIII(2000~2001)

Stage 1

A. Liczby antypierwsze

tooooooooooooooo classic。

B. Mapa gęstości

前缀和。

C. Przedziały

模拟。

D. Gra w zielone

幸运的，这个题在谷上有。

请注意是在环上的部分要走过一个绿点，而不是整个/jy

发现如果一个A的点的后继有让A赢的，它就也是赢的，否则它是输的。如果一个B的点后继全是让A赢的，那么它也是赢的，否则它是输的。但是只知道这些不管用，我们可以让所有点都赢，也可以让所有点都不赢。

考虑如果不在环上的绿点也算数的话，那么我们只要一开始让所有绿点赢，然后按上面递推就好了。注意到如果从一个绿点出发必然可以到达自己，那么它必然是赢的，否则这个绿点是无用的。发现我们从有用的绿点出发递推就可以得到正确答案，所以问题是求出哪些绿点是有用的。

做法是，我们先把所有绿点置为有用的，然后有用的绿点必然是赢的，递推出哪些点是赢的，如果一个有用的绿点其实是输的，那么就把它置为无用的。于是每轮减少至少一个绿点，复杂度$O(cm)$。

为了证明这个奇怪东西的正确性，考虑最后每个输的点显然真的不能赢，而每个赢的点确实可以走到一个环上，而由于是从一些绿点开始递推，环上确实必然有一个绿点。

Stage 2

D0

Gorszy Goldbach

找到一些大素数快速减少数的大小。打表即可。

D1

Spokojna komisja

2-sat。

Wyspa

没太看懂题意。应该模拟就行了吧/oh

D2

Mrówki i biedronka

没太看懂题意。应该模拟就行了吧/oh

Podróż

题意不是很懂，看起来是什么大力建图dij?

Stage 3

D0

Wędrowni treserzy pcheł

判定基环树森林同构，考虑基环树，每个子树树hash之后相当于判定两个序列是否循环同构，跑个最小表示然后hash即可。

D1

Porównywanie naszyjników

考虑那个简单的最小表示都需要啥。发现我们需要求lcp，然后需要保证可能作为最小表示开头的位置数量很少。注意到一段只有第一次循环和最后一次循环中的位置可能成为最小表示的开头，所以后者已经结束了，而前者，考虑倍增hash，结束了。

Zwiedzanie miasta

智障了。随便跑一个欧拉回路，然后找到前缀和最小的点，从它出发就得到一个全正的。和raney引理有点像。

D2

Bank

如果只有一种货币，注意到每个人都不会让你的资金量变小，所以我们会每次选择加最少初始资金就能选的。

但是现在有四种货币，感觉上贪心好像真的可以得到一个极优解，我们只需要先让第一种最小，如果有很多个可以选的，让第二种最小，这样的。

Kopalnia złota

枚举一个横坐标，线段树维护纵坐标，那么一个点在一个横坐标区间贡献一个纵坐标区间。

Łańcuch

直接dp。考虑我们首先要让$n-1$是1，剩下的都是0，所以设$dp(i)$表示变成$i$是1前面都是0的步数，为了这么做发现我们只有送一个1上去才能把最低的1拿掉，所以看起来策略就是每次把当前末尾极长我们想要的段(一些0之后一个1)往上扩展一个1，然后把下面那个1扔了，直到够到$n$这样的。

#### IX(2001~2002)

Stage 1

Superskoczek

我们尝试让马分别往上走一步，往下走一步，往左走一步，往右走一步。注意到必然存在一种方案使得马的坐标绝对值保持在$101$以内。搜即可。

或者使用格的线性基，称为hermite标准化的算法。它收录于 线性代数。我们说说前面怎么做。

首先我们必须可以找到或者组合出四个在坐标轴上的向量，把它们称为简单向量。具体做法就是有就直接取，没有就找最多两个组合。

这个东西是正整数线性组合，那么我们考虑怎么改成整数。现在有一个向量$(a,b)$，我们要凑$(-a,-b)$，不妨设$a,b>0$，想一想发现通过使用$(a,b)$和下半轴和左半轴的简单向量总可以凑出$(-a,-b)$。

然后跑hermite标准型。这个标准型应该包含且仅包含$(1,0),(0,1)$。

Komiwojażer Bajtazar

模拟。

Wyspa

转一圈双指针即可。

Zamek

直接dp。

Koleje

noip2012 借教室。noip出poi原题/jy

线段树模拟一下。

Stage 2

Izolator

这是一个匹配问题。考虑每个数可能贡献正的它，负的它或者不贡献，不贡献显然没劲，然后我们希望让最大的若干个数贡献正的，最小的贡献负的，所以构造一下发现可以最大的$\lfloor\frac{n}{2}\rfloor$个数贡献正的，最小的$\lfloor\frac{n}{2}\rfloor$个数贡献负的。

Działka

模板 最大子矩形。

Wyliczanka

excrt。

Kurort narciarski

还是直接dp。

Protokoły

不是很能看懂题意。不过肯定可以直接dp吧。

Stage 3

Minusy

这个问题好像很经典，似乎在arc出现过。对于每一段连续的加号，我们在两边放一对括号。arc搬poi/jy

Narciarze

这个看起来不是最小路径覆盖啊，也不是最小割。但是上下界最小流就好了!

Waga

背包。

Liczby B-gładkie

数论题/jy

min_25/洲阁筛的第二部分。

Nawiasy

直接dp。

Szyfr

模板 knapsack。折半。

#### X(2002~2003)

Stage 1

Ciągi bez zająknięć

考虑有没有一个$\log$个的构造。发现可以把原序列复制一份，在中间加入一个没有出现过的字符。

交一发wa了。考虑有没有一个$O(1)$的构造。发现两个字母肯定不行，但是搜一搜或者手动构造，发现三个字母可以构造出$n=8$，一个做法是$abcbabca$。结论是thue-morse序列的差分是square free的。

或者可以大力随。注意到长度超过某个足够大的$k$的square几乎不可能出现，而它们有$n^2$个，那么取$k=120$看起来足够，如果往后加入一个字符后，出现了长度$\leq k$的square，则删掉它。我们只需要维护$k$个前缀和即可。为了证明这个东西的复杂度，请见 https://www.sciencedirect.com/science/article/pii/S0304397515006489。

为了写checker，看起来需要使用lyndon array那一套。

Liczby Przesmyków

数位dp。

Czekolada

也就是如果选一个x的时候，前面有$k$个y被选了，那么它带一个$k+1$的系数。dp即可。

Przemytnicy

dij。

Płytki drukowane

大力dp，直接存两端的状态。

Stage 2

Mastermind II

模拟。

Autostrady

2-sat。hnoi搬poi/jy

Trójmian

读错了三遍题。

弱于 zjoi2017 多项式。

Kafelki

根据周期引理，如果$k+l-\gcd(k,l)\leq n$，那么$\gcd(k,l)$也是周期，并且显然不需要存在比它更小的周期，所以答案是$\gcd(k,l)$。如果$k+l-\gcd(k,l)>n$，那么$\max(k,l)>\frac{n}{2}$，不妨设$k>l$，那么我们知道如果没有$k$，$l$导致了$l$个等价类，而$k$的作用是合并了其中$n-k$对，所以答案是$l-(n-k)$。

Połączenia

考虑k短路说了啥，我们跑一个floyd，从每个点出发建最短路树，然后真的跑k短路。这里我们可以$O(nk)$跑一次，方法是不合并堆而直接爆力向上找。

Stage 3

Gra w dzielniki

如果这个数是一个素数，那么我们就需要遍历所有的素数。所以按任意顺序问所有的素数，问中了就除一下再问剩下的就好了。

Skarb

主要问题是两个人能不能相遇。我们分别找到环，进入环之前模拟一下，进入环之后只需要算个$\gcd$。

Sumy

考虑同余最短路，我们从$0$出发bfs，但是直接做是$O(na)$的，所以bitset维护一下就$O(\frac{a^2}{w})$了。

Kryształ

完全没懂它在说啥。

Małpki

终于有2e5题了。直接拓扑排序。

Tasowanie

把环求出来，然后直接算这个置换就好了。

#### XI(2003~2004)

Stage 1

PIN-kod

没看懂。

Zawody

模板 有向图最小环。跑两个bfs。

然后发现可能不太对啊!不过我们枚举第一条边走的是哪条边就好了。

Gra

跳棋/jy

读错题/jy

很容易想起sdoi2019 金币游戏，所以我们尝试转成staircase nim。发现两个空格之间就是一个staircase，然后就结束了。

Szpiedzy

也就是有一个内向基环树森林，那么我们在环上枚举任意一个点选还是不选把环断开，在树上直接dp即可。

Sznurki

原来string真的是弦而不是串串。

数量可以直接dp，把子树传上来的接起来即可。长度的话当然二分，然后就是接的时候最长的接最短的，次长的接次短的，这样的。长剖之后计排，复杂度$O(n\log n)$。

Stage 2

Most

好像很经典，但是我好像没见过。

考虑样例，容易想到我们可能让两个很慢的老哥一起过，此时对面需要有一个快的老哥等着回来。也就是说，我们可以

 - 让最快的人带一个人过去

 - 让最快的人和第二快的人过去，最快的人回来，两个人过去，第二快的人回来

一定是一个后缀被第二种带过去，枚举即可。

Bramki

问题是可能有环，有趣的是如果有环的话输出可能仍然是确定的，这个题意大概是对于一开始的状态，按任意顺序调整，直到。类似 viii poi Gra w zielone 的做法，我们全赋成$1$调整一遍，全赋成$0$调整一遍，如果一个门两遍得到的相同，那么它是确定的，否则它是不确定的。

Jaskinia

也就是求一个深度最小的点分治。

看起来很困难。考虑点分治本质是什么，发现它是给每个点分配了一个深度，然后我们找到深度最小的点划分下去，如果这个点唯一那么就可以建立一个分治结构，而唯一当且仅当两个深度相同的点不会出现在同一个分治块，也就是它们之间的路径上有一个深度更小的点已经把它们分开了。

考虑自底向上做，维护哪些深度有一个点满足上面还没有一个深度更小的点，这里深度是$\log$级别的。然后合并子树的时候如果有相同的，那么这个点的深度必须比它们小，分配尽可能大的深度即可。这么做是不劣的，因为大的深度可以由大的深度来解决，小的深度则需要小的深度，这玩意感觉上有点类似树上的某种进位，但是不是很理解啊。

考虑用一个简单的东西描述一个过程，这种做法可能叫compress?感觉它可以帮助你换扫描线方向，比如点分的方向是在点分树上扫，但是我们描述了点分树之后，就可以直接在原树上扫。但是也许除了点分治以外没有哪个题可以这么做了。

Przeprawa

又见面了。然而好像没有，这个直接爆力即可。

Turniej

考虑一个波特什么时候能赢，我们认为一条边从赢指向输，那么如果把没有边都当成双向边，从它出发可以到达每个波特，它就赢了，构造方法是在生成树上自底向上进行比赛。但是这个好像不是很行。

注意到如果有超过一个波特能赢，那么一个波特能赢，当且仅当它可以打败一个能赢的波特，因为它必须打败所有波特，而打败了一个能赢的波特的话，只需要先让这个波特打败别的所有波特即可。所以我们找到一个能赢的波特，然后找到所有可以打败它的波特，就得到了答案。

考虑凑一些限制，如果波特$u$必然不能打败$v$，那么说明$v$必然打败$u$和所有$u$可能可以打败的波特，那么$v$的出度必然严格比$u$大，所以我们知道出度最大的波特必然可能赢任何波特。

接下来找到所有能赢的波特，我们知道如果不是所有能赢的波特都到某个波特有边，那么这个波特也能赢。一开始把出度最大的波特标记为能赢的，每次取出一个能赢的波特，维护一个还没能赢的波特的列表，找到所有它不必然打败的波特，标记为能赢的。注意到每次一个还没能赢的波特没有被标记为能赢的，都要求新处理的能赢的波特到它有边，所以复杂度是线性。

Stage 3

Zgadywanka

为了得到满分，你需要赢三场。

我们直接找到概率最大的。如果这个数是$x$，还有$t$个数没出现，其中有$k$个$<x$的概率就是$x^k(1-x)^{t-k}$。

Wschód-Zachód

注意到主要问题是要到达中间那个狭窄的地方。直接在东侧模拟即可。

Wyspy

怎么还计算几何的。

为了把树建出来，经典做法是从边上往外画一条射线，考虑撞到的第一个多边形，它要么是父亲要么是兄弟。为了避免成环，每个多边形从最右的点往右画射线即可。为了画这个射线，使用线段树维护。

Kaglony

对于第一种，我们可以把每个连通块分开。对于第二种，在补图上把每个连通块分开。

但是怎么算补图的连通块啊?简单想法是bitset，复杂想法是别乳卡。更简单的想法是，我们每次加入一个点，然后枚举它的邻边，如果一个连通块中不是每个点都和它有邻边，那么发生了一次合并，这个可以维护没有边的连通块的列表做到线性。注意到每两轮必然分别是两种情况，所以边数会减少至少$n$，并且进行$n$轮必然结束，所以轮数是$O(\min(n,\frac{m}{n}))$的，当然一般来说很松。复杂度$O(m\sqrt{m})$。

Maksymalne rzędy permutacji

周期是所有环的周期的$\operatorname{lcm}$。为了最大化这个，我们必然选择一些不同素数的幂，然后从小到大排列它们，对得到的每一个区间转一下。现在问题是最大化$\operatorname{lcm}$，dp值我们猜测取个$\ln$就赢麻了，所以要用若干个素数幂做背包。为了卡常，注意到很大的素数不会用到，扔了就赢了。

Misie-Patysie

相当于平面上有一个棋子，你可以往左，往下，往左下移动。

不知道干什么的时候你就打个表，发现先手必败的状态$0$很少，只看$x\geq y$的部分，那么可以这么走出来 : 每一步可能是$x+=2,y+=1$或者$x+=3,y+=2$，记前者为$1$后者为$2$，则$0$的位置可以通过一个序列生成，序列的构造方式是一开始有一个$1$，接下来每次把$1$替换成$12122$，$2$替换成$12122122$。我们需要每次移动到一个$0$上，那么生成所有的$0$，然后找到一个即可。直接生成会得到长2e7的串，其实挺可以接受，但是你也可以预处理每一轮保留多长做到恰好够用。

#### XII(2004~2005)

Stage 1

Bankomat

一个密码可能出现，当且仅当去掉相邻的重复元素之后，它是所有移动序列的子序列。对每个串建子序列自动机，然后枚举每个密码上去跑，复杂度$O(10^lnl+\sum \vert t\vert)$，其中$l$当然是密码长度。

Punkty

经典问题是判断两个多边形是否相似，做法是转一圈求相邻边的点积和叉积，然后跑一个最小表示判断是否相等，如果允许对称则翻转之后再跑一遍。

现在问题是我们没法唯一地连成一个多边形。考虑求出凸包，剥掉凸包，求出凸包，剥掉凸包，如此直到所有点都被剥掉，然后依次比较每个凸包，每个凸包会确定一圈可能的变换，然后我们需要对这些东西求一个交，看起来很复杂啊。

考虑有没有一个简单想法。我们首先确定平移量，发现找到重心，然后把重心平移到重合即可。然后考虑放缩，可以选择距离重心最远的点，把这两个距离放缩到相等。然后考虑旋转，我们从重心出发记录相邻两个点的点积和叉积，然后跑最小表示。

Samochodziki

这个是 模板 离线寄存器调度问题。做法是贪心把下一次选择时间最远的放回去。

Skarbonki

当然是内向基环树，我们打开环就赢了，为此需要打碎每个环上一个点。

Skoczki

又见面了/jy

Stage 2

Lot na Marsa

又见面了/jy

然而这个没那么原，因为它让你求出所有解啊。问题是查询区间最小前缀和，这里单调队列即可。

Banknoty

已经不会背包了。单调队列。

Sumy Fibonacciego

加起来爆力模拟进位。

Kości

也就是给图定向，使得出度的最大值最小。二分答案，然后考虑网络流，直接建就行了，复杂度$O(m\sqrt{m}\log n)$。

Szablon

好像前两天汪娟给我看这个题来着。考虑答案必然是一个前缀，当然也必然是一个后缀。我们枚举一个前缀，考虑所有它的出现位置，如果这些出现覆盖了整个串那么就可行，这可以z algo求出来。所以我们只关心相隔最远的两次出现。从短到长枚举前缀，那么出现的集合会逐渐缩小，用链表维护所有的出现即可。

Stage 3

Dziuple

也就是求二分图的平面嵌入数。考虑连通怎么做，注意到如果左部最下面那个点是$u$，那么$u$的邻接点只能有最多一个还有别的出边，否则就会相交。设这一个点是$v$，那么$v$的邻接点只能有最多一个还有别的出边。所以图必然是一个毛毛虫，我们把主链两端的叶子数$+1$再乘起来，剩下的叶子可以随便排列，还要考虑翻转链和放在哪一边，再乘一个$4$得到答案。注意单点需要特殊处理。

考虑不连通怎么做，不是单点的连通块之间排一排，单点则可以插在任意位置。

Akcja komandosów

没太看懂。据说是求最小的前缀使得这些圆没有交。

考虑了随机增量，好像不太行。

考虑我们找到交中最右的点和最左的点，考虑前者，发现这个点必然是由一个圆中最右的点或者两个圆的交中最右的点贡献，继续发现它必然是所有两个圆交中最右的点中最左的。所以爆力枚举即可，复杂度$O(n^2)$。

Dwa przyjęcia

猜测答案必然是$n$。归纳，如果所有点都是偶度点就赢了，否则删掉一个奇度点$u$，得到一个方案，那么$u$必然到其中一边有偶数条边，另一边是奇数。不管加入到哪一边，$u$加进去之后，邻接点的度数就都变成奇数了，于是我们考虑能不能通过加一些边再递归下去，然后把这些边删掉换成$u$和它们之间的边。把邻接点之间的边全部取反然后递归，此时删掉这些边，那么到$u$有偶数条边的部分，$u$的邻接点度数都是奇数，此时加入$u$就赢了。

译自 Combinatorial Problems and Exercises by László Lovász。

Dwuszereg

容易想到抽象成xor方程组，这里问题是什么有若干个$x_i\operatorname{xor}x_j=0/1$，当然把它看成边，注意到每个点度数不超过$2$，所以是若干个环和链，模拟即可。

Autobus

usaco好像也搬过这个。扫描线BiT或者分治一下。

Lustrzana pułapka

首先注意到我们只关心是否回到了原点，所以可以把反射改成取模，也就是从一个边界出去则从另一个边界回来，这相当于撞了一个边界就进行一次对称。这个看起来性质要好一些。接下来自然考虑把它无限延伸变成一条完整的射线，而原点被复制无限份，不过这个好像没太有必要。

设射到了$(a,b,c)$，那么我们称这是一步，则会在$\frac{\operatorname{lcm}(2x,a)\operatorname{lcm}(2y,b)\operatorname{lcm}(2z,c)}{abc}$步之后撞到原点。所以我们得到答案是$(a+b+c)\frac{\operatorname{lcm}(2x,a)\operatorname{lcm}(2y,b)\operatorname{lcm}(2z,c)}{abc}$。

但是还有一个小问题，就是这里射线不能碰到棱，所以还需要算一下。注意到我们要么永远不会撞到棱，要么在第一次撞到原点之前就会撞到棱。考虑前两维，如果存在$\frac{a}{b}=\frac{(2i+1)x}{(2j+1)y}$，也就是$2(jay-ibx)=bx-ay$，那么就会撞到棱。exgcd一下，我们知道这等价于$\gcd(ay,bx)\mid\frac{ay-bx}{2}$。注意到这个式子成立当且仅当$ay-bx=k\gcd(ay,bx)$中的$k$是偶数，那么$\frac{ay}{\gcd(ay,bx)},\frac{bx}{\gcd(ay,bx)}$不可能都是偶数，所以它们必然都是奇数，所以也就是$ay,bx$中$2$的幂次相同。

现在可以一个$\log$算一个点的答案了。考虑什么样的点可能有贡献，注意到如果$a,b,c$都选的很大，并且分别和$2x,2y,2z$互素，显然是很优的。如果$a,b,c$都很小，那么好像就比较的拉。选择$a=x-1,b=y-1,c=z-1$，答案至少是$(x+y+z-3)\frac{xyz}{8}$，如果想要进一步改善，$a,b,c$中有至少一个要和$x,y,z$对应互素。考虑$x$以内最大的和$2x$互素的数，发现它要么是$x-1$要么是$x-2$。但是很遗憾，这里还有一个限制，不过我们预处理一下哪些互素，然后分别往下枚举一些检查那个不能碰到棱就好了。看了一眼，三个分别往下枚举$12$个就过了。

Prawoskrętny wielbłąd

注意要回家的。

画一画观察一下，猜测一条路径合法，当且仅当每个角都合法，并且边的方向没有跨过$1\rightarrow 2$的方向，或者说只能转一圈。正确性还是比较显然的。

那么从$1$出发，把$2$作为$0$排一个极角序。现在开始dp。设$dp(i,j)$表示当前刚走了$i\rightarrow j$的答案，那么转移可以转移到$0\rightarrow j$和$i\rightarrow j$两个半平面bound住的一个部分。注意到固定$j$，则可以转移到的部分是$0\rightarrow j$右侧，$j$出发顺时针排极角序得到的一个后缀，所以对每个$j$开一个前缀和优化即可。复杂度$O(n^2\log n)$，瓶颈是排序。

#### XIII(2005~2006)

Stage 1

Okresy słów

border和周期一一对应，这里好像就是要找一个最短border，那就真的把所有border跑出来就好了。但是应该没有这么复杂啊?

考虑我们类似于kmp，设$f_i$是前缀$i$的最短border长度，先爆力向$f_{i-1}$中插入$i$，然后最短border的信息就都包含在前缀$f_i$中了，跳$f_{f_i}$就得到答案。复杂度$O(n)$。

Krążki

模拟。

Żaby

请注意这里是平面，距离是欧几里得距离。

最小瓶颈树是线性的，主要问题是要求到每个点最近的关键点。把式子写出来，发现它是一个二维的东西，看起来我们需要把它化成一维的。

试了一下发现好像不能类似 货币兑换 一样做，那么就是不能直接化成凸壳了。考虑怎么让它简单一点，注意到两维是独立的(你不会没有把根号扔掉吧?)，所以先对每个点求出同一行的点中最近的，然后这个就变成了一个常数，再对每个点求同一列中最近的即可。总复杂度线性。

Tetris 3D

发现是矩形max矩形推平，然后这里max是单增的。满点集，四分树，复杂度$O(d^3)$，是不是就过了啊!

注意到并不是满点集，最大值必然在某个立方体的角上取得，所以只把这些点拿出来建2-dt，复杂度是$O(n\sqrt{n})$的。

由于max是单增的，也可以树套树俩$\log$。

Profesor Szu

没有环的话就dag dp。有环的话，只要可以走到环就是答案，所以从环出发倒着dfs即可。有向图找环，使用kosaraju或者tarjan scc。

Stage 2

Magazyn

当然切比雪夫转曼哈顿，然后就中位数了。转回来之后不一定是整数。

Szkoły

容易想到费用流，但是直接建的话边数是$n^2$的。哦network simplex是不是就过了啊?事实是，所有东西都过了。

由于$k$都不一样，看起来很难优化建图。

Metro

这里是允许交的。注意到我们每次必然是从已经选了的部分出发往边上扩展两条链，因为如果和已经选的部分不交，换一下就交了并且必然不劣。从一个直径端点出发长剖，选前$2l-1$长链。

Najazd

凸包上的差分，我们设$s(i,j)$表示从$i$顺时针转到$j$的区域中所有点的权值和。

Listonosz

我们把规定的一串边直接从起点连到终点。但是问题是，可能出现两个序列包含同一条边，所以需要先建一个空图把这些序列加进去，然后在上面dfs得到所有极长的序列，然后拿这些去跑。

Orka

考虑最后我们肯定会把一维全部删完，另一维则可以留一些不删。区间dp，设$dp_1(i,j)$表示第一维删到$[i,j]$，尽量删第二维，可以删到哪里。转移就往里删一步。

Stage 3

Tańce w kółkach

感觉小膜数很有用，所以先搞个式子。发现它就是$n![z^n](\sum\limits_{i=l}^\infty\frac{z^i}{i})^k$，那么猜测$n$很大的话直接全膜成$0$了，想了想发现是真的，因为$p$出现至少$\lfloor\frac{n}{p}\rfloor$次，那么注意到$5^\frac{n}{5}401^\frac{n}{401}$增长的显然比$n$快多了，所以比如$n\leq 1000$爆力卷，更大的直接输出$0$即可。

Estetyczny tekst

dp，设$dp(i,j)$表示最后一段选了$[i,j]$的答案，转移考虑上一段，发现就是某个长度以内的绝对值是一边，以上的是另一边，那么我们双指针扫这个分界点，前缀和优化即可。

Kryształy

容易想到从高到低数位dp。注意到如果一个数不顶上界了，它就完全自由了，剩下的数不管怎么选，它都有唯一的方式把剩下的数调整成正确的。所以我们考虑在最先不顶上界的数处统计一个方案，如果有多个那就取编号最小的。

Misie

大力dp。

Palindromy

题意好像是，给若干个回文串，求其中有多少对接起来还是回文串。

枚举长的，那么短的需要是它的前缀，插个trie即可。

Zosia

发现这个有向边其实是无向边，所以就是求一个最大独立集。注意到一个连通图的最大独立集不超过点数的一半上取整，所以只有$O(k)$个点在非平凡连通块中，套用$1.1996^n$的最大独立集，复杂度在有且只有一个非平凡连通块，大小为$2k+1$时最劣，所以是$O(1.1996^{2k})$。

遗憾，这个题直接随一个顺序贪心就过了。

#### XIV(2006~2007)

Stage 1

Drzewa

考虑我们直接枚举换完之后的四个符号，得到四维偏序，然后仨$\log$排序分治分治BiT即可。需要特殊处理相邻的。

注意到我们要换的位置左右哪个大哪个小是没有关系的，所以就只剩下两维了，也就是对于$i$有$a_i<\min(a_{j-1},a_{j+1}),\min\leq a_i<\max,\max\leq a_i$，对$j$同理。

Biura

也就是在补图求连通块个数，怎么感觉已经出过这个了。考虑枚举一个点，如果它到前面某个点有边则标记不合并，然后把剩下的都合并了，复杂度线性。

Zapytania

经典。莫反。

Osie symetrii

所有的对称轴必然过重心，所以先找到重心，然后维护哈希值和中心对称之后的哈希值即可。

Atrakcje turystyczne

从每个关键点出发dij，然后状压dp。

Stage 2

Grzbiety i doliny

模拟。

Powódź

注意到每个最低的点组成的连通块显然需要放一个，所以从小到大放，模拟一下它排空了哪些点。但是可能你会从一个谷里跳过去，复杂度就飞了，这就很麻烦。发现这是瓶颈路，所以考虑从低往高扫，某种意义上是自底向上扫答案的kru重构树。

Skalniak

考虑了很多强行做法，但是不好优化。考虑如果一个方案中$x=y$两侧都有点，那么全都翻到$x=y$的一侧必然不会让周长变长，画一画你就发现这些边全都对应起来了。

于是考虑如何最小化重量和。我们可能会把一些东西翻回去，要想不让周长变长，只能是做刚才那样的翻折的逆，所以画一画一共有四种可能的答案。赢了。

Megalopolis

差分，问题变成子树加单点查询。

Tetris Attack

考虑直接从左往右扫，维护还未匹配的部分，加入一个的时候往前找，如果有就换到一块，感觉除了它没啥东西可以正确了。用BiT维护还剩多少即可。

Stage 3

Koleje

看起来是一个斯坦呐树。两倍让我们想起tsp的近似算法，考虑用任意dfs序近似最小斯坦呐树，于是从每个关键点跑dij即可。

Gazociągi

注意到每个点的贡献是确定的。

Odważniki

先全都除掉最小的那个。考虑这个东西相当于，每个容器的容量是一个奇怪进制的数，那么从低到高尝试消掉每个容器的每位即可。也就是如果有一个容器当前这一位非零，那就去放。如果物品用完了，就看下一位，否则尝试把下一位也填满，这里优先填下一位非零的。

据说可以直接把所有的容器不进位地加起来。

Egzamin na prawo jazdy

完全没有一个方向啊。考虑每条路能到一个区间，那么能到所有路当且仅当能到第一条和最后一条。同时，第一条路能被一个前缀到达，最后一条能被一个后缀到达，所以答案是一个区间。注意到能到第一条路是贪心往右走，能到最后一条是贪心往左走，两边是独立的，所以可以分别求出加$i$条边最远可以到哪，然后卷起来。

先考虑第一条，最后一条是类似的。看起来我比较智障，可以发现跑一个lis，不在lis中的位置就是需要加边的位置，然后就结束了。

Klocki

容易想到$n^2$，设$dp(i)$表示最后一个选了并且有贡献的是第$i$个的答案，那么$i$可以转移到$j$，当且仅当$j-i\geq a_j-a_i$，也就是$a_j-j\leq a_i-i$。BiT即可。

Waga czwórkowa

感觉很困难。还是考虑数位dp，设$dp(i,j)$表示高$i$位，$i$及以上还有$j$没有消去的最小个数和方案数，这里$j$是以$i$作为第$0$位记录的。注意到如果一位选了超过$4$个，那么也一定不优，如果一位同时被两边选了，那么也一定不优。主要问题是$j$可以多大，显然它不能超过$2\log_4 n$，当然这个还是太松了，可以猜测它的绝对值不超过$2$，因为低位最多只能凑一个无限接近$1$的数。

#### XV(2007~2008)

Stage 1

Klocki

枚举最后我们选的区间，那么肯定它们都要贴到中位数上去。对顶堆即可。

Plakatowanie

单调栈，贪心地，这看起来确实是最优的。

Cło

二分图匹配。

或者发现我们只要找到一个生成基环树森林即可，所以dfs然后随便再找一条边。

Szklana pułapka

感觉很离奇。首先由于这是光，我们只要找到从每个点出发会在哪结束。考虑不会有两个这样的过程在某一时刻状态相同，否则它们必然来自同一个起点。

洛谷上的翻译没提到周长很小。爆力找到边界上所有点，然后模拟即可。

Robinson

相当于把每个障碍物都变成中心对称的船的样子，然后船变成一个点。bfs即可。

但是这里有$2000$啊?考虑找到船的中心，然后我们希望每次都能真的把一个位置推成障碍，那么容易想到bitset，但是这里不太需要，考虑我们顺着船的方向扫，那么每个障碍是一个长度先变大再变小的区间推平，注意到投影在扫描线上同一个位置的障碍，同时只有一个在贡献，并且一个贡献结束了就不再贡献，双指针一下，然后差分-前缀和就赢了。复杂度$O(n^2)$。

Stage 2

Blokada

建个圆方树，然后直接结束。

BBB

枚举转了多少次，然后我们会把前若干个$-1$改成$+1$，后若干个$+1$改成$-1$。现在$n\log n$是简单的。

考虑类似于某个经典题，发现其实我们所要的就是前缀和的最小值，因为它变成正的了就全都变成正的了，并且它必然可以变成正的。单调队列即可。

Pociągi

爆力hash。对每个等价类维护一个大小，一共有$O(n+m)$个等价类，一个车相当于查询了一个区间$\max$，四毛子即可。另外最好写的区间半群是并查集。

Mafia

这是一个内向基环树森林。dp，如果是树，设$dp(u,0/1)$表示$u$能/不能活到开枪的答案，转移枚举每个儿子有没有开枪，如果有儿子开枪了那么$u$就可以死。现在有一个环，钦点一个人，从他身后断开即可。

Ucieczka

感觉很厉害。考虑只能往右拐说的是啥，发现我们接下来可以干啥会受到且仅受到前两次转弯时位置的影响，于是可能的状态数是$O(n^4)$。前缀和优化，直接冲，直接过。小问题是按什么顺序枚举，按两维的差枚举就行了，类似于区间dp。

Stage 3

Lampki

请注意颜色$k_i$只是一个说法，实际上它们是互不相同的。考虑crt，发现对于$i$，答案是$\displaystyle\frac{\prod_{j>i}(p_j-1)}{\prod_{j\geq i} p_j}$。

Kupno gruntu

容易想到$n^3$，也就是枚举一边，双指针另一边。猜测我们需要一些好性质。如果一个数$\geq k,\leq 2k$，那么可以直接选它。如果一个数$>2k$，那么不可能选它。现在每个数要么是障碍要么$<k$。考虑如果有一行的一个区间和$\geq k$，那么必然可以删一些数使得它$\leq 2k$，所以就赢了。但是答案可能不是行的区间，继续考虑这个想法，枚举$y$上的投影，我们得到若干个列的和，如果一列的和$\geq k,\leq 2k$，直接选，如果$>2k$则是障碍，那么问题是求障碍之间有没有一段的和$\geq k$。考虑固定这个投影的上端点，枚举下端点，那么我们可以知道每个位置何时变成障碍，在它变成障碍的时候分裂它所在的段。倒过来把分裂改成合并，并查集维护，复杂度$O(n^2\alpha n)$。

然后发现这个过于复杂。注意到如果一个矩形不包含$>2k$的数，并且它的总和$\geq k$，那么它的子矩形中必然有解。考虑如果有一行的和$>2k$，那么这一行一定有一个区间是解，否则一定有若干行组成一个解。单调栈求个最大权子矩形即可。

Podział królestwa

也就是求一个子集到另一个子集的边数。dp，复杂度$O(2^n)$。但是这个题卡空间，那就一边搜一边算。

具体地，也就是你要把一个点从一个集合移动到另一个集合，那么边数的变化量是简单的。为了从这个生成所有可能的状态，枚举所有$2^n$个状态，然后总共发生$O(2^n)$次切换。

Trójkąty

直接做。注意到叉积的式子是$(x_b-x_a)(y_c-y_a)-(y_b-y_a)(x_c-x_a)$，展开之后每一项只和两个点有关，不过外面还有一个绝对值，发现这个符号就是它的方向，所以就是半平面数点，枚举一个点，给剩下的排极角序扫过去即可。

Permutacja

感觉之前有场cf出过这个。如果这一位卡着，那么就卡着了，否则这一位放一个更小的，剩下的部分可以随便排，一个还有$c$次没有出现的元素的贡献是$\frac{1}{c!}$，那么所有更小的的贡献就是$\frac{1}{c!}+\frac{z}{(c-1)!}$，BiT维护前缀积即可。

膜数不是素数，crt，维护一个数的时候附带当前考虑的素数的次数即可。当要做加法的时候，必然是直接统计进答案了，所以可以直接转成整数。

Stacja

发现如果两个点只需要一张票，那么一个是另一个的祖先，那么省掉的票的总数就是每个点的深度和。直接换根dp即可。

#### XVI(2008~2009)

Stage 1

Straż pożarna

注意到到两个点距离相等的点是一条折线，大概是这个样子 : 

![img](/img/xiv-poi-r1-a.png)

那么边上的都矩形数点数掉了，主要问题是中间那个。考虑平时我们是怎么数任意多边形的，差分成一条斜线下方的部分和一个矩形，那么斜着扫，维护每个位置下方的点数即可，BiT。

Słonie

考虑每个位置不对的数至少要参与一次交换，分开考虑每个环，对于那个转一圈的构造，一个数要参与$n-1$次交换，剩下的每个数参与一次交换。那么我们显然希望最小的那个数贡献$n-1$次。考虑也可能会换环外的，那么我们希望全局最小贡献$n$次，这个环上每个数贡献一次。每个环对这两种取个$\min$即可。

Gaśnice

考虑了网络流，但是不凸，所以只好dp，但是dp也不会处理$s$。

考虑直接贪心，我们在尽可能高的地方放一个灭火器即可，也就是一个灭火器总是可以比它匹配的子树内最深的点高$k$。需要维护所有未被覆盖的点，每次取出其中最深的，然后维护子树中的灭火器。每次让尽可能深的灭火器匹配最深的未被覆盖的点。复杂度$O(nk)$。

Kamyki

考虑其差分，发现就是staircase nim。

Przyspieszenie algorytmu

也就是每次取$p$或者取$s$，用相同的调用序列取得的值的集合也相同。取出来的都是区间，所以我们直接会了多项式复杂度。

可以猜测，把连续段缩成一个，只保留每个数第一次出现和最后一次出现之后，两个序列相同那就是相同了。但是看样例发现假了。考虑取$p$就是删到第一次出现最右的数的第一次出现，取$s$就是删到最后一次出现最左的数的最后一次出现，但是注意到删的时候可能影响别的数的第一次和最后一次出现，这就完蛋了。

注意到颜色个数很少，考虑这玩意有没有什么用，首先这限制了状态数不超过$2^{100}$。/jy

考虑对于每个左端点，向右找到每个颜色个数增加的位置之前，反过来也是一样的，这样我们得到$O(nk)$个状态，猜测只有这些状态是可达的。考虑如果一个区间$[l,r]$，比如取了$p$，没有得到一个这样的区间，那么继续向右扩展，颜色个数仍然不变。

考虑直接搞出每个等价类。按颜色数从小到大处理，那么根据上一句话，我们已经知道取$p$取$s$分别会到哪里了，然后还需要限制取$p$删掉的那个字符相同，所以对于每个颜色数，给每个等价类分配一个编号，那么颜色数为$i$的就是颜色数为$i-1$的两个，和一个字符乘起来，基排然后离散化即可。复杂度$O(nk)$。

感觉我理解的很不深刻啊。

Stage 2

Przechadzka Bajtusia

从两边往中间dp，设$dp(i,j)$表示$i$到$j$的答案，转移枚举两条边，转移的复杂度是$\prod\limits_{i,j}\deg(i)\deg(j)=O(m^2)$，然后转移的边权都是$1$，队列维护即可。考虑能不能把同一个字符的边搞得快一点，字符只有$\Sigma=26$种，注意到枚举了一个字符之后，可以$O(n^2\Sigma)$地计算这个子矩阵$\min$之类的东西，因为它的一维是啥跟另一维没有关系，只跟这个字符有关。复杂度$O(n^2(n+\Sigma)+nm)$。

Konduktor

dp，设$dp(i,j,k)$表示这次在$i$检票，上次在$j$，总共用了$k$次的答案。

Architekci

感觉感觉。建立子序列自动机，那么需要求一个长$k$的路，贪心地转化成最长路长度是不是足够。那么从后往前扫，用可撤销化数组存转移，对不够长的位置开个BiT，够长的位置直接维护最大的，那么只有在后$k$个位置，以及前面的位置中最多$k$次会操作BiT，所以复杂度就是$O(n+k\log k)$。

或者看看题解，发现合法当且仅当我们第$i$次选了$[b_{i-1}+1,k-i+1]$之间一个数。单调队列维护第一个$\max$即可。

Łyżwy

hall定理。重温一下经典，考虑这个也就是每个人匹配一个长$d$的区间，要求人是否有一个完美匹配，那么也就是求任何一个人的集合是否满足邻接的鞋比人多，也就是求鞋数减去人数的$\min$，称这个是权值。注意到最小的集合必然是一个区间，因为如果我们从小到大排序，相邻两个人邻接的鞋不相交了，那么这就分成了两个集合，其中某一个必然不比另一个小；如果所有相邻两个人邻接的鞋都相交，那么把最左边到最右边的人中间全选上必然不劣。于是现在我们要求一个最小子段和，线段树即可。

Wyspy na trójkątnej sieci

主要问题是怎么编码一个这样的图。感觉上直接用每一步绝对的方向编码就行了(而不是记录你怎么转弯这种东西)。

Stage 3

Wiedźmak

dij。状态数是$2^pn$，大约是1e6。但是需要注意一下边数，是$2^pm$的，大约是2e7。考虑有没有一个简单的$O(1)$ decrease key的做法，感觉一下没有。考虑是否有一个顺序让我们不用decrease key，感觉一下把手中剑的状态相同的分为一层，那么一层内的边需要dij，层间的则不需要。于是我们的堆大小就是$O(m)$，感觉上很可过。

Słowa/Słowa 2

考虑如果是给你了一个串应该咋办，毕竟我通过$k=0,k=1$可以拼出所有串。类似于找到所有$10$和开头的$0$，它们必然由$1$得到。最后一个$1$在上一轮是$0$还是$1$不能确定，但是此外的$1$必然由$0$得到。如果有两个相邻的$0$，那就爆炸了。如果最后只剩一个字符了，那就可行。所以我们会了$O(2^m)$。

感觉一下，状态只有$O(m)$种，因为只有最后一位在变啊。

现在考虑各$k$任意怎么做。每个串内部啥样是确定了的，但是边界上可能有问题。注意到每个串前两个字符必然是$10$，最后一个可能是$1$也可能是$0$，除了$k=0,k=1$的情况。找到所有$k\geq 1$的串，爆力维护$k=0$的。如果一个串最后是$0$，那么需要判断它后面是不是$0$。如果它最后是$1$，后面有一个$0$，那么这个$1$就要被拿出来跟后面合并。那么每个串可能，正常，最后一个位置本来是$1$而变成$0$了，已经消失了，强行维护一下即可。

Tablice

妈的，怎么还元素互不相同的。直接多重集hash。

Wyspa

发现我们希望尽可能贴着$1\rightarrow n$走，然后这条路好像就是所有边的半平面交。看看这个半平面交怎么求啊，发现对每个点只需要找到最低的和它有边的点。

Kod

读错题。

看起来复杂度是$O(L)$，其中$L$是总长。

也就是给一个每个叶子代表一个串的$01$ trie，求有多少个串$a$满足，对于任意可能出现的编码的前缀$s$，$s+a$在trie上不停贪心匹配，到最后恰好匹配完。发现$s$具体是啥是没有用的，只有它最后停在哪个点有用，于是也就是在任何一个 从根出发，走某个编码的后缀，然后走某些编码 可以到达的点，走一个$a$都会到根(叶子和根是同一个点)，那么爆力就是枚举一个起点，dfs地枚举一个串，复杂度$O(n^2)$。我们将 从根出发，走某个编码的后缀 可以到达的点称为关键的，将关键点走某些编码可以到达的点称为有效的。

考虑怎么找到所有关键点。找一个dfa匹配后缀，那么当然可以多串sam。或者考虑有没有什么$O(L)$的做法，考虑枚举一个点，处理它到子树中叶子的所有路径，也就是一边dfs子树一边同时dfs整个trie，这个东西复杂度是子树大小之和，看起来它是$O(L)$，因为子树大小不超过两倍的叶子数，而每个叶子会被算对应的串长次。

接下来找到所有有效点。注意到如果从一个关键点出发，经过根到达了一个有效点，那么这个有效点必然也是关键的，因为从根到它走的是一个串的后缀。所以每个关键点也只需要找到子树内的有效点。一边dfs整个trie一边同时dfs子树，如果离开了子树则剪掉即可。

接下来统计答案。对于所有有效点再类似地dfs，但是这次是如果到不了根则把这个字符标记为不行，如果到了根还没匹配完，则再递归到根，并记忆化一下。总复杂度$O(L)$。

Poszukiwania

可能没太看懂题意，说的大概是如果答案是yes则支付$1$，no则支付$2$?设$dp(i)$表示用$i$块钱可以搞定最长多长的区间。翻译比较奇怪，但是看起来$dp(0)=1,dp(i)=dp(i-1)+dp(i-2)$之类的。交互则记录转移。

#### XVII(2009~2010)

Stage 1

Kolej

每个栈必须是有序的。如果什么时候栈顶是接下来应该放的数，那么直接pop。现在考虑插入一个数，如果它比一边的栈顶小，比另一边大，那么当然插入这一边。如果比两边的都大，那么没救了。如果比两边的都小，这个是主要问题，猜测我们应该push进栈顶更小的那一边。但是这个看起来很假啊，因为有pop的话，我们可能会希望pop一串之后得到一个更大的栈顶，来放接下来比较大的一个数。

考虑一些强行做法。对于一个栈的情况，结论是如果存在$i<j<k$满足$a_k<a_i<a_j$，那么不可行。对于两个栈的情况，这里$a_k$是作为一个 不能进行pop 的限制，于是如果出现这种情况，$i,j$不能在同一个栈中。为了证明这是充要的，类似于一个栈的情况，我们知道在任意pop结束后的时刻，两个栈都是单调递减的，而递减就说明不会有数被卡死。

所以从后往前枚举一个$k$，在前面比$a_k$大的顺序对之间连边，然后二分图染色。于是也就是给若干个矩形的顺序对连了边。转而考虑两个点$i<j$之间何时有边，如果$a_i<a_j$，并且有$k>j,a_k<a_i$，那就有边了。于是找到$a_k<a_i$的最大的$k$，$i$向这个$3$-side矩形连边，主席树优化建图即可。

为了砍空间，考虑直接从下往上扫，扫到一个点的时候，它贡献了一个区间推平，如果两个推平冲突则无解，线段树维护即可。

Gildie

注意到我们不需要没有办事处的点，那么考虑随便找一棵生成树，奇数层分配裁，偶数层分配缝，就赢了。

Test na inteligencję

subsequence am，vector上二分找转移就好了。

Korale

hash。

Najdzielniejszy dzielnik

那么也就是求出现次数最多的素因数的出现次数。看起来并不能全pr一遍，所以我们就只分解三次根号以内的好了，看起来算量是4e7左右，然后开根，mr判一下，剩下的必然是两个素数的乘积。我们枚举每两个算它们的$\gcd$，就可以得到这些素数，然后试除一轮，可能还会剩下两个一起的，mr判一下，直接统计进答案即可，复杂度$O(n^3+nv^{\frac{1}{3}})$。

Stage 2

Antysymetria

由于它是对称的，可以manacher。或者二分hash。

Chomiki

考虑如果现在以$a$结尾，接下来再以$b$结尾需要的长度是确定的，因为保证了串互不包含，这个也就是求最长的$a$的后缀满足它是$b$的前缀，acam即可。然后矩阵快速幂即可。

Klocki

考虑什么时候一个区间合法，发现如果区间和$\geq k\cdot len$必然合法，如果不满足这个那么可能两边还可以救一救，但是发现答案必然没有被两边救，因为救完了之后算上两边就得到更长的区间。拆拆前缀和，大概是$s_i=\sum\limits_{j\leq i}(a_j-k)$，答案要满足$s_r-s_{l-1}\geq 0$，也就是$s_r\geq s_{l-1}$。单调栈即可。

Owce

强行dp，经典的，枚举一条边和这条边连向的点，那么划分出来的每个部分都是一个区间，然后就是三角形数点了。一共有$O(n^3)$个三角形，不过没有关系，使用经典的差分即可。需要排$n$次极角序，复杂度$O(n^3+nm\log m)$。

Teleporty

经典的，大力讨论，最后图有七层$1,S_1,S_2,M,T_2,T_1,2$，答案是所有相邻两层连成完全二分图，每层内部连成完全图。

Stage 3

Monotoniczność/Monotoniczność 2

看起来很带劲。设$dp(i,j)$表示是否存在以$i$结尾长度为$j$的子序列。发现只有$j\bmod{k}$有用，但是此时就需要记多长了，BiT一下，我们会$O(nk\log n)$了。

考虑怎么对每个$j$批量转移所有的$i$。画到平面上，考虑$<$怎么做，也就是每个点推平右上方所有点。感觉比较困难。

考虑怎么对每个$i$批量转移所有的$j$。对于$dp(k<i,j-1)$，如果$j-1,j$之间是个$<$，我们扫到$i$的时候只需要考虑$a_i$最小，且$dp(k,j-1)=1$的那个$k$。于是我们会$n^2$了，但是看起来很不够啊。

考虑有没有什么性质。强行猜测如果存在以$i$结尾长$j$的满足条件的子序列，那么必然存在长$j-1$的，然后啪的一下就做完了。但是遗憾，这个是假的，我只知道要么存在长$j-1$的要么存在长$j-2$的，但是不知道是啥结构。

考虑有没有什么别的性质。感觉比较厉害，强行猜测，虽然可行的$j$不一定连续，我们还是只需要维护最大的那个，设为$f(i)$。从左往右归纳，现在考虑到$i$，假设$j<i$的$f(j)$都是从前面的$f$中最大的那些转移来的，$p(k)$是$k$的最优决策点，设$j=p(i)$。我们尝试构造一个$i$结尾长度$>f(i)$，或长度$=f(i)$而转移到一个已经被归纳的情况的方案。设$p_{f(j)}=j,p_{f(j)-k}=p(p_{f(j)-k+1})$为$f(j)$对应的方案。

 - 如果$a_j=a_i$，在$f(j)$的方案中把最后的$j$换成$i$，得到的长度$\geq f(j)\geq f(i)$，而$f(j)$是从前面某个$f$转移来的。

 - 不妨设$a_j<a_i$，那么也就是说$f(i)-1,f(i)$之间的限制是$<$。还是考虑拿$j$凑个方案。

   - 若$a_{p_{f(i)-1}}<a_i$，还是可以在$f(j)$的方案中把最后的$j$换成$i$。

   - 否则$a_{p_{f(i)-1}}\geq a_i$，而$a_j<a_i$，于是$f(i)-1$到$f(j)$之间必然有一个限制是$>$，把$>$后面的位置换成$i$。

于是我们证明了，对于每个不从前面最长的状态转移得到的方案，都有一个从前面最长的状态转移得到的方案不比它劣。BiT维护一下即可。

Gra w minima

猜测每次被选的必然是一个前缀，前缀和优化dp。

为什么必然是前缀?考虑如果你选了一个前缀挖掉一些，那么对手下一步带上这些挖掉的地方不会更劣。

Latarnia

计算几何/jy，矩形反射得到矩形，所以大力模拟。但是好像会出来指数个矩形啊/yiw

Żabka

批量二分双指针求出转移到哪，然后倍增。

Jedynki

考虑直接算最左边的$1$后面是$0$的方案数，对应的最右边，然后减去只有一个$1$的。

首先描述如何计算两个这种表示的数的加减法，也就是讨论相加的两段分别是什么，以及前面有没有进位。看起来跟正常的加法是一致的。和的段数不超过段数的和。

然后开始计算这些方案数。简单地，只有一个$1$的方案数就是$n$的长度。

枚举最左边的$1$的位置，不管顶不顶上界，下一位有恰好一种方案，然后如果$n$开头是$10$，那么一开始会顶上界，方案数是$n$的后这些位，否则每一位都自由了，方案数是若干个$2$的幂，也就是一堆$1$加起来得到一串$1$。

右边看起来要困难一点，枚举最右边$1$的位置，左边是若干个$n$的前缀加起来。不过没有关系，考虑每个位置的贡献，发现第$i$位是$\sum\limits_{k=0}^i 2^k=2^{i+1}-1$，当然如果是$0$则没有贡献，所以也就是整个数乘$2$再减去$1$的个数。模拟即可。

Mosty

二分答案，然后有的边两个方向都能走，考虑用网络流给边定向。只考虑已经确定方向的边，每个点有一个入度和出度的差，把这个差搞成$0$就胜利了，同时我们知道度数，所以一个点应该有几条未定向的边指向它是确定的，匹配一下即可。复杂度$O(m\sqrt{m}\log n)$。

Piloci

首先可以枚举左端点二分。左端点从左往右，右端点也从左往右，所以可以两个单调队列。

#### XVIII(2010~2011)

Stage 1

Lizak

容易想到法，但是这里必要不大。考虑枚举区间长度$k$，然后把所有数都减去$1$，问题是有没有一个长$k$的区间有给定个$0$，那么发现每次加入一个$0$删除一个$0$，$1$的个数是连续变化的，所以求出最小值和最大值即可。

想了想你发现最小值和最大值好像也不是那么好求。那么也就根本不要这么做，设$s_i$表示$i$位置的后缀和，找到第一个$1$，设它在$p$，那么所有以$p$或$p+1$为左端点的区间拼成了$[1,s_i]$，那么完全在$p$右边的区间都已经没有用了。同理找到最后一个$1$。现在还剩下端点在第一个$1$左边，最后一个$1$右边的部分，它们是这两个$1$之间的和，加上若干个$2$。

Piorunochron

classic。在洛谷上你可能需要搜这个题的英文名 lightning conductor。

Przekładanka

也就是有两个环。这个题在arc出现过，看起来任意置换都可以换出来。但是想了想你发现逆序对数不对的不行。

感觉一下，注意到前三个就是某种窗口，a操作的作用是移动这个窗口，于是冒泡即可。但是有操作数限制，再感觉一下大概是不会爆的。

需要特判$n\leq 3$。

Konspiracja

注意是划分。那么如果两个人之间有一条边，他们就不能都在第一组，如果没有边则不能都在第二组，这个是充要的。考虑2-sat。结束了。

但是2-sat怎么计数啊?感觉很困难。考虑有没有啥性质。

考虑设第一组的大小是$k$，那么它合法，当且仅当第一组中所有点的度数之和是$m+\binom{k}{2}$。然后发现度数之和总是不可能比这个大，所以我们只需要考虑度数最大的$k$个点，如果可行，考虑其中度数最小的那些，尝试把它们换成一些度数相等的，组合数选一选即可。

Wykres

二分答案，然后向右贪心，但是随机增量需要你的顺序是随机的，所以我们先倍增地找到这一段大概的长度，然后在里面二分，复杂度$O(n\log^2 n)$。

Stage 2

Sejf

考虑对于最小的生成元$g$，整个群都是它的倍数，这里没有发生取膜。考虑我们可以辗转相减，所以如果有$a,b$则必然有$\gcd(a,b)$，那么最小的生成元必然整除剩下的所有数，否则取一个$\gcd$就得到更小的。

所以枚举这个最小的生成元$g$，它必然是$m_k$的因数，然后判断$m_1,...,m_{k-1}$中是否存在一个数是$g$的倍数，然后还需要它有可能是最小的生成元，看起来这个只需要当且仅当它也是$n$的因数，所以枚举$\gcd(n,m_k)$的因数即可。1e14以内最大的$d$在2e4左右，看起来不太行啊。

把每个素因数分开考虑，那么$m_1,...,m_{k-1}$每个数的作用相当于把各维都$\leq$某些数的位置给ban掉了。于是我们打个标记并做前缀和，这个前缀和是每一维前缀和的卡笛尔积，复杂度是$O((k\log\log v+d(v))\omega(v)+\sqrt{v})$。

另一个做法是把$\gcd(m_i,\gcd(m_k,n))$相同的数只留一个，据说得到的状态数会很少，经典的，$n$以内$k$-smooth数的个数，在$k$很小的时候近似为$\frac{1}{\pi(k)}\prod\limits_{p\leq k}\frac{\log n}{\log p}$，但是

Różnica

这个 出现过的 听起来就很困难。

注意到是极差，我们可以放成任意两个的差，然后你就会了$O(n\Sigma^2)$，也就是枚举最小的和最大的，赋成$\pm 1$求最大子段和，这里初值需要找到上一个字符的上一次出现，或者你可以拆前缀和。显然只需要在我们枚举的字符里面做，所以复杂度是$O(n\Sigma)$的。

Śmieci

也就是指定了每条边经过奇数次还是偶数次。我们可以且只能自由地给一个环的经过次数$+1$，要得到一个每个点度数都是偶数的，那么容易想到线性基，如果给的这些经过奇数次的边组成的向量在图的环空间中，那么就可以搞出来。所以跑一个dfs树找到所有非树边确定的环也就是基本环，它们组成一个环空间的基，我们可以把这些非树边换到前面来变成一个单位矩阵拼上一些可能是任何东西的树边的部分，所以也就是说我们把非树边搞对就赢了。然后差分一下找到每条边最后应该经过多少次，跑欧拉回路分解即可。使用四毛子lca，复杂度是线性的。

又看了看发现完全不对啊，给一个环的经过次数$+1$其实没有改变度数的奇偶性，也就是说我们保留所有经过奇数次的边直接跑欧拉回路即可。太智障了。

Rotacje na drzewie

注意到一个点换或者不换的贡献，跟子树中做了啥操作是没关系的，所以我们只是要求出换或者不换的贡献。这个是经典线段树合并，这里我们放了一个数的时候需要求它在另一棵树上的前缀和，带着这个前缀和递归下去即可，递归到只剩一边的时候就乘上子树中数的个数贡献进答案。

Temperatura

不太习惯poi说明部分分，我还以为整个题都$v\leq 50$。不过关系不大，dp，设$dp(i,j)$表示结尾于$i$，$i$的温度是$j$的答案，转移枚举上一个的温度，也就是推平为前缀$\max$，然后全局$+1$，并把比$l$小的和比$r$大的扔了。

那么你发现它总是单调的，这个推平其实啥用没有，所以用一个双端队列维护这些段就行了。

Stage 3

Dynamit

二分然后自底向上贪心，如果子树中有一个点距离为$k$的点还没被覆盖，那就在这个点上放一个。注意到未被覆盖的点中只有最远的有用。

然后需要考虑如果一个点有多棵子树，一棵子树放了的东西如何影响另一棵，我们只需要维护最近的放了的点。然后找到所有放了的东西里面最近的那个，看它能不能推掉所有没覆盖的里面最远的，如果不能就要在这个点放一个了。

另一个等价的做法是，按深度从大到小扫，每次找到一个还未覆盖的点，就在上面放一个，并标记所有被它新覆盖的点，每条边只会来回贡献两次，所以每轮复杂度是线性的。

Impreza

考虑如果两个点之间没有边，那么其中至少一个必然不在团中，注意到$\frac{2}{3}-\frac{1}{3}=\frac{1}{3}$，于是我们每次找到一对没有边的点删掉，剩下的就是答案。

Inspekcja

感受一下，只有所有子树大小都不超过$\frac{n}{2}$才行，也就是说最多只有两个点行。

Okresowość

考虑转成border，那么所有border的信息都被最长真border包括了，所以求出最长真border递归下去即可。但是如果最长真border长度不超过一半，那么中间会空一些，直接猜测判断如果目前是全$0$，则在最右边填一个$1$，否则填全$0$。为了证明这东西的正确性，画一画你发现如果填全$0$不行，根据定义当且仅当全$0$产生了新的周期，考虑一下，如果有一个周期长度不超过中间这一段，那么整个串都是$0$，此时在中间那一段最右边填一个$1$，剩下的还是$0$必然是可行的。

否则，先弱周期引理一下，设我们想要的那个最长真border的长度是$k$，那么它对应的周期长度是$n-k$，新产生的周期中最短的那个长度是$t$，那么$\gcd(n-k,t)$也是周期，如果它不比$n-2k$小那就没救了，然后你发现$\gcd(n-k,t)$

所以两边都是全$0$，。感觉挺对啊。

Meteory

过于经典。

Patyczki

考虑如果我们确定了两个短边，则只要找到某个区间中的三个出现过的颜色，使用st表，复杂度$O(n^2)$。

考虑怎么只带一个$n$，我们枚举最长边，设它的长度是$k$，以及另两条边的颜色，设它们的长度(还未确定)是$x,y$，那么要满足$x+y\geq k,x-y\leq k,y-x\leq k$。于是相当于问两个集合的笛卡尔积中，一个斜着的3-side矩形中是否有点。

画一画你发现这个查询看起来其实比较简单，它是查了一个有宽度的后缀，那么我们还是只需要一个斜着的单调栈，这部分排序双指针即可，总复杂度$O(nk^2)$。

优化也是简单的，我们只枚举一条边的颜色，然后单调栈的时候维护另一条边的两个特例，也就是考虑我们在画一条分界线的话，向左下走直到出现两个不同的颜色再向$x=y$贴近即可。复杂度$O(nk)$。

遗憾的，有远简单的做法。注意到如果固定了两条短边，那么长边我们肯定选最短的比它俩都长并且颜色不同的。于是我们排序后向下找到前两个颜色不同的，向上找到前两个颜色不同的，就赢了。

那么怎么找呢，直接扫过去，对每个颜色的最后一次出现维护一个堆即可。复杂度$O(n\log n)$。

Konkurs programistyczny

感觉好像很经典啊。

首先我们要匹配一下。然后要最小化这个罚时，洛谷翻译没说罚时是通过时间之和，呃发现这个相当于有个凸的费用，所以多加点边即可。

那么复杂度是啥呢。这个图有$n$个点$n^2$条边。发现死了。

注意到它再怎么说还是一个右部点的单重匹配，也就是说只有$n$条边有$1$的流量。如果我们能只更新这些边之类的就赢了。

想了想发现比较智障。不停跑一个最大匹配就赢了。这里我强力猜测复杂度是$O(n^{2.5})$，反正肯定不满。

#### XIX(2011~2012)

Stage 1

Festyn

这个看起来比较牛逼了。

首先可以差分约束一下得到是否有解。但是感觉这个没有必要。

考虑先把差确定的缩起来，我们对每个块钦点其中最小的作为代表元，那么一个块覆盖了$[x,x+a]$这样的。两个块之间的限制会是$x+c\leq y+d$这样的。于是可以推出一个形如$x-y\in[l,r]$的东西。其中$l,r$都有可能是无穷。如果$[l,r]$是空那就没救。

$x-y$有一个限制，$y-z$有一个限制，可以得到$x-z$的一个限制。考虑一下，如果两个块之间这样得到所有可能限制并合并，仍然有至少一侧的限制是无穷，那么无论如何都可以把它俩错开。无穷的方向也就是边的方向，于是我们跑一个scc，此时每个scc内部排好了，scc之间按照拓扑序放在数轴上即可。

于是考虑一个scc怎么做。由于这是scc，我们可以选一个主元表示每个所在的区间，这个对上下界分别跑floyd即可，然后问题就是给一些区间，每个区间的左端点有一个区间的限制，摆在数轴上使得覆盖的总长度最大。考虑贪心，按限制的左端点从左往右考虑，放在第一个还没被覆盖的位置。

然后发现我比较智障。由于这是scc，其中的值不管怎么分配都是连续的，简单归纳就可以说明这件事。于是只需要找到最大值即可。

Litery

classic。

Studnia

考虑如果没有这个需要挖到$0$的限制该怎么做。发现好像不是很会啊。

看成可以$\pm 1$了，想了一年slope trick，但是它不凸。

那么只能$-1$怎么做呢。二分个答案$d$先。考虑如果相邻两个数相差$>d$，必然让大的那个变小，于是就简简单单了。注意到从左往右扫一遍，如果$a_i+d<a_{i+1}$则$a_{i+1}\leftarrow a_i+d$，就可以解决答案中所有形如/的坡，因为我们必然先扫到坡底，而坡底左边根据归纳假设不会再变小(要么是形如\的坡的坡底；要么是形如/的坡的坡顶，已经处理过了；要么不属于任何坡)。于是两边各扫一遍就赢了。

那么现在需要挖到$0$了。把一个位置$p$挖到$0$，也就是把它两边bound成\/这样，注意到这个bound和上一步先做哪个都可以，于是我们做完上一步就只需要二分这个了。考虑左边，也就是在一个前缀中求$a_i\leq dp-di$的最大的$i$，那么维护前缀$a_i-di$的有序数组即可。直接注意到$a_i+di$和$dp$不降就赢了。

Randka

也就是求一个内向基环树上的lca。看看是不是属于环上同一个点的子树，树的部分直接lca，环的部分只有两种可能。

Odległość

也就是求一个曼哈顿距离最小的。大力分解先。

考虑每个数挂到它的所有因数，然后就赢了。复杂度$O(v\log v)$。

Stage 2

Tour de Bajtocja

感觉很难做。可以猜个结论，连接两个$>k$的点的边必然可以不删，因为删一条至少一个端点$\leq k$的边也可以断掉和它相关的一个环，而由于这是无向图，如果和它相关的环超过一个，可以想象一下大概比较有道理啊。剩下的就是图拟阵了，贪心，并查集维护即可。

Bony

爆力。

Szatnia

爆力是$O(\frac{qkn}{w})$。膜一个素数算方案数，莫队是$O(kn\sqrt{q})$。

考虑换一个顺序。判定性的东西都是可以提到前面来的，我们对每个$a$的前缀，求出位置最大的$b$的后缀使得背包有解。设$dp(i,j)$表示考虑所有$a<i$的元素，要凑出$j$，位置最大的$b$的后缀是哪一个，没有则是$0$。可以从$dp(i-1,j)$转移来，或者枚举所有$a=i$的元素。复杂度$O(nk)$。

Okropny wiersz

跑出runs。对于每次查询，首先枚举长度的因数，然后看有没有这个因数长度的run覆盖这个位置。一共有$O(n)$个run和$O(qd(n))$次查询，离线扫描线，总复杂度$O(n\log n+qd(n))$。

注意到如果$a$是非平凡整周期，$b$是非平凡整周期，那么$\gcd(a,b)$也是整周期。于是我们可以从$len$出发每次删去一个素因数，而删的顺序是无关紧要的，这样我们会得到$\log$轮查询，每轮有$q$个，但是每个run要塞到它的倍数去。根据the runs theorem我们知道这样塞出来的总数还是$O(n)$，所以还是离线扫描线，复杂度就是$O((n+q)\log n)$了。

考虑能不能不用runs。我们需要判断 $d$是不是$[l,r]$的整周期，同时我们知道 $pd$是$[l,r]$的整周期，那么实际上只需要判断 $d$是不是$[l,l+pd)$的整周期。对于$p>K$，$d$不超过$\frac{n}{K}$，可以一起扫一遍，这样的事情只会发生$O(q\log_K n)$次，扫的时候总要花费$O(\frac{n^2}{K})$；否则我们直接爆力hash，这部分是$O(qK)$。$K=\Theta(\frac{n}{\sqrt{q}})$时平衡，复杂度$O(n\sqrt{q})$。

然后发现我是智障。check一个周期等价于check一个border。复杂度$O((n+q)\log n)$。

Rozkład Fibonacciego

加加减减还是很带劲。先考虑几个简单的事情 : 答案不超过$\log_{\hat{\phi}} n+O(1)$。如果相邻两个fib数贡献都非$0$，那么我们可以把它们合并。$3f_n=f_{n+2}+f_{n-2}$，而$3f_1=f_4$，也就是说任何一个数系数的绝对值不会超过$2$，也就是说超过一位的退位就没救了。可以继续考虑到$2f_n=f_{n+1}+f_{n-2}$，也就是说任何一个数系数的绝对值不会超过$1$，证明的话让我们定义势能是每一位的位置乘上系数的绝对值的和，显然它非负，并且每次使用$2f_n=f_{n+1}+f_{n-2}$都会减小。

这自然让我们考虑一个问题 : 如何给出若干个fib数和的zeckendorf表示。一个简单的$n\log v$是用$3f_n=f_{n+2}+f_{n-2}$把最大值折掉$\frac{1}{3}$，边界处用$2f_n=f_{n+1}+f_{n-2}$递归更新。

于是在zeckendorf表示上dp，设$dp(i,j)$表示从高往低考虑到第$i$位，上面的退位是$j$，系数的绝对值之和最小是多少。感觉上$j$只可能是$\pm f_{i+2},\pm f_{i+1},0$中的一个，甚至可能$f_{i+2}$是取不到的，这就很带劲了。

题解做法比较厉害，直接找到最接近$k$的$f_n$然后取差，dp都不用了。洛谷题解证的很好。

Stage 3

Squarki

首先可以得到最小的两个数的和。最大的也是可以的。

这个解数看起来很困难，于是更加考虑能不能找到什么性质。

排序。考虑原序列排序后是$a_1,...,a_n$，那么这个和的第一位必然是$a_1+a_2$，第二位必然是$a_1+a_3$，第三位可能是$a_1+a_4$或$a_2+a_3$，这就麻烦喽。不过没有关系，我们知道了$a_1+a_2,a_1+a_3$，就知道$a_2-a_3$了。考虑怎么确定任何一个数，枚举$a_2+a_3$是哪一个，比$a_2+a_3$小的必然是$a_1+a_k$这样的，于是也就是枚举最大的这样的$k$，此时我们就知道了$a_1,a_2,...,a_k$。然后我们就知道了所有的$a_i+a_j(i,j\leq k)$，而剩下的里面最小的必然是$a_1+a_{k+1}$，这样下去就全知道了。复杂度$O(n^3)$。

Licytacja

也就是谁达到$x+y\geq n$谁就赢了。

一共只有$82$个$x$。搜即可。

Pensje

感觉很离奇。

对每个点求出上面最近的确定了的点和到它的距离，并考虑到有些值已经出现过，那么我们知道这个点的值就是某个前缀。把没有确定的点挂在这个前缀，已经确定的挂在已经确定的位置，此时如果一个前缀$k$挂了至少$k$个点，它和后面就分开了。如果一段中有且只有一个位置是不确定的，就可以确定它。一段内的值是可以交换的，因此它们并不能被确定，因此我们确定了所有可能确定的，这就证明了它的正确性。

Wyrównywanie terenu

恐怖极了兄弟。

也就是我们把每个数表示成$ax_i+by_i$，那么答案就是$x,y$分别做这个问题 : 有一个可能有负数的序列，每次可以给一个区间+1或-1，求最小的操作次数把所有数都变成0。考虑差分，相当于每次把一个移给另一个，要把整个序列变成$0$。可以发现答案就是差分的绝对值的和的一半。

首先对每个数exgcd求出一组解。然后我们可以$x_i\leftarrow x_i+k\frac{b}{g},y_i\leftarrow y_i-k\frac{a}{g}$生成所有解，其中$g=\gcd(a,b)$。也就是说要在若干斜率相同的直线上各选一个整点串起来，最后答案是在开头结尾各放一个$(0,0)$，相邻两个的曼哈顿距离之和。

注意到如果我们移动了$i$，$>i$的部分可以一样地移动，也就是说这不会改变后面的贡献。那么贪心让相邻两个最近即可。

但是实际上这会改变后面的贡献，因为最后需要回到$0$。考虑怎么把这个扔掉，如果可以像积木大赛一样，只算正的，并保证最后一个是负的那就赢了，但是这里允许只算正的就会不停选负的导致最后剩下的还是正的。这就没救了。

这是一道计算几何直觉题。考虑一个离奇想法，我们先做这个不管最后一段的，然后如果最后一段不优，再把它调整回来。如果相邻两个点是$(x_1,y_1),(x_2,y_2)$，最后一个点是$(p,q)$，判断移动$(x_2,y_2)$一步是否能减小答案即可。容易感觉到最多一共移动$n$步，因为我们跑出去的距离本来就不会太远，且两个位置的移动是独立的，我们选择使答案增大最少的$n$次前面的移动，依次计算总的答案即可。

Bezpieczeństwo minimalistyczne

看起来比较的有趣。

考虑每条边就是一个限制$a_u+a_v=k$。注意到对于每个连通块，确定一个就确定了所有的；如果有一个奇环，那么最多有一种可能。

假设图是连通的。如果不是二分图，则设一个是$x$，随便找一棵dfs树推出所有的，并解出$x$；如果是二分图，还是设一个$x$推出所有的，此时可以得到一个区间的限制，比如如果一个点初始点权是$a$，最后是$kx+b$，那就要求$kx+b\leq a$，这里$k=\pm 1$。可能还要求了减完的点权也非负吧，那就还有一个$kx+b\geq 0$。最后就是$x\in[l,r]$。由于每个点点权的减少量也是$x$的一次函数，我们知道两端必然分别取最大值和最小值。

Hurtownia

不凸，所以不是费用流。

容易考虑dp，但是感觉很困难。

考虑如果进货都在购买前，我们就从小到大选。

猜测还是从小到大选。如果不是从小到大选，那就会出现扫到某刻，我们不选$b_i$而选$b_j>b_i$，其中$b_i,b_j$排名相邻。如果$i>j$显然选$b_i$，如果$i<j$，那么我们就需要置出前面一个，而前面的都更小所以必然不优。BiT维护即可。

Prefiksufiks

对每个前缀求出最小表示，每个后缀求出最小表示，前缀爆力维护significant suffix就是$O(n\log n)$，后缀则是线性的。这才1e6直接冲了。

可以比较容易地线性。循环同构border就是$st...ts$这样的。那么我们先枚举一个border $s$，问题就是求删掉它后剩下的里面的长度不超过一半的最长border $t$。

考虑从中间往两边扫。注意到如果$[l,r]$有border $[l,p]$，那么$[l+1,r-1]$有border $[l+1,p-1]$。于是如果$[l+1,r-1]$的长度不超过一半的最长border长$k$，$[l,r]$的长度就不超过$k+2$，于是这里有一个均摊，用hash check一下即可。

还有一个牛逼trick!注意到因为我们删去的是border，两边的长度是相等的，我们把这个串重新排成$s_1s_ns_2s_{n-1}s_3s_{n-2}...$，那么border就变成了回文。

#### XX(2012~2013)

Stage 1

Usuwanka

考虑如果我们可以找到连续的$k+1$个可以消除的，那就消除它们，然后两边接起来。最后倒着输出，由于正着看中间的都是消掉的，倒着看中间的就都是没消掉的。

猜测我们真的可以找到。证明考虑每$k+1$个一块，如果没有一块包含恰好一个黑色，必然有至少一块只包含白色，并且这样的块里面必然有至少一个和一个包含黑色的块相邻。每次操作之后只需要重构$O(1)$块。复杂度线性。

然而实际上只需要开个栈就好了。

Cennik

如果$b\geq a$，那是好做的，只需要给每个点的邻接点们，挂个虚点优化建图即可。

如果$b<a$。那么此时考虑一个点$u$，我们需要只给$u$邻接点中没有边的点对两两连边。

一个想法是考虑把邻接点之间的邻接矩阵画出来，然后数据结构优化建图。具体地，考虑一行，也就是$v$到各$w$的边，存在$v\rightarrow w$的$w$会把这一行分成若干段，如果有$k$段我们就要连向$k$个区间。这里面每条边会出现两次。但是有问题。一条边会出现多个点的优化建图中。这就需要我们深入分析一下，如果一个点度数是$d$，那么它会产生一个不超过$\min(d^2,m)$的贡献，那么总共就不超过$O(m\sqrt{m})$。现在我们可以用一个$O(1)$向区间连边的东西，st表即可。复杂度$O(m\sqrt{m})$。

但是这里我们有$2m\sqrt{m}$条边，空间飞了。这就不好。

让我们看看题解怎么做的。首先发现这个$b$的所有用处就是如果一条路中两条相邻的$a$不能替换成一条$a$，则可以把它们替换成一条$b$。先跑一个最短路，那么最短路中相邻的两条边肯定不能替换成一条边，我们尝试尽可能替换成$b$，如果最短路长度是偶数，那么答案必然要么是全$a$，要么是全$b$的；如果是奇数，我们就会剩一个$a$替换不了，此时可能会希望选择一个长偶数的，第$2k-1,2k$条边不能替换成一条的最短路，然后全部替换成$b$。

那么这个东西怎么跑呢。看起来就是挖掉所有三元环。考虑到这是bfs，搜到一个点之后就不再需要它作为距离$=2$的点了。注意到三元环只有$O(m\sqrt{m})$个，考虑如果现在处理$u$，我们标记$u$的邻接点，然后枚举$u$的邻接点$v$，枚举$v$的还未访问的邻接点$w$，如果存在$u\leftrightarrow w$，那就跳过$w$，否则更新$w$，并在所有点第二层枚举的边表中删掉它。这样每个三元环会贡献$O(1)$次，复杂度$O(m\sqrt{m})$。

Gobeliny

每个限制bound出了一个多边形区域，我们需要求一个交。

这个太离谱了，考虑点简单做法。如果没有暗墙，这是一个经典的半平面交问题。注意到对于一段连续的暗墙$M$，设两边的顶点是$A,B$，那么$AB$和$M$围起来的区域都是暗的，也必然只有这样的区域是暗的，并且光源必然在直线$AB$上。所以把所有连续的暗墙的两端连起来跑半平面交，然后判断光源的范围(可能是一个点或一条直线)是否和半平面交有交即可，这也可以直接塞进半平面交来实现。或者可以 如果是点，直接检查一遍；如果是直线，把每个半平面拍到这条直线上变成$\geq x$和$\leq x$。

下面是第一遍的考虑。

如果有暗墙，考虑一段暗墙和两边的亮墙相接的地方，设这两个点是$A,B$，那么画一画可以发现由于多边形是连续的，光源必然在$AB$上。于是如果有两段暗墙就可以确定光源的位置。

先考虑如何check一个光源。我们向每个顶点发射射线，经过一个顶点则标记射线的这一侧被挡住了，离开了多边形则停下。如果离开时撞到边，如果有至少一侧还没有被挡住就无解。如果撞到点，标记这个点一侧亮另一侧暗。看起来实现复杂。

那么我们考虑只有一段暗墙怎么做。把$AB$连起来记为亮墙，然后判断半平面交和$AB$是否有交即可。

Taksówki

分为从$0$到$d$和从$d$到$m$两段。

到$m$最多需要一辆单独的车。任何一辆足够行驶$m-d$的车都可以。

到$d$的过程，看起来我们会让所有车从大到小出发。如果只剩下一辆足够行驶$m-d$的车，需要判断它能不能把你送到，不能的话则从$<m-d$的里面再派。

Multidrink

看起来很厉害。

首先方案倒着还是方案。首先找到$1\rightarrow n$这条链，想象我们从左往右走。会需要进入子树。比如链上有一个点$u$，它左边是$l$右边是$r$，且有儿子$v_1,v_2,...$，那么一旦从$u$进入$v_1$子树，离开的时候必然站在$v_1$，因为$u$已经走过了。也就是说我们进入的时候必然选择$v_1$的某个儿子，从它走到$v_1$。注意到如果有子树$v_2$，由于$u$已经走过了，我们进去只可能踩$v_2$，这导致我们出不来，所以不能有子树$v_2$，也就是链上每个点只能挂一个儿子。

考虑子树内。现在有一棵树，我们站在根$u$的儿子$v$上，要遍历整棵树最后到$u$。那么我们类似地知道如果$u$只有$v$一个儿子，我们就递归到$u$的某个儿子；如果$u$还有恰好一个儿子$w$，那么$v$必须是一个单点，否则一旦向下进入它儿子的子树，上来的时候就只能到$u$，而$w$还没有被遍历。于是我们知道$u$的儿子必须是若干个单点和一个任意的什么东西。然后考察这个任意的什么东西，继续讨论可以发现它必须是一个菊花。

现在我们解决了站在$u$上的问题。如果我们站在$l$上，可以直接进入一个儿子，此时还需要更多的讨论。这实在是太困难了，让我们dp吧!

设$dp(u,0/1/2)$表示$u$子树，从$u$进从儿子出/从儿子进从$u$出/从儿子进从儿子出 的方案是否可行，然后在链上从左往右再写一个dp。看起来还是很复杂。反正这就是个复杂题/oh

Stage 2

Spacer

两个01串之间怎么到达呢。注意到$k$只有1e6，我们从两个串出发分别搜出连通块中1e7个串，如果都能搜出来我们就断定连通，因为此时再断开它很困难啦。

草，我居然直接猜出题解。感觉很厉害。

具体一点是只需要搜$nk+1$个点。证起来比较困难。

Inspektor

看起来很困难。按时间排序先，然后有记录的人第一条和最后一条就确定了一个区间，先把它们覆盖一次。接下来如果一个人比如左侧的记录不满，那就让他往左一步，如果左侧还不满那就继续往左，这个可以用线段树维护。剩下的用没出现过的人积木大赛。这个只能跑判定，所以二分一下就好了，复杂度$O(n\log^2 n)$。

足有5e6，不得不砍砍你的$\log$。考虑怎么把线段树省掉，发现类似于积木大赛的单调栈证明来做就赢了。具体地，如果当前这一位限制是$h$，前面有$c$个能用的右端点，如果$c>h$则$c\leftarrow h$，因为超过的部分不能延申过来了；如果$c<h$则要右边的左端点来补充。维护一个单调栈，把$h-c$插入进去，弹掉的部分喂给积木大赛。当我们遇到一个能用的左端点时，对单调栈进行一个全局减，维护全局标记即可，可能需要弹掉栈底，所以实际上这是一个队列了。这就可以线性地check。

看了一眼题解。遇到左端点的部分可以认为是前面先喂给了积木大赛，然后这个左端点把它接上了。于是这个单调栈也没有用了，弹的时候就对应于，先尝试限制右端点的部分，如果还没弹够就继续限制积木大赛的部分。

Łuk triumfalny

显然B不会走回头路。考虑一个类似于超现实数的想法，dp，设$dp(u)$表示B站在$u$，$u$是黑的而子树其它点都是白的，只考虑$u$子树的情况对应的数，那么B可以选择向任何一个儿子走，而A必须把所有儿子都操作到$\leq 0$才能获胜。于是也就是$dp(u)=\max(0,\sum\limits_{v\in\operatorname{ch}(u)}(dp(v)+1)-k)$。二分即可。

Konewka

线段树维护一下$<k$的$\max$，如果有$=k$的就找出来标记。

Morskie opowieści

感觉好像很眼熟啊。考虑我们总可以在一条边上横跳，所以拆点分别跑长奇数和偶数的最短路即可。

Stage 3

Gra Tower Defense

直接随便选一个还没被覆盖的点就是对的，因为在那个存在的解中每个点要么是塔要么和塔相邻，所以随便选一个点必然到某个塔距离不超过$1$，因此覆盖了这个塔所覆盖的。

问题是怎么找覆盖了哪些点。维护每个点到最近的塔的距离，爆力更新即可。复杂度是线性的。

Bajtokomputer

看起来比较厉害。简单想法是从左往右找到第一个$1$，然后右边都结束了。于是我们也知道没有必要产生一个$>1$的数。用dp确定$-1,0,1$三段分界的位置即可。$-1$段从开头的极长连续$-1$开始，$0$段必须只包含一开始就是$0$的，$1$段从一个$1$开始。

Gdzie jest jedynka?

总是只需要一次比较。爆力是用$n^2$次$d=n-1$的查询找到$1,n$，然后用一次比较确定哪个是$1$。

考虑如何优化。我们随便找一个数，和它差最大的数要么是$1$要么是$n$。大力试除可以$O(\frac{n}{\log n})$地得到一个数。但是这个看起来比较困难啊。

考虑一个牛逼想法。我们维护一对相距最远的点，从第$\lg n$轮开始往下进行，第$i$轮让它们往两边扩展$2^i$，如果某一侧不能扩展则不扩展(假装自己扩展了)。但是这里有一个问题，我们不能判断距离是否$=2^i$，这还是比较难受。不过不需要判断这个，如果上一轮最后两个点距离是$k2^{i+1}=2k2^i$，我们去找那个距离为$(2k+1)2^i$的即可。这样扩展一轮是$O(n)$的。此时我们会得到最多六个点，在其中爆力找到相距最远的两个继续进行，直到它们的距离为$n$，这里求距离是$O(\frac{n}{2^i})$的，没有必要再除一个$\log$了。总复杂度$O(n\log n)$。

考虑了怎么确定剩下所有数。看起来是无法做到$O(n\log n)$的。

Łańcuch kolorowy

对前缀桶进行字符串hash，那么区间桶的hash就是两个前缀桶的差。

Labirynt

什么惊悚题。

看了一眼题解，感觉很厉害。大概是说，我们首先选出四个L作为顶点，要满足顶点之间LR个数相同，此时顶点之间可以看成一条很粗的边，为了避免碰撞，两头搞到足够长就可以了。然后要搞定每条边内部。假设第一位是L，那么找到第一个R满足它们之间LR个数相同，这可以用桶找到。递归搞定里面，外面接上这一个L一个R得到的还是一条边，然后再把它跟后面接起来。复杂度线性。

Laser

每条线段也就是一个极角区间。把所有点排极角序，每个间隔需要处理出如果射线射在这里，经过多少线段，以及经过的线段中最远的端点，然后就是选$k$个不交的区间使得权值和最大，前缀和优化dp即可。复杂度$O(n(k+\log n))$。

这个题同时是[cf16 exhibition final I](https://atcoder.jp/contests/cf16-exhibition-final/tasks/cf16_exhibition_final_i)。

Polaryzacja

考虑最小值。二分图染色，每条边从黑点连向白点，这样答案是$n-1$。显然答案不可能更小。

考虑最大值。比较困难。dp个先，设$dp(u,i,j)$表示$u$子树，$u$能到的有$i$个，能到$u$的有$j$个的答案。复杂度$O(n^3)$。转移的时候$i,j$只有一个有用，可以把空间压到$O(n^2)$。

这个最大值比较厉害。结论是我们找到重心，让一些子树指向重心，剩下的子树从重心发出，答案就是内部的加上两部分的大小乘积。背包一下使得两部分的大小尽可能接近。复杂度$O(n\frac{\sqrt{n}}{w})$。

如何证明这件事呢。考虑先证明必然有一个点是一些子树指向它，剩下的子树从它发出。

断言存在一个这样的点，当且仅当所有极长链有交，当且仅当不存在四个点$u,v,a,b$满足$u\rightarrow a,u\rightsquigarrow v,b\rightarrow v$。那么考虑存在这样的$u,v,a,b$时，以$u\rightarrow v$为根将树拎起来，设$i_a,o_a$为$a$子树中能到达$a$/$a$能到达的点数，那么这两端原本的贡献是$o_a+o_b$。翻转$a,b$子树中所有边和$u\rightarrow a,b\rightarrow v$，贡献变成$\geq o_a+o_b+o_ao_b$，必然不劣。

然后证明这个点必然是重心。如果它不是重心，不妨假设最大的子树，大小为$s$，且指向它，那么把它向最大的子树移动一步，指向它的部分大小$c$不会变大，而如果$c>\frac{n-1}{2}$，$c$越小子树间的贡献越大，因此答案不会变小。

#### XXI(2013~2014)

Stage 1

Wąż

强力dp。

[官方题解](/file/xxi-poi-waz-sol-pl.pdf)以一种不错的方式描述了这个题的结构。[这里](/file/xxi-poi-waz-sol-zh.pdf)有一个deepl机翻。

Klocki

如果没有两边的颜色，我们能放最多的就放最多的，不能就随便放一个，相同数量按数值为第二关键字排序。注意到这样可以保证如果两边颜色可以不同，那么构造出来就是不同的，于是如果两边的颜色限制不同也赢了。

如果两边的颜色限制相同，我们把这个颜色拿出来作为"随便放一个"的唯一候选，直到把它用完。

看一眼题解，这玩意能线性。拿个链表即可。

Hotele

classic。

考虑如何线性。对于某三个点，按深度从大到小是$u,v,w$，center是$c$，它们到$c$的距离都是$d$。长剖，在$c$处统计每个$d$的$u,v$对数，然后把它挂到所有祖先上，对于$k$级祖先，要一个距离$d-k$的点作为$w$，这可以在一个上传的数组上打一个标记。

设$f(u,i)$是$u$子树距离$u$为$i$的点数，$g(u,i)$是$u$子树lca为$u$的距离为$i$的点对数，$h(u,i)$是$u$子树中所有在$u$上要一个距离$i$的点的标记，那么$f$就是儿子们$f$的和平移一位，$g$就是$[t^2]\prod(1+tF)$，$h$就是平移一位再加上这里的$g$。$g$的长度不超过最长的轻儿子的长度，于是$g$合并到$h$的复杂度就摊给了这个轻儿子。

Kurierzy

classic。

Bar sałatkowy

还是看成$\pm 1$保证和非负吧。如果总和是$s$，那么$i$位的前缀和$l_i$和$i+1$位的后缀和$r_{i+1}$满足$l_i+r_{i+1}=s$，要求$r_{i+1}$非负也即要求$s-l_i$非负，也即$l_i\leq s$。

设全局的前缀和是$p$，考虑区间$[l,r]$，那么$s=p_r-p_{l-1},0=p_{l-1}-p_{l-1},l_i=p_i-p_{l-1},0\leq l_i\leq s\Leftrightarrow p_{l-1}\leq p_i\leq p_r$。也就是求有多少区间$[l,r]$满足$p_l,p_r$分别是区间$\min,\max$。

枚举$l$，那么右侧的非严格单调栈上都满足$p_r$是区间$\max$，而$l$在一个前缀是区间$\min$，二分即可。这个前缀可以用另一个单调栈求出。

考虑如何线性。瓶颈在于二分 右侧递减单调栈的第一个元素在递增单调栈中的前驱，考虑分散层叠，我们用链表维护两个单调栈(右侧递增和递减)的归并即可。

Stage 2

Karty

如果只问一次，贪心。

线段树。对于每个区间，维护第一位的卡是正面/反面时，最后一位的卡应该是正面还是反面。

Przestępcy

如果没有这个起点颜色相同的限制，直接跑两遍子序列自动机，复杂度$O(n\log n)$。

如果有的话，考虑枚举中间这个位置，往两边倒着匹配，留出尽可能长的前后缀，看其中有没有相同的颜色。

注意到每个颜色出现最多一次，这里就有均摊了，以左边为例，从左往右枚举中间，尝试最后一位的匹配位置能不能右移，如果可以则继续尝试倒数第二位，这样的。由于每个颜色只会扫过一遍，复杂度是线性。

剩下的问题就是怎么看一对前后缀有没有相同颜色。开个桶，如果从左往右扫，从右往左撤销后缀的桶即可。

Superkomputer

牛逼题。

曾经出现在21年sd省队胡策的qc赛。

大致译自 https://fajnezadania.wordpress.com/2014/04/13/superkomputer/ 。

倒过来变成剥叶子。这有一个好处，我们剥一个叶子不会让叶子的数量增加，只会让它不变或减少$1$。

那么首先我们知道如果现在叶子数$\leq k$，所需的轮数就是树的高度。如果叶子数$\geq k$，我们每次必然选满$k$个。

由于叶子的数量不会增加，而到了叶子数$=k$的时候答案就确定了，一个贪心的想法就是先剥最深的叶子使得树高尽可能减小。但是这样有可能会使得叶子数更快地减小。

考虑枚举最优解中叶子数$=k$时的树高$h$。设$c_h$是$\geq h$的所有层的点数和，那么我们至少需要$\lceil\frac{c_{h+1}}{k}\rceil$轮才能剥完它们，接下来还需要$h$轮结束。但是直接这么估计是有问题的，因为我们并不一定每次都剥了一个深度$>h$的点。不过注意到$\lceil\frac{c_{h+1}}{k}\rceil$是轮数的一个下界，我们把所有东西都取一个$\max$得到一个更紧的下界。接下来证明这个贪心达到了这个下界，从而同时证明它就是答案。

考虑我们选择了深度最大的$k$个叶子，有深度相同的则任意选。设其中最浅的那个的深度是$d$，树高是$H$。如果$h<d$，那么$h+\lceil\frac{c_{h+1}}{k}\rceil$显然减少了$1$。如果$h\geq d$，那么$h+\lceil\frac{c_{h+1}}{k}\rceil$可能不变，于是我们希望说明它必然不是原来的$\max$。由于选择了深度为$d$的叶子，$>d$的每一层点数都$<k$，因为每一层的点数都不超过下一层点数加上这一层叶子数，在这一轮操作前后都是这样的。于是我们知道对于$h\geq d$，$h+\lceil\frac{c_{h+1}}{k}\rceil\leq h+1+\lceil\frac{c_{h+2}}{k}\rceil$，这是因为$h+1$层的点数$<k$。于是$\max\limits_{d\leq h\leq H}h+\lceil\frac{c_{h+1}}{k}\rceil=H$。既然$H$减小了$1$，我们知道$\max\limits_h h+\lceil\frac{c_{h+1}}{k}\rceil$就减小了$1$。

剩下的问题是如何对每个$k$求$\max\limits_h h+\lceil\frac{c_{h+1}}{k}\rceil$。考虑怎么把取整去掉，我们把$h$塞进去，就变成$\max\limits_h \lceil\frac{hk+c_{h+1}}{k}\rceil=\lceil\max\limits_h \frac{hk+c_{h+1}}{k}\rceil$。也就是有一堆一次函数$h+c_{h+1}x$了。为了使用凸壳，转而考虑有一些点$(-c_{h+1},h)$，用斜率为$x$的直线去截，截距即为$h+c_{h+1}x$。要求截距的最大值，求上凸壳然后扫过去即可。复杂度$O(n)$。

感觉在这个问题上倒着性质确实更好。

Ptaszek

classic。

dp。$dp(i)=\min\limits_{j=i-k}^{i-1} dp(j)+[a_j\leq a_i]$。容易想到线段树，但是不行。

注意到这里代价只有$0,1$，那么存在一个最优决策只使用$dp(j)$最小的某个$j$，维护$dp$为第一关键字，$a$为第二关键字的单调队列即可，也就是dp相同的保留$a$最大的这样的。

Rajd

感觉很眼熟。原来是出现在sdptt2021 r1的讲课环节。

考虑排个拓扑序，那么删一个点，以它前面的点结尾的路径不会被影响，以它后面的点开头的路径不会被影响。两部分各自内部是容易线性的。两部分之间的边$u\rightarrow v$会产生$f(u)+g(v)+1$的贡献，在$u$处加入$v$处删除，离线并查集可以做到$O(m\alpha(n))$。

Stage 3

FarmerCraft

看到farmer就条件反射了，poi玩usaco模拟器是吧/cf

dp，设$dp(u)$表示$0$时刻进入$u$子树的话，最后一个装完的时间。转移考虑进入各子树的顺序，每个子树有遍历时间$a$和代价$b$两个参数，答案是$\max\limits_i b_i+\sum\limits_{j<i}a_j$。容易想到邻项交换。设前面的和是$s$，相邻两个是$(a_1,b_1),(a_2,b_2)$，对后面的影响相同，对答案的贡献是$s+\max(b_1,a_1+b_2)$。要凑$\max(b_1,a_1+b_2)\leq \max(b_2,a_2+b_1)$。考虑怎么才能拆出来。

 - 如果$b_1\leq a_1+b_2$，那么也就是$a_1+b_2\leq\max(b_2,a_2+b_1)$，由于$a_1+b_2>b_2$，也就是$a_1+b_2\leq a_2+b_1$。

 - 否则也就是$b_1\leq \max(b_2,a_2+b_1)$，必然成立。

合起来也就是如果$b_1-a_1\geq b_2-a_2$，那么$(a_1,b_1)$排在前面。

Dookoła świata

感觉有点眼熟。看起来某次学校的模拟赛出现过。

爆力就是枚举一个起点然后贪心，如果$O(n)$地预处理，可以$O(c)$地处理一个有$c$次加油的方案。注意到如果我们从$p_1$出发依次经过的序列是$p$，那么从任何$p_k$出发还是经过$p$。考虑随便找一个位置出发求一个$p$，那么对于任意一个$k$，任意一个贪心求出的方案必然经过$[p_k,p_{k+1})$中的某个位置。于是在最短的$[p_k,p_{k+1})$中枚举一个起点即可。

为了证明这东西的复杂度，我们证明如果$l$的总和是$s$，则每个方案的加油次数都在$[\frac{s}{d},2\frac{s}{d}]$中。下界是显然的。对于上界，考虑对于每次加油，设上次加油到这次加油的幻想距离为 加油前已经跑过的距离 加上 它面前的这一段，由于贪心，幻想距离是$\geq d$的。考虑所有的幻想距离的和，由于每一段最多算两次，这个和不超过$2s$，而每一次加油至少跑了$d$的幻想距离，所以最多加$2\frac{s}{d}$次油。$\Theta(\frac{s}{d})$段点数的平均值是$\Theta(\frac{nd}{s})$，那么必然有一段是$O(\frac{nd}{s})$的，贪心一次复杂度是$\Theta(\frac{s}{d})$，因此在这一段中枚举起点就得到复杂度$O(n)$。

也可以不枚举起点。注意到各个起点的方案不会相互穿过，所以我们这么扩展，把重合了的只保留一个，复杂度是一样的。

Mrowisko

以食蚁兽为根把树提起来，问题就是求一个到根的乘积喽。基排双指针就结束了。

Turystyka

也就是直径$\leq 10$的图求最小权支配集。

直径很小的图看起来就很有趣。考虑随便跑一棵dfs树，那么树的直径不超过$10$。由于这是dfs树，非树边只可能是返祖边，也就是说子树间互不影响，这就很好。

dp。设$dp(u,S)$表示$u$子树，到根的链的状态是$S$，子树内的答案。复杂度$O(2^{10}n)$。

Lampy słoneczne

范围是相同的，角度不超过$180$，想象一下也就是说能照到是传递的。显然这东西形成了一棵树。

主要问题是如何把树建出来，建完之后dfs一遍就好了。看起来还是自底向上比较阳间。沿角平分线方向扫我们得到一个拓扑序。角是两个半平面的交，判定是否在照射范围内只需要知道沿这两个半平面垂线方向的位置，离散化先，剩下的问题就是给一个点集，支持激活一个点，删除一个2-side矩形中所有激活的点。树套树即可。

看一眼题解没想到就是这个复杂度。树套树太拉了，考虑如何卡常。注意到很可以离线。首先这里外层树可以BiT。内层树问题是序列，支持在某个位置插入一个点，或者清空整个后缀，还是可以BiT。所以就$O(n\log n)$空间了。

Panele słoneczne

感觉比较厉害。

考虑$d$是$[a,b]$中某个数的因数，当且仅当$\lfloor\frac{a}{d}\rfloor>\lfloor\frac{b-1}{d}\rfloor$。$\lfloor\frac{a}{d}\rfloor$分成$O(\sqrt{v})$段，那么$\lfloor\frac{a}{d}\rfloor>\lfloor\frac{b-1}{d}\rfloor$也分成$O(\sqrt{v})$段，那么$[\lfloor\frac{a}{d}\rfloor>\lfloor\frac{b-1}{d}\rfloor][\lfloor\frac{c}{d}\rfloor>\lfloor\frac{d-1}{d}\rfloor]$也分成$O(\sqrt{v})$段，整除分块即可。

妈的，怎么还有多测。现在我们还有八倍常数，砍砍你的。考虑我们只需要找到最右的那一段，所以倒着扫感觉就会得到一个$\frac{1}{2}$的常数。

Załadunek

感觉很厉害。考虑我们必然是上连续发若干班，然后下把它们发回来，这样的，中间可能会有什么都不做的时间。dp，设$dp(i)$表示前$i$班完全结束的最小时间，转移枚举刚才这一串，如果是$(j,i]$

 - 如果在$k$时刻发$i$，那么就在$k-(i-j-1)$时刻发$j+1$，于是我们要求$k-l\geq t_{i-l}$，且上一轮在$k-(i-j-1)$时刻前结束，于是$k=\max(\max\limits_l(t_{i-l}+l),dp(j)+i-j-1)$。

 - $i$发出后需要经过$s$时间到，然后才能发返回的车，也就是共经过$2s+i-j-1$时间。

于是$dp(i)=\min\limits_j \max(\max\limits_l t_{i-l}+l,dp(j)+i-j-1)+2s+i-j-1$。注意到两列车同时来，其中一列必不可能立刻发，让它延后$1$不影响答案，所以可以让每个$t_i$跟$t_{i-1}+1$取$\max$，此时$\max\limits_l t_{i-l}+l=t_i$。

对$\max$讨论，显然$dp(j)-j$单增(从$dp(j)$的方案少发最后一班可以得到$dp(j-1)$的方案)，双指针维护$\max$切换的位置，单调队列即可。

#### XXII(2014~2015)

Stage 1

Czarnoksiężnicy okrągłego stołu

假设$p=3$。可以感觉到合法序列整体上还是双调的。从$n$往两边dp。注意到两边具体到哪是不重要的，只有填了多少是重要的，设$dp(i,S,T)$表示填了前$i$个数，左右状态分别是$S,T$的方案数，考虑$S$是啥样的，$T$是对称的。$S$需要从第一个空位右边一位开始，往左记录所有信息。预处理所有可能出现的状态及转移即可。

当两边接起来的时候需要爆搜。

然后感觉我比较的拉。考虑插入而不是摆放，我们现在要放$i+1$，记录$i$和$i-1$，$i-1$和$i-2$，$i$和$i-2$是否相邻，如果相邻的话顺序是什么。见于 https://www.cnblogs.com/chenxiaoran666/p/Luogu3581.html 。

Kwadraty

容易感觉到这个$k$大概是三次根号级别的。

首先只有有限个数不能被凑出来。

```
2 3 6 7 8 11 12 15 18 19 22 23 24 27 28 31 32 33 43 44 47 48 60 67 72 76 92 96 108 112 128
```

我们要求的是一个从无穷远处来的非严格后缀$\min$个数。看起来它还是挺大的。

在1e6处$k=144$。1e6以内$k$分成$5360$段，这看起来不是很能用。

既然这个东西可以快速求，我们首先猜测怎么求。简单想法是这个方案就是贪心选最大的。但是这个不对。

注意到$a^2=(a+1)^2-2a-1$。既然$>128$的数都能凑出来，我们可以要求前面选的若干个都是连续的，把这个$-2a-1$扔给后面解决。猜测减到$128$以内的前一步这个数不大，至少我们可以知道$\frac{2}{3}$次的界。考虑如果这个数很大，我们把$k$减小$1$，会腾出$\Theta(k^2)$来，啊啊，还是不是很好啊。

不过没有关系，我们猜测找到最小的$t$使得$S_{n^3}(t)\geq n$，那么$k(n)$要么是$t$要么是$t+1$。这个也只对有限个数是错的。

```
n k t
64 8 6
68 8 6
73 8 6
80 8 6
97 9 7
107 9 7
132 9 7
137 9 7
157 10 8
173 10 8
177 10 8
189 10 8
193 10 8
257 11 9
273 11 9
277 11 9
378 12 10
```

考虑每个$t+1$后面有至少一个$t$，也就是$k(S_{n^3}(t))=t$，那么剩下的问题就是求有多少个$t+1$。

如果我们想凑出$n$，可以先选一个$S_{n^3}(t)$，然后凑$S_{n^3}(t)-n$并把这部分减掉。可以注意到$S_{n^3}(t)-n=O(n^\frac{2}{3})$，于是这个事情只有在$S_{n^3}(t(n))-n$是一个不能被凑出来的数时才可能不能做到。打表发现当$n$足够大时这是充要的，于是结束了，复杂度$O(\log n)$。

Pieczęć

模拟。容易想到纸上最左的，如果有多个则取最上的格子必然是由最左的，如果有多个则取最上的格子印出来的，如此sort之后扫过去模拟一下即可。

Kinoman

画到平面上，出现$c$次的颜色贡献$O(c)$个矩形，2-side矩形加，最后求全局$\max$，扫描线线段树即可。

Łasuchy

如果这是链。如果现在决策$i$，我们需要知道$i-1$会不会反悔，于是记$i-1,i-2$的选择即可。

现在这是环。枚举$1,2$的选择。

那么接下来让我们看看牛逼做法。考虑如果存在相邻两个食物满足一个比另一个的一半还要小，那么它俩夹的这个人肯定选另一个了。此时这个 另一个 的值就减半，我们dfs地找到所有这样的选择。如果这样的选择一个都没有，我们转一圈显然是对的。如果有至少一个，此时剩下了一条链，找到一个最小值，它左边往左右边往右即可。

Stage 2

Logistyka

感觉很眼熟。如果模拟的话，我们每次都会选最大的$c$个。但是这个模拟看起来性质不是很好。

题解比较厉害。考虑这个$s$是有其意义的，我们把操作的轮数看作横轴，把操作的元素看作纵轴，那么问题是每一列不能有重复的，于是考虑扫行，如果一个元素超过$s$个，超过的部分肯定没救，否则让它填到未完成的行里，如果填满了就另起一行，这样每一列显然没有重复的。也就是说把每个数跟$s$取$\min$之后总和$\geq cs$那就可以。BiT维护即可。

Podział naszyjnika

还是画到平面上。可行区域是一些矩形并的交，我们希望求一个离$y-x=\frac{n}{2}$最近的点。每个矩形并看起来是一个左上2-side矩形和一些右下2-side矩形，这两部分是没有交的。于是对两部分分开处理，左上直接求对$x,y$限制的交，右下从左往右扫$x=y$，求出每个点上对$x,y$分别的限制的交，只看$x$就是区间对左端点取$\max$，最后求整个序列，画一画发现单调栈即可。复杂度$O(n)$。

让我们看看题解。看起来有个牛逼做法，给每个数随机权值使得每个颜色的xor和是$0$，那么区间合法当且仅当xor和是$0$。hash table，每个桶开个双指针即可。

Pustynia

我年轻的时候居然还做过这个。显然toposort，需要用个啥优化建图，看起来就是从这些数连到一个虚点，从虚点连到区间中剩下的数，线段树即可。

Kurs szybkiego czytania

感觉这个比较有趣啊。还是按照惯例称为$s,t$。考虑从$s$入手，$t_j=1$当且仅当$aj+b\bmod{n}<p$，可以看成是限制了$j$在环上的一部分，那么设出起始位置的值$x$，$s$的限制就是若干个环上的一部分的交。因为$a\perp n$，每个数出现恰好一次，所以最后交出来的区间长度就是答案。呃呃，因为实际上它还是序列，需要减去匹配位置$>n-m$的部分。

Trzy Wieże

这个大概比较有趣啊。只有一种字符的情况直接处理掉。只有两种字符的情况，发现认为第三种字符出现$0$次是没有问题的。于是问题变成求$i,j$使得前缀和数组的差中没有两个数相同且$i-j$最大。

尝试爆力地思考。如果$[l,n],[l,n-1],...,[l,k]$都不满足要求，并且$k$足够小($k<n-O(1)$即可)，那么这之间三种颜色的出现次数的极差不超过$1$，且必然在$O(1)$步内达到一个三种颜色出现次数相等的状态，接下来每三步都是三种颜色各一个。如果某三步不是这样了，那么立刻就会出现一个答案。于是处理每个位置往后不停选三种颜色各一个的三步到何处停止即可，复杂度$O(n)$。

然后根据这个可以证明答案要么左端点在$[1,3]$要么右端点在$[n-2,n]$。

Stage 3

Odwiedziny

看起来是容易归约到任意查询的。于是根号分治，如果$c\leq K=\Theta(\sqrt{n})$我们预处理每个$c$下到根的前缀和，求出$\mathrm{lca}$之后跳一次la来减去多余的贡献，否则爆力长剖la。复杂度$O((n+q)\sqrt{n})$。

Myjnie

最便宜的一个比较呃呃。考虑如何避免记录单调栈。

考虑扫值域，我们找到全局$\min$，然后把包含它的确定下来，那么画到平面上发现可以区间dp了。设$dp(i,j,k)$表示区间$[i,j]$，最小值$\geq k$的答案，那么我们枚举这个$\min$的位置和值，处理跨过$\min$的区间，然后递归下去，复杂度$O(n^3m^2)$。注意到可以前缀和优化，或者可以直接不记$k$，因为如果枚举的$\min<k$我们只会把这个方案的答案算小，复杂度变为$O(n^3m)$。

Tablice kierunkowe

如果行列的多重集分别形成相同的多重集则可行，那么hash然后排序即可。

如果元素可以相同，感觉是npc的。

Wilcze doły

显然我们会修改长度恰好为$d$的区间。枚举这个区间然后向两边延伸，但是因为不凸看起来不是很好办。考虑枚举答案，固定一个端点的话另一个端点显然是单调的，因此可以双指针，那么问题变成维护区间长$d$的最大子段和，单调队列即可。复杂度$O(n)$。

Kolekcjoner Bajtemonów

题意大概是，有一个序列，除了某个颜色出现次数较少，其它所有颜色出现次数相同，求出这个较少的颜色，只能读一次，卡空间。

这个题看起来还是比较有趣啊。求出这个相同的出现次数$c$，这可以通过维护两个特例的出现次数做到。同时维护二进制每一位的出现次数，那么膜$c$之后就得到答案。

Modernizacja autostrady

对于最长。枚举这条边，然后把两边的直径串起来，也就是最大化两边的直径和。为了求子树外，四毛子lca。

对于最短。显然切了一条边之后我们必然连两边的center，如果两边的直径分别是$l_1,l_2$，那么连起来之后是$\max(l_1,l_2,\lceil\frac{l_1}{2}\rceil+\lceil\frac{l_2}{2}\rceil+1)$。我们肯定要切断直径上的一条边，如果直径超过一条，如果center是一条边我们必然切center，否则切啥都没用。如果直径唯一，那么我们随便切一条边之后，两个直径端点必然分别是两边的直径端点之一，可以用那个dfs求直径的结论来证明。那么问题就是以直径为根拎起来，求每个点子树中的最长链，然后胡乱统计答案即可，这里不需要lca。总复杂度$O(n)$。

对于最长也可以不需要四毛子lca。如果没有断直径上的边，以直径为根求子树直径，然后加起来即可。如果断了直径上的边，跟最短一样做。

Wycieczki

又来k短路了。啊啊，怎么$k$有1e18啊?

于是矩阵快速幂。倍增，如果总路径数超过了$k$就停下。直接在乘法里面判断是不是超过了$k$。复杂度$O((nv)^3\log k)$。

#### XXIII(2015~2016)

Stage I

Hydrorozgrywka

怎么poi也有仙人掌题。在圆方树上换根dp，进入环时可以选择顺时针走或者逆时针走，环对外面的影响只需要一个bool。

Park wodny

统计每个B的连通块，枚举一个连它周围最大的两个即可。

Nim z utrudnieniem

我们需要把xor和搞成$0$，于是设原来的xor和是$k$，这就是$[z^kt^0]\prod(1+z^{a_i}t)\bmod{t^d-1}$，其中$t$上是普通卷积而$z$上是xor卷积。那么问题就是法哇塔怎么卷上一个$(1+cz^S)$这样的东西了!

题解比较牛逼。考虑爆力dp，设$dp(i,j,k)$表示前$i$个，xor和为$j$，选的个数膜$d$是$k$的方案数，从小到大排序，注意到$\operatorname{highbit}(j)\leq \operatorname{highbit}(a_i)$，于是总状态数就是$d\sum a_i$的。

Nadajniki

大力dp。设$dp(u,i,j,k)$表示$u$子树，$u$放了$i$个，$u$到儿子们的边中差的最多的还差$j$个(也就是$u$的父亲至少放这么多)，$u$的儿子们放了$k$个(这限制$u$的父边是否满足条件)的答案，显然每一维都不超过$2$。转移的时候枚举$u$放了几个，$u$的父亲放了几个，儿子们放了几个，此时儿子们就独立了，然后在儿子之间背包即可。

Korale

如果只求权值和，经典做法是从空开始扩展，把珠子从小到大排序，每次可以选择当前方案中最后一个的下一个，或者把最后一个换成它的下一个，复杂度$O(n\log n)$。每个方案只有一种扩展出来的方法，所以不需要记忆化。

另一个想法是，二分答案，然后直接这么扩展$k$个。复杂度是$O(k\log v)$。

要求字典序最小的方案的话，我们就需要比较字典序了。可以感觉到每个方案中元素个数都很少......吗?注意到一个方案的子集都比它小，所以任何方案不超过$\log k$个元素，复杂度$O(k\log^2 k)$。

感觉这里需要更厉害的东西。我们写这么一个堆，每次要比较两个权值和相同的方案时，就把它俩合并，然后递归下去合并子树，这样我们弹的时候必然是把权值和相同的方案一口气弹完了。达到答案的时候我们要给一些方案排序，使用基数排序做到$O(k\log k)$。

但是这个是错的!因为这个扩展并不一定能搜到答案。考虑我们拿着权值和去搜这个答案，贪心选择字典序最小的方案使得权值和仍然$\leq$答案即可。为了做到这个需要知道一个后缀中$\leq$某个数的数中最靠前的，在线段树上二分即可。

Stage II

Świąteczny łańcuch

经典题。我们是要一个连通块个数。把所有区间对的长度拆成$2^k$，这里它是幂等的所以像st表一样拆即可。然后对于长度相同的区间，如果$[l_1,r_1]\leftrightarrow [l_2,r_2]\leftrightarrow [l_3,r_3]$，那么现在再来$[l_1,r_1]\leftrightarrow[l_3,r_3]$就没有意义了，所以只需要保留左端点间的一棵生成树，这样就只剩$O(n)$条边。把它们再拆成两半递归到下一层。复杂度$O(n\log n)$。

Drogi zmiennokierunkowe

看起来很带劲。首先缩scc，那么同一个scc要么都行要么都不行。问题变成在dag上找一个点使得它可以到达的和可以到达它的点的并是所有点。求能到的点数，practical的做法是$O(\frac{nm}{w})$，看起来并不行。

可以注意到一个点满足条件当且仅当它在拓扑序中的位置确定，因为如果$u,v$互不可达，我们删掉所有可以到达$u,v$中至少一个的点之后就可以删$u,v$中任何一个。于是考虑能不能求出最大位置和最小位置啊?但是这个还是等价于统计每个点可达的点数。我们需要一个让问题再弱一点的性质。

考虑我们把所有在拓扑序上跨过了$u$的边都删掉，那么$u$前面的点到后面就必须经过$u$了，并且删掉这些边对$u$能到的点集和能到$u$的点集并没有影响。考虑前面，此时如果$u$前面一个点没有出度，那就显然没救。否则由于每个点都有出度，而$u$前面的点一直走下去必然经过$u$，所以$u$前面的点都能到$u$。后面同理。复杂度是线性的。

感觉这个题还是比较有趣。

Zająknięcia

首先注意到不弱于lcs。

dp，设$dp(i,j)$表示两边分别匹配到$i,j$这样的，那么如果$a_i=b_j$，我们可以从$a_i,b_j$分别的上一次出现$-1$转移来，这俩分别记为$t_a(i),t_b(i)$吧。但是卡空间。

感觉这个题会比较厉害啊。注意到比如我们先扫第一维，如果我们现在扫到$i$，那么我们只会从$(t_a(i),j^\prime)$转移来，其中$b_{j^\prime}=a_i$。于是每个颜色只有出现次数个状态是有用的，空间就是线性的了。但是这玩意不用卡常?但是这玩意不用卡常?但是这玩意不用卡常?但是这玩意不用卡常?但是这玩意不用卡常?

一看时限10s。行。

Arkanoid

看起来有点惊悚了。考虑我们如何计算 何时撞上某一块砖 这样的东西。对每条边分开算。那么比如现在有一条**右**边，我们还是用那个翻折的trick，画一画可以发现如果这条边的中心是$(x,y)$，射线撞到任何一个$(x+am,y+bn)$就撞到了它(两维上都翻折偶数次。可以发现如果是翻折奇数次的话会先经过上边/下边)，其中$a,b$是整数。设射线实际上会撞到所有的$k(x_d,y_d)$，于是我们可以解出$a=\frac{kx_d-x}{m},b=\frac{ky_d-y}{n}$，那么我们要求$k+x^\prime\bmod{m}=0,k+y\bmod{n}=0$的最小的$k$。

于是我们对$x_d,y_d$的四种情况分别给所有数解出来一个$k$然后排序(两个是另两个取负)，那么每次沿着某个方向找一个后继然后删掉它即可。二分出这个位置然后用并查集找。复杂度$O(n\log v)$。

Wcale nie Nim

看起来非常恐怖。显然A的每一步都会清空一堆。看看样例，我们知道如果$n=1$答案是$2\lceil 1+\lg a_1\rceil+1$。

注意到一对结束之后，B不得不把一步给别的某对堆$x,x$。那么他显然会把这对堆变成$x+1,x-1$。如果$x$是$2$的幂$+1$那就少了一步，此时A必然会跟上来取走$x+1$。如果A去了别的堆，那么那边清空之后B就可以把这边变回$x,x$。

我们将A把一对中大的拿走这个操作称为拿，B把一对中有一个$0$的摊平称为摊，B把平的一对搞的不同称为炸。如果只有拿和摊，答案就是$\lg$的和之类的。那么只有炸可能省出步数，并且最多省下一步。观察二进制，如果一对是$a,a+1$则不会被炸，如果是$a,a$且$a$的二进制表示全$1$，那么一轮炸-拿-摊可以把$a$的长度减少$1$，如此一直进行$a$的长度次才能减少一步，一旦中断就不可能减少一步了。于是A可以上来先全搞成全$1$的形状，然后两个人每次都会选择最长的那个操作，B是因为最长的最不容易有用，A是因为要逼B往短的上走。A一旦先手操作一堆就会操作干净，因为它上面不可能再省下步数了，而B会让这一堆长度减少$1$。最后每一堆长$1$的都能贡献，如果A先手则有一堆不行。胡乱模拟即可。

Stage III

Równoważne programy

感觉比较厉害啊。注意到操作可逆，所以我们可以进行一个排序，把它们都换的字典序尽可能小。那么从左往右枚举一个位置，我们希望换过来一个尽可能小的，枚举它的颜色，找到右边第一个这样的，然后判断能不能换过来，这当且仅当它能和这一段中每个数换。考虑直接维护每个颜色能不能换过来，问题是单点清空，求前缀bitset的or的某一位，线段树就是$O(\frac{nk\log n}{w})$。

但是std不是这个复杂度啊。std做法大概是枚举一个颜色，如果相邻两次出现是$i,j$，那么记录$[i,j]$中不能和这个颜色换的数的个数，然后对上去判断是否相同。证明考虑找一个好一点的翻译器。我好像考虑到了类似的hash做法。

Posłaniec

还是比较简单的吧!先$n^4$跑个路径数，然后我们要减去多次经过起点/终点的，那就枚举经过起点/终点的环来容斥，大概是$\sum\limits_i\sum\limits_j c(u,u,i)c(v,v,j)c(u,v,d-i-j)$这样的。枚举两个点预处理$c(u,u,...),c(v,v,...)$的卷积即可，复杂度$O(n^3d+n^2d^2+qd)$。

Pracowity Jaś

1e9+7秒大约是31.7年。

这就需要我们看看prev\_permutation到底干了啥事了。看起来我们应该找到最短的后缀满足它不是递增的，这个位置就是第一个下降的位置。设它是$k,a$，其中$k$是数，$a$是递增序列，$k>a_1$，那么我们要做的就是把$a$中$k$的前驱换到$k$这里，剩下的数从大到小排序。于是只有$a$的长度和$k$在$a$中的排名是重要的。可以算出来如果$a$中比$k$小的有$l$个，大的有$r$个，那么答案是$l+1+\frac{(2l+r+1)r}{2}+\frac{l(l-1)}{2}=\frac{(l+r)^2+l+r+1}{2}$。

于是说只有$a$的长度是重要的，这个排名也是不重要的了。那么就是要求所有字典序比某个排列小的排列，极长递增后缀长度的和和平方和。还是枚举前面长度相同的段，剩下的部分就是一个没有字典序限制的问题。设$f(n)$表示长$n$的排列的答案，考虑枚举这个后缀的长度$k$，那么首先有$\binom{n}{k}$种方案选出这个后缀，前面随便排就是$(n-k)!$，但是这个会把一个实际上极长后缀长$d$的排列在$k=1,...,d$处都算一次，所以还要差分一下。式子看起来像是$f(n)=\sum\limits_{k=1}^n\binom{n}{k}(n-k)!k^e=n!\sum\limits_{k=1}^n\frac{k^e}{k!}$，后面跟$n$无关了，前缀和即可。

Żywopłot

对偶图mst。

Klubowicze

看起来很牛逼，当场无人通过。收录于 格雷码相关问题。

Niebanalne podróże

这个题看起来大概区分出了波兰国家队。

也就是求是不是所有简单环的长度都相等。这里我们既不能求出最大环，又不能求出最小环。

那么我们先跑一个dfs树，dfs树上有很多环，并且这是无向图所以dfs树居然只有返祖边。

如果所有的非树边覆盖的链都不交，那就比较简单了。

如果有的非树边覆盖的链交了，考虑设所有非树边覆盖的链的长度都是$l$，那么一个环合法当且仅当长度是$l+1$。设两条非树边端点分别从上到下是$(u_1,v_1),(u_2,v_2)$，那么设$d_u=\mathrm{dis}(u_1,u_2)$，$d_v$同理，交的部分就应该是$\mathrm{lca}(v_1,v_2)$上面的一段，我们可以得到一个长$d_u+d_v+2$的环，于是应该有$d_u+d_v=l-1$。在$\mathrm{lca}(v_1,v_2)$处统计，以它为根我们知道$d_u=\vert\mathrm{dep}(v_1)-\mathrm{dep}(v_2)\vert,d_v=\mathrm{dep}(v_1)+\mathrm{dep}(v_2)$，也就是说$d_u+d_v=2\max(\mathrm{dep}(v_1),\mathrm{dep}(v_2))$，于是实际上只要求，要么只有不超过一个子树中有$v$，要么(不存在$2\mathrm{dep}(v)>l-1$的$v$，且有$\mathrm{dep}(v)<l-1$的$v$的子树不超过一个)。当然这里$\mathrm{dep}\geq l$的点要删掉。

考虑经过至少三条非树边的情况。如果它要有贡献，考虑我们走的前两条非树边，它们一定满足到它们$v$的lca的距离一个$=\frac{l-1}{2}$另一个$<\frac{l-1}{2}$，这俩分别称为低的和高的吧，不能两个都$=$是因为这样就直接接起来了不能再走。那么接下来我们要转到第三条非树边上，这条边如果更低那么它和这俩中任何一个都能凑出不合法来，于是它必须更高，于是它的$v$不能比前两条边的lca低，如果低了那和高的就凑起来了。它又不能比两条边的$u$都高，否则走不过去。如果它的$v$比低$u$低那么它就和低边凑成了不合法，如果介于两$u$之间，那么考虑它的$v$和高$v$的lca，高边在这里的深度必然是$>\frac{l-1}{2}$的，于是又凑成了不合法。所以如果有环经过至少三条非树边，必然不合法。

到这里我们知道对于第一问直接长剖一下存哪些深度有$v$，并维护一个指向$<l$的$\max$的指针即可，移动它的总复杂度是线性。考虑怎么数数，合并的时候距离$=\frac{l-1}{2}$的选两个，如果有$<\frac{l-1}{2}$的再拿它配$=\frac{l-1}{2}$的，这就是所有方案了。复杂度线性。

Parada

也就是在树上求最大毛毛虫，中心链上的边没有贡献。dp，在lca处统计即可。

#### XXIV(2016~2017)

Stage 1

Flappy Bird

猜测保持尽可能低就可以得到答案，因为如果一个位置不是尽可能低，我们让它降低要么是把升高延后了，要么是真的减少了一次升高。

黑白染色，那么每个柱子的下侧限制就是$y-x>a_i-x_i(x\leq x_i)$，而由于我们贴下侧走，一旦撞了上侧就没救。扫出一个单调栈，然后在上面和上侧的限制上双指针即可。

题解做法简单一些。考虑答案由我们最后到的点中最低的那个的坐标确定，直接扫过去，维护我们可以到的点的最小和最大纵坐标，然后就结束了。

Podzielność

考虑$b-1$的倍数有啥性质。经典的，$b^k-1=(b-1)(b^{k-1}+...+1)$，也就是说$b^k\bmod{b-1}=1$，也就是说$b-1$的倍数就是各位之和为$b-1$的倍数的数。

首先考虑我们怎么选最多个。想了想发现了$a_i\geq 1$这个牛逼条件，于是我们直接扔掉一个和总和膜$b-1$相等的，如果这个是$0$则可以不扔。查询的时候在前缀和上二分一下即可。

Reprezentacje różnicowe

看起来牛逼题。然后仔细一看发现这个序列好像是为了这个性质构造的，那个$r$就比较直白了，那么考虑$a$很大的时候$\times 2$就没啥贡献了，只有$+r$有贡献，而这个每次会让$r$增加$1$，也就是说我们统计一个足够长的值域范围内覆盖了$x$以内的多少数，设有$c$个，如果覆盖了$x$就结束了，否则答案就是再往后$x-c$对。复杂度$O(n\log\log v+\log^3 v)$。

Sabotaż

第一个叛徒肯定是叶子，因为这里算的时候不包括他自己，而叶子的子树不会更大。然后他肯定是一级一级地往上推。对每个叶子求出向上占领各级所需的比例的$\max$，取个$\min$即可。

Turysta

求一下所有的scc，每个scc跑一个哈密顿回路，然后跟下一个scc串起来即可。

Stage 2

Zawody sportowe

如果一个连通块边数超过点数，那就没救。否则是基环树森林，环上如果环长$\geq 2$有两种选择，树上只有一种，toposort即可。

Strajki

贺个动态图连通性先。但是这里是删点，这就很不好。考虑维护存在的边数，根号分治，对于每个点我们维护周围度数比它小的点有多少个还存在，这样如果一个点的度数是$k$，全图度数比它大的点个数就不超过$\frac{n}{k}$，那么改它的复杂度就是$O(\min(k,\frac{n}{k}))$，总复杂度$O(n\sqrt{n})$。

考虑能不能更快一点，毕竟这里是树。好像儿子在bfs序上是一个区间，所以BiT就好了。比较智障!

Suma cyfr

dp。设$dp(i,j,k)$表示$i$位，膜$m$为$j$，和为$k$的数的个数，然后从高到低确定每一位即可。

Kontenery

根号分治。

Zamek

先把不能走的找出来。也就是一个单点修改矩形求和。

然后建出图来。枚举一个横坐标，按纵坐标排序，这里矩形不交就很好，爆力双指针即可。

然后bfs。

Stage 3

Dostawca pizzy

猜个凸先。

考虑个dp先，设$dp(u,i,j)$表示$u$子树走$i+j$次，其中$i$次回到根，$j$次没有的答案，转移就爆力卷，复杂度$n^3,n^4$区别可能不大。

但是这东西好像不好直接优化!需要一个牛逼结论。考虑我们钦点所有终点，那么如果一条边子树中有$k$个终点，它经过至少$k$次，如果$k=0$则是两次。猜测总有一种方法达到这个下界。问题仅在于子树中有终点的边是否必然可以不被一条终点在子树外的路径经过。注意到进来又出去就形成环，而已经有一条路径进来了，那么把这个环接到那上面即可，也就是说这个下界确实是恰到好处的。

那么我们就只需要钦点终点了。设$dp(u,i)$表示$u$子树有$i$个终点，计算父边边权$w$的贡献的答案，那么$dp(u,0)=2s(u),dp(u,i)=iw+\min\limits_{\sum j=i}\sum dp(v,j)$，$s$是子树和父边的边权和。复杂度$O(nk)$。这大致等价于在上面那个爆力中断言如果$j>0$则$i=0$，否则$i=1$。

那么接下来归纳一下证明凸性。考虑叶子看起来是凸的，$dp(u,...)$是儿子们的$\min,+$卷积塞上一个$dp(u,0)=2s(u)$，可以注意到的是$dp(u,0)>\sum dp(v,0)$，所以它确实是凸的。然后可以wqs二分或者静态链分治合并凸函数。

Midas

好像它说的是树啊。那么我们求一个lca就好了啊?

如果不是树，递推，主席树多树二分。复杂度$O(m\log n)$。

Oceny

英文题面有误，应为后面的不能比前面的小。

考虑把这俩画到平面上，那么一个点左上和右下方的必须和它相同，而连通块之间必然可以不同，我们就是要求有多少连通块。

这个问题好像比较经典!因为这是排列，考虑问题相当于画尽可能多的十字使得每个十字只有左下和右上有点，这又相当于查询有多少个间隔满足左边的$\max$比右边的$\min$小，那么也就是查询有多少个前缀$i$满足$\max=i$。如果$i$出现在$j$，那么相当于$[j,i-1]$都不可能成为答案，如果一个位置没有被这样覆盖则显然是答案，线段树维护$0$的个数即可。

Zapiekanki

无人通过!恐怖极了兄弟。

把题面中的$k$称为$n$。

这是一个有容量限制的摆渡车。考虑相当于在数轴上放若干个点，相邻两个距离$\geq d$，然后每个人往后匹配一个点，一个点最多匹配$z$个人。经典的，首先每个点要么和一个人重合，要么在上一个点后恰好$d$的位置。dp，设$dp(i,j,k)$表示从第$i$个人开始连续放了$j$个点，还有$k$个人没匹配的答案，复杂度$O(n^3)$。

注意到如果有至少$z$个人，我们必然尽可能早地放一个点，这样就是$O(n^2z)$了。于是希望把$i,j$砍到$O(\frac{n^2}{z})$的级别，但是不太行啊，毕竟摆渡车里面是$z=n$的。

换个想法，首先这里$j>0$时的转移是唯一的，所以我们直接把这一维扔掉，改为转移的时候枚举连续选多少次。至于选多少次呢，当然是选到满。那么假设我们现在要处理$dp(i,...)$的转移，当我们遇到一个$x_i+td$的时候我们选择$x_i+(t-1)d$这个点，这个操作的效果大概就是$>z$的部分加$z(x_i+(t-1)d)$并平移$-z$，$\leq 0$的部分加$j(x_i+(t-1)d)$并拍成$0$，这里后者有均摊。然后还要把下一段的操作重做一遍。可以发现的是主要问题是我们需要做这么多平移，感觉完全没法做啊!

考虑现在是不是容易看出什么牛逼性质了，注意到如果一个状态想要坚持不被拍到$0$，它只能坚持最多$\frac{n}{z}$轮，而刚才还说如果有至少$z$人在等，我们必然继续放一个点，所以$\geq z$的这部分是不用转移的。所以复杂度又$n^2$了。这么说一开始应该也可以看出来的啊，还是眼力不好!

Kucharz

看起来又是有趣卡空间题。但是这个题不够有趣，注意到如果我们用操作$3$，必然是希望早用，于是有能量我们就会用，于是枚举一开始连用多少次，能量就没有意义了，只需要开一个长1e6的$dp$数组。

Rozdroża parzystości

classic。考虑我们就是求一个字典序$k$小的方案，先把所有东西插入线性基，那么一棵生成树将会调整一切。如果我们改变一条非树边的状态，对应树上的链跟着改变即可，也就是说我们首先随便得到一个解，然后在环空间中求一个和它xor的第$k$小。

为了随便得到一个解，每两次对目标的修改，把它们在树上的链取反。

为了在环空间中求和它xor的第$k$小，如果生成树上的边是编号最小的那些我们就赢了，否则我们需要消出一个对角基来，但是这个巨大矩阵上大概不是很好操作。考虑能不能通过选择一棵特殊的生成树解决这个问题，我们选择字典序最小的生成树，那么对于每个基础环，上面最高的位一定是那条非树边贡献的，否则把它替入就得到字典序更小的一颗生成树。于是我们在此上贪心即可。$k$的改变只可能影响最低的$\log v$个基础环，爆力即可。求字典序最小的生成树使用kru。

#### XXV(2017~2018)

Stage 1

Pionek

考虑必然是存在一条过原点的直线，它的一侧我们都选，另一侧我们都不选。扫描线扫一扫即可。

Plan metra

容易想到找到$1$到$n$这条链，一个点$u$到链的距离就是$\frac{1}{2}(d(1,u)+d(n,u)-d(1,n))$，而它应该挂在链上$d(1,u)-d(n,u)$和它相同的那个点上，于是我们找到这条链之后就容易挂成一个毛毛虫了。那么考虑一个$d(1,n)$合法，当且仅当每个点到链的距离都是整数，这可以简单地用奇偶性限制住，并且每个点都和某个在链上的点具有相同的$d(1,u)-d(n,u)$。显然对于每个$d(1,u)-d(n,u)$等价类，其中$d(1,u)$最小的那个点是在链上的，用它们求出一个$d(1,n)$，如果有不同的那就无解了，然后直接如上构造即可。

或者简单一点，$d(1,n)$就是最小的$d(1,u)+d(u,n)$。

但是这里有问题，如果没有一个点在链上，或者说$1,n$是相邻的，我们就死啦，所以需要check一下$d(1,n)=1$的情况。

Powódź

感觉比较有趣啊。显然还是要扫值域，考虑每个高度是若干个连通块，每个连通块周围都是高度不低于它的墙。考虑这个连通块的结构，在序列上它是卡笛尔树，那么在矩阵上，考虑从大到小扫这是一个合并的过程，于是它还是一棵树。那么在这棵树上dp，也就是求一个 每个点到根路径上选恰好一个点，然后每个点有一个权值(在某两面墙的高度之间可以随意选)，所有方案中权值积的和。dp即可。

Prawnicy

模拟。

Różnorodność

考虑枚举一条横线，那么我们在这条横线上还是可以算每个颜色上一次在哪个竖条中出现然后数点。那么横线扫过去的时候会有插入删除，用set维护每个颜色即可，复杂度$O(n^2\log n)$。

Stage 2

Przelewy

剥叶子。

Drogi rowerowe

看起来这个比较有趣啊。缩个scc先，那么我们考虑如果$u$不能到$v$，则$v$有不超过一种方案到$u$是啥意思。我不理解，但是发现不用理解，因为在这种图上直接dp就是对的。

Konduktor

第一问把包含其它区间的区间去掉，然后直接贪心找到左端点最左的还没有包含一个的，在它的右端点放一个。

那么考虑dp，设$dp(i,j)$表示放了$j$个，最后一个在第$i$段的方案数，这里按照哪些区间包含这个点划分成$O(n)$段。注意到如果贪心得到的最优解在前$i$段放了$j$个，某个方案在前$i$段放了$j+2$个，并且在第$i$段放了一个，那就救不了啦。于是每个位置只有两个$j$有用。转移的时候找到完全在$i$左边的区间中左端点最右的，然后从它上面转移过来，前缀和即可。复杂度是线性的。

Przekaźniki telekomunikacyjne

简单ds题。维护区间和和一个等差数列标记。

Tomik poezji

先给所有$a_i$加上$1$。问题就是把它们分成尽可能少的组，使得对于每一组存在一种排列方式使得所有真前缀的和膜$s$都不为$-1$，且除最后一组外每一组总和为$-1$。考虑什么样的组是存在一种排列方式使得所有真前缀的和膜$s$都不为$-1$的。但是感觉不好考虑。

不过还是可以的嘛，考虑如果我们有至少两种长度，那么其中一种必然可以使得和膜$s$不是$-1$。这时候容易猜一个按出现次数贪心的做法，但是这个看起来并不好证呢。

让我们看看我校伟大的cmo Ag爷怎么说。

 - 如果某一时刻出现次数最多的数不止一个了，那么答案必然是$0$，因为如果有至少两个数$a,b$，我们现在不能选$a$，那么选完$b$必然可以立刻选$a$。

 - 否则，最后剩下的数必然是一开始就出现次数最多的数，设它是$a$。

   - 如果$a\not\perp s$，它只会剩下最多一个，否则考虑在这一时刻之前我们选了某个$b$，好像在$a\mid b$的时候会出问题。考虑我们找到最后的极长段，满足如果其中某个位置的和是$t$，有$a\mid s-1-t$，那么在这一段前一位我们选的数必然不是$a$的倍数，因此它当时只剩一个了，那么除非所有数都只剩下了一个，否则我们是不会选它的。于是答案还是$0$。

   - 如果$a\perp s$，我们把所有数除$a$，那么相当于我们在数轴上不停往右走$1$到$\frac{s-1}{a}-1$，然后走某个别的数，这样的。考虑我们走过的总长度，总是要经过那么多次$\frac{s-1}{a}$，用$a$之外的每个数只能跨过不超过一个，因此总是跨过一个必然是最优的。

Stage 3

Dwa pionki

还是枚举最后两个点连线的垂线，那么沿着这条垂线方向尽可能选即可。

Trzy wieże 2

好像其实是Trzy wieże 1的一部分。在做Trzy wieże 1的不久之后我在tricks里面说这类问题是经典的维护特例。

Liczby kompletne

见鬼捏。考虑首先枚举位数，那么我们把位数分解，然后dp，设$dp(i,j)$表示，假设我们当前这个数是$x$，那么$\lfloor\frac{n}{x}\rfloor=i,d(x)=j$的方案数，这里$n$是$x$的范围。但是这个好像不是很有前途，因为转移的时候我们总要枚举素数幂啊。不过我们知道这个可以做$O(n^{\frac{3}{4}+o(1)})$，鉴于基本和组的平方根之和是$\frac{3}{4}$级别。

看起来可能需要点性质。首先我们知道因数个数是$\log_{10}$的数，素因数个数就不超过$\lg\log_{10}$了。大力讨论，先考虑九位数怎么做，$9=3\times 3$，也就是说它有两个素因数，每个都是两次，或者有一个素因数是八次，两种情况都是简单的，精细实现可以做到$O(\sqrt{n})-O(n^\frac{1}{4})$。大概需要注意直接算前一个会算重。

七位数及以下线筛。只要考虑一下八位数就赢啦。

那么八位数可能有三个一次的素因数，一个三次和一个一次，或者一个七次。最后一个是简单的，中间那个可能要素数计数，前面的感觉更不好做啊。

妈的，能不能线筛直冲1e8啊?当然可以，分段打表即可。

Ogrodzenie

dp。枚举开头$s$，设$dp(i,j)$表示前两个选了$i\rightarrow j$的答案，转移可以转移到$dp(j,k)$，其中$k$是一个前缀，预处理出这个前缀然后打个标记即可。问题是怎么做三角形数点，这个是经典的。

Turniej trójinformatyczny

感觉比较有实力。

首先这是一个竞赛图，如果$a$在任意两项上不能胜过$b$，那么说明$b$必然在某两项上胜过$a$。于是问题是找到所有的scc以及求scc之间的拓扑序。

考虑kosaraju，问题是需要找到一个点可达且还没遍历过的任意一个点，树套树，复杂度$O(n\log^2 n)$。

但是这有点极端了。考虑能不能稍微的快一点，发现这里只需要求一个前缀$\min$，复杂度$O(n\log n)$。

让我们复习一下kosaraju。在正图上求离开序，在反图上按离开序的倒序dfs就按正图上的拓扑序找到了所有scc。

Dwa długie lizaki

把每个区间的两维画到平面上，那么每个区间就是一个矩形，要求交中$x+y$最大的点，扫描线线段树即可。

Taksówki

空跌之言可谓切綮。我们只需要满足每相邻两个确定的限制，因为它对这相邻两个是充要的。

Wielomian

法法。

#### XXVI(2018~2019)

消失之年。你在洛谷上找到的poi2018是xxv，2019是xxvii，xxvi可能是poinan吧。

Stage 1

Klubowicze 2

也就是把一个环分成两段满足两边的or相同。$n,m$看反就比较乐。一开始看成了分成两个子集，这东西大概不可做啊。这个就比较简单，我们枚举一个分界点，找到左右最短的使得or等于全局or的地方，然后这俩中间都可以当另一个分段点。双指针，使用两个栈维护or即可。

Robocik

小波特罗比。

每轮就是一个平移，每个膜$n$等价类是一个等差数列，看看它有没有经过目标即可。

Para naszyjników

我们知道所有长$k$区间的奇偶性都相同，当且仅当相距$k$的两个数总是相同。那么问题变成判断平移$k$之后是否和自己相同，hash一下就好了，或者直接kmp求出所有border。

看起来官方题解比较厉害。考虑如果两个串长度相同怎么做，如果它们奇偶性相同就赢了，否则如果四端不都相同那么删一次答案是$n-1$，否则我们找到离任何一端最近的和四端都不相同的，然后把它那一侧扔掉。

如果两个串长度不同，我们枚举长串的一个区间，问题就是求出左/右第一个0/1，很容易线性。

Podciągi

感觉官方题解还是比较厉害。设本质不同子序列数是$f$。考虑我们每次选择一些没出现过的字符，在左边放一个$a$右边放一个$b$，那么本质不同子序列数会乘上$f(a)f(b)$，然后减去$f(a)f(b)-f(ab)$。通过爆搜，找到所有长$\leq 7$的$a,b$就可以覆盖1e18。

Niedbałość

贪贪你的。维护左右目前出现过的字符，如果有重合那就选过去，然后把跨过的一段删掉。

Stage 2

Rozliczenia

BiT。

Gwiazdy

如果可以任选起点，那么所有东西都可以搞出来啦!

猜测就是几乎所有东西都可以搞出来。但是显然不总是这样，比如如果$s=1$，第一步必须往右。注意到首先总可以让只有第一步可能不能搞出来，具体一点就是先扔掉$s$并不考虑第一步，倒着考虑，不妨设最后一步是往右，如果是连续长$k$的往右，那就从$n-k$开始走到$n$，然后如果是长$k^\prime$的往左，就走到$k^\prime$然后一直走到$1$。最后用第一步走到$s$。这样只有第一步可能不能搞出来。

感觉这个构造已经很厉害了!考虑一个更猛的，注意到如果在$i$，我们就没法在开头连续往左$i$步，但是开头的连续往左结束之后就相当于任选起点了，所以其实只对开头连续相同段的长度有限制。这就赢了。

Kolacje

每种和查询一起拿出来建个虚树，然后变成链$\min$了，可以并查集做到$O(n\alpha(n))$。

我好像不是很会写虚树。

Przesunięcie cykliczne

考虑第二个subtask怎么做。分块，我们每次走过比如$K=50$，那么走$t$步时转了一圈回到一开始的地方后面一点的话，也就是说一开始是$a_0$，$a_{t-1}<a_0$，且 $a_t>a_0$或$a_t<a_{t-1}$，那么序列长度就在$((t-1)K,tK)$中，爆力尝试$K$种即可。

或者直接随机走期望$\Theta(\sqrt{2n})$步，然后就会得到两个相同的数，此时走的总长就是一个$n$的倍数，给这个数分解素因数每次尝试删掉一个素因数发生什么，这是$\sqrt{2n}+\log n$。

那么考虑怎么二分之类的啊。

感觉比较厉害。考虑我们先让前$i$次跳$2^i$，$i$从$0$开始，也就是说我们每次跳$1,1,2,4,8,16,...$，直到找到第一次 这个数比上个数小 的时刻$t_1$，这就越过了$n$。然后再跳，找到第一个比起点大或者比上个数小的时刻$t_2$，这就走完了一圈。那么我们知道$n$就在$(2^{t_1-1}+2^{t_2-1},2^{t_1}+2^{t_2})$中。

现在在其中二分一个答案$d$，因为这个区间是$(k,2k)$这样的，我们知道$\frac{n}{2}<d<2n$。但是现在我们不知道我们在什么位置捏。做法比较的强力，我们假设$d$是偶数，如果不是偶数就微调一下。从任意一个点$a$出发跳两次$\frac{d}{2}$，分别到达$b,c$。如果$d=n$，那么$a=c$。使用geogebra观察一下，发现$d<n$的时候三个点的顺序总是$a,b,c$的循环同构，$>n$的时候总是$c,b,a$的循环同构，或者你可以把它看成$d$的一次函数然后想象一下。这就赢了。我不是很理解这东西是不是有什么深刻的结构啊。

Osiedla

经典的，每个e-dcc可以直接任选一棵dfs树，那么每个点子树中都有返祖边，dfs树向下而返祖边向上即可。e-dcc之间没救。

Stage 3

Metro

classic。二分答案，然后贪心。

看起来有牛逼做法。直接以center为根，长剖选前k长链。

Remont

为啥这么多一眼看上去没有多项式复杂度爆力的题。问题相当于每个间隔选或者不选，相邻两个间隔不能都不选，相同颜色的间隔不能都选。

可以说是一眼网络流!但是很遗憾我并不会。考虑拟阵交，也不行。本质上来说，颜色限制是独立，序列限制是覆盖。

考虑线性规划。但是我好像证明了它不是全幺模的。

考虑2-sat。这会可以了，但是一个颜色出现很多次的话，需要连很多边。不过前后缀和优化建图一下就好了。我想了一年才想到，感觉比较智障!

Wyścigi

考虑如果只有一次查询，显然我们会倒着分配这个得分，也就是排名$i$的获得$i$分，这里排名定义为更大的数的个数。那么就是要这样求全局最大值个数。

发现排名压根不会变，所以线段树维护即可。deepl给我把操作2翻译成$\geq x$的$-y$了。

Zjazd obieżyświatów

感觉比较厉害。

先给答案一个上界。考虑枚举终点，因为只要上界，我们可以要求终点在一个环上，毕竟每个点都可以在$O(n)$步内走到一个环上。因为大家都会到终点，我们随便找一个终点所在的环，膜它的长度从终点出发跑同余最短路。这证明了答案不超过$n^2$。

于是考虑如果有点不在环上，枚举答案，我们要$01$矩乘$n^2$轮，每次乘法是$\frac{n^2}{w}$，要乘$n$次，然后全部and起来。复杂度$O(\frac{n^5}{w})$。

发现我比较智障。发现这玩意可以二分，因为所有人在$t$时刻相遇之后，只要一起走，就能在$t+1$时刻继续相遇。所以倍增即可，复杂度$O(\frac{n^3\log n}{w})$。

Długie podróże

切了这题的都没进国家队/cf

考虑既然要经过$\frac{n}{10}$条边，就是$\frac{n}{10}+1$个点，我们随机一个点有$\frac{1}{10}$的概率随到这条路径上，随到了的话从它出发bfs一下就赢了，那么算一下，假设有$50$组数据，那么我们需要在1e7次询问中幸存，比如要$\frac{1}{1000}$的错误率吧，每组的错误率就要在$10^{-10}$。我们每随一个的错误率是$\frac{9}{10}$，那么看起来随$\log_\frac{9}{10}10^{-10}\approx 218$个点就好啦。

Gra w dzielniki

很容易写一个dp，也就是设$dp(i)$表示现在在$i$的期望时间，转移枚举得到了啥，只有它是不是因数有关系，复杂度$O(n\log n)$。

猜测方差很小，因为这东西看着就很像二项分布，所以直接做就好啦。

Ornitolog

例行卡空间题吗。

注意到$a,b$很小，类似于约瑟夫问题的做法，我们每次都能砍掉$\frac{n}{a}$个，也就是把它变成了$\frac{a-1}{a}$，算一下算量大概是2e5啊。

具体一点，我们每次删的是一侧的一个等差数列，求出每次删了多少个，找到答案在答案被删时的位置之后，倒着扫并维护它的位置。如果一个位置在删掉了各$ai+b$之前是$x$，那么它就会变成$x-\lfloor\frac{x-b}{a}\rfloor$，如果$a\mid x-b$它就会被删掉。所以如果它删掉之后是$y$，那么$y=x-\lfloor\frac{x-b}{a}\rfloor=\lfloor\frac{(a-1)x+b}{a}\rfloor$，我们爆力拆解下取整就是$\frac{(a-1)x+b}{a}-1<y\leq\frac{(a-1)x+b}{a}$，解得$\frac{ay-b}{a-1}\leq x<\frac{a(y+1)-b}{a-1}$。两侧分别给出$x=\lceil\frac{ay-b}{a-1}\rceil,\lfloor\frac{a(y+1)-b-1}{a-1}\rfloor=\lfloor\frac{ay-b}{a-1}\rfloor+1$。看起来只有$a-1\mid ay-b$时它俩不相等，此时必然有$b=y$，那么看起来我们应该取后者。

#### XXVII(2019~2020)

可以称为近代题了。

Stage 1

Pomniejszenie

必然是把高若干位改相等，然后如果接下来$a$本身就小就不用管了，否则需要留一手以改小。有趣的是如果正好撞到$0$上就没救了，此时我们往前找到第一个非$0$的，在这里改小，然后后面全改成$9$。

Pisarze

¿

有空练个ai。

Przedszkole

草，这不是挑战色数吗。

看一眼范围，原来是分成三部分。

$n\leq 15$。子集卷积$k$次。$k$可能很大，所以$\ln-\exp$，复杂度$O(2^nn^2)$。或者$O(2^nn^3)$，设$dp(i,S)$表示恰好用了$i$种颜色，填满了$S$的方案数，子集卷积，最后选出这些颜色即可。考虑有没有好写的$O(3^n)$之类的，好像只能$O(3^nn)$啊。

$m\leq 24$。如果一个点是一度点，它的贡献就是不能选和它的邻接点相同的颜色，也就是给答案乘上$k-1$。如果一个点是二度点，我们把它缩进边里。用和上面一样的dp决策所有度数$\geq 3$的点的颜色，然后每条缩了一些点的边只有端点颜色相同或者不同有贡献，复杂度$O(3^\frac{2m}{3}m)$。

看起来也可以对边容斥。

2-正则图。若干个环。考虑从随便一个点断开然后dp，每个颜色只有和起点相同还是不同有关。或者容斥也是可以的。

Układ scalony

考虑我们可以构造任意长的直径，但是不能构造任意短。最短的就是$n+m-2+[2\mid n,2\mid m]$。

为了构造中间的，考虑转转然后冲进一条对角线。沿着某一个方向走几个之字形，然后现在我们到了某个角，再拐一次就超了，那么从对角那里伸出一条来，中间构造一个最短的即可。

感觉我的强行构造水平还是不行。

Najmniejsza wspólna wielokrotność

首先注意到相邻的两个数总是互素的，也就是说它们的lcm必然是它们的乘积。相邻三个数$a,b,c$，只可能$a,c$都被$2$整除，并且它们除掉一个$2$之后必然互素，也就是说lcm至少是$\frac{abc}{2}$。我们在大约1e6以内枚举所有lcm不超过1e18的区间，并特判两个数的情况即可。

Stage 2

Wakacje Bajtazara

也就是让奇数天的和尽可能大，并且不能两次在奇数天在一个点。那么考虑我们走出来是个什么形态，不妨假设偶数天在白点，我们选择了一串白点和它们的邻域，相邻两个白点的邻域有交。dp，设$dp(u,0/1)$表示$u$子树的一条祖先-后代链，$u$是最高的白点/黑点的答案，这里如果$u$是黑点，$u$要贡献一个负的点权，在儿子中找一个不同颜色的以转移，或者找两个以统计答案。

Drzewo czwórkowe

每个点的边界分成若干段，我们需要大力维护它分成哪些段以及这些段的连通性。超级模拟/cf

有趣的是这里不需要合并，因为两个点的边界相交的话，一个点在这一边必然不能再相交了。直接这么加边即可。

为了统计答案，从高到低模拟。每次相等都会让至少一个点消失掉，所以是线性的。

Wielki Upadek

考虑往右的情况，往左就倒过来做。由于新的骨牌都是矮的，我们必然希望用它们去塞一些间隔。问题就是应该怎么塞。

设第$i$个间隔需要$a_i$个短的，长的是短的的$k$倍。那么如果一个长的能代替$k$个短的，显然是不劣的。考虑让长的优先去代替短的最多的地方，那么我们用什么东西支持插入删除求前$k$大和，平衡树即可。

Marudny Bajtazar

2 classic。

Trudny dylemat przedszkolanina

也就是选两个$\leq n$的数使得因数的并集最大。感觉这个比较厉害。

考虑类似于高合成数的想法，注意到$\gcd$和$\mathrm{lcm}$的各素因数的次数应该都是单减的，对着开搜即可。但是我不会搜啊?

Stage 3

Powtorzenia

也就是对每个出现过的颜色计算最多的连续出现次数$-1$的和。特判两边的段，中间对每个颜色建卡笛尔树然后主席树数点即可。

Szyld

感觉比较带劲。设两个串分别是$a,b$。如果$b$有字符没有在$a$中出现过，那么答案是inf，否则答案必然不是inf。

考虑我们肯定是每一个和上一个的最长真border重叠，因为重叠的少了不会让$b$变得不出现。所以问题就是这么重叠多少次会让$b$出现。在vector上二分找到下一个我们要的字符在哪即可。

Unia Bajtopejska

让人想起那个区间gray code题。

考虑$a=0$咋做。考虑如果还有$b=2^k-1$咋做，考虑分成左右两半，那么两部分之间的边边权都至少是$2^{k-1}$，而内部都$<2^{k-1}$，所以我们必然是内部连起来然后两侧放一个。

于是考虑$a$到$b$之间变化的最高位$k$，两部分之间的边权都至少是$2^k$。从这里断开递归两边。考虑当区间变成trie上的子树的时候剪一下，$[0,2^k)$的答案就是两倍的$[0,2^{k-1})$再加上$2^{k-1}$的一条边。

那么问题是有两个区间$[a,2^k),[0,b]$，要各找一个数使得xor和最小。考虑从高到低贪心，如果$a\leq b$那答案就是$0$，直接结束；如果$b<2^{k-1},a\geq 2^{k-1}$那这一位可以扔掉；否则我们让$k-1$位是$0$并递归下去。复杂度$O(q\log^2 v)$。

注意到除了第一次分治的合并，剩下的时候都有$a=0$或$b=2^k-1$，所以这些都是$O(1)$的，复杂度$O(q\log v)$。

Reprezentanci firmy

一眼模拟费用流。考虑怎么表示这个 一个区间至少有多少人 的限制，先不要上线性规划，让我们想一想。

想了想发现不行捏。线性规划，每个区间限制总和，每个人还要限制$\leq 1$，每行的$1$或者$-1$都是连续的，所以这玩意非常全幺模。对偶，问题变成给每个区间分配一个数$y$，每个人分配一个数$x$，使得对于每个人，包含他的区间的$y$的和减去他的$x$，结果$\leq$他的$c$，每个区间每选$1$可以获得$p$，$x$每选$1$获得$-1$，最大化总贡献。那么这个$x$的效果也就是多了多少减去多少呗。

哦这个对偶是不是和 雪的魔法 或者 zjoi2013 防守战线 差不多啊。

建图也是差不多的。建一排点从左往右连，每两条边对应一个人，这两条分别是容量为$c$费用为$0$的和容量为$\infty$边权为$-1$的边。每个区间从右端点对应边的右端点连到左端点对应边的左端点。跑最大费用循环流。

开始模拟费用流。发现这里会各种退流，完全模拟不了。

继续发现少看了一个条件，原来这是个树啊。dp，设$dp(u,i)$表示$u$子树，上面已经选了$i$的答案，那么子树间完全是互不影响的，可以直接求和，就看$u$选多少。当然猜测$dp$是凸的，为了证明这件事，我们在左边挂一个$s$右边挂一个$t$就变成源汇流啦。那么$u$选多少的贡献就是$f(x)=p_ux$再加上不包含在子树中的部分的那个超过的代价，它们都是上凸的，于是闵和即可。这里需要用平衡树启发式合并维护。

所以是不是一开始就可以直接dp。设$dp(u,i)$表示$u$子树选了$i$个人，满足子树中所有限制的答案。转移也注意到答案是凸的，闵和即可。

Sieć

也就是邻域$\pm 1$，保证没有负数，求链$0$个数。

那么我们考虑设$k=500$是长度限制，怎么$O(n\log n+qk)$之类的。

点分治，找到包含路径上至少一个点的$O(k+\log n)$个分治块，对每一块查询到它这里剩下的长度最大的病毒，然后正着倒着分别扫一遍就可以求出每个点是否被覆盖啦。复杂度$O(n\log n+q(k+\log^2 n))$，或者你也可以根据邻域半径的限制把$\log^2$改成$k$，看起来会更好写。

你的做法对，但是不如静态top tree。考虑没有$k$的限制咋做，感觉上并不好poly log，这里离线分治也似乎并没有优势。还是树分块吧，每块需要开个堆维护前/后缀覆盖的最长长度，复杂度$O(q\sqrt{n\log n})$。砍砍你的，对每一块离线所有的求$\max$，按照经典的做法，每次找到最大值并推平后面所有的查询，这里值域只有根号直接计排，再上个序列线性并查集就线性啦，总复杂度$O(q\sqrt{n})$。

Tunele czasoprzestrzenne

线段树分治，但是这里最短路变化量很大。是不是猜测它并不大就好了啊（

考虑一些别的能判负环的东西。真的存在这样的东西吗。

所以还是猜测我们需要的松弛量并不大吧。尝试分析但是并没有分析出啥。可以知道的是，必须要建虚点连所有点，并且猜测时间分治比直接删边快。

Bajholmska Firma Transportowa

从大到小扫，每次合并两个连通块。合并的时候会发生什么呢，感觉不是很好办啊!

考虑改成外层点分治，那么每条到分治中心的路径只有是否经过关键边和路径的$\min$有用，线性地卷卷然后给答案打个后缀加标记即可。复杂度$O(n\log n)$。

Kompresja drzew binarnych

从小到大排。但是为啥对呢。发现它确实不对，比如2 4444 4444 6666666666666666，从小到大我们得到4，但是把两个4444放在一起我们得到3。

考虑我们每次钦点出答案中的一个点。dp，设$dp(i,j,k)$表示考虑到$i-1,i$，$i-1$还剩$j$个，$i$还剩$k$个的答案。转移枚举一个点，把$d$看成$\frac{1}{2^d}$，它要满足和是某个$\frac{1}{2^k}$。复杂度也许是$O(n^5)$，这不重要。

考虑两个$i$可以代替一个$i-1$，所以我们应该尽可能多用$i-1$，也就是说把$i-1$打一包，然后尝试去补$i$。$i-1$自己会填满trie的若干子树，$i$的效果就是给它进位，我们需要决策有多少拿去给$i-1$进位啦，有多少拿去跟$i+1$配。这就可以线性的状态数了，设$dp(i,j)$表示$i$还剩$j$个的答案，转移枚举$i+1$用了$2k$个，就产生$\mathrm{popcnt}(j+k)$的贡献。注意到$\mathrm{popcnt}$只有$\log$种，相同的$\mathrm{popcnt}$下多用$i+1$必然不比把$i+1$堆起来留给$i+2$去配对优，因为你把低位都消灭了还往低位放就是直接让$i+1$在贡献嘛。所以有用的决策也只有$\log$种，复杂度$O(n\log n)$。

Skarbiec

显然下界是$\lceil\lg n\rceil$，而直接对每位问这一位是$1$的那些就达到了这个下界。

Bieg na orientację

如果只有一次查询。考虑其Y-center，枚举Y-center，这三个点必须来自不同的子树，或者某一个是Y-center自己。贪心选择最长的子树即可。换根dp得到子树外的信息，或者考虑以center为根也是可以的。

现在有多次查询，这就是一个三维偏序捏。注意到我们只求有没有，并且每维都是1-side的，我们把一维改成求$\max$，就一个$\log$啦。

Miasta partnerskie

看起来是稳定婚姻类似物。但是完全不是，我们直接给每个点找一个最大xor和并连边，那么能且只能选这些边，dinic即可。

Przekaźniki telekomunikacyjne 2

考虑我们枚举那个$\max$在$x$还是$y$上取得，画一画这告诉我们要斜着扫，然后就线段树维护即可。复杂度$O(n\log n)$，但是相当于要扫四遍所以比较的慢。

#### XXVIII(2020~2021)

我做了大部分poi，但我保留了一部分。我觉得保留一部分，才知道你马上要联合省选了。

## cnoi各省

### ahoi

#### 2022

A. 排列

这个就是各环长的$\mathrm{lcm}$嘛。然后交换的效果是把两个环串起来，枚举两个环长，不同的环长只有根号种，然后算算方案数即可。

B. 钥匙

感觉一下。考虑每种钥匙不超过一把怎么做，如果经过一把钥匙又经过一个宝箱，并且钥匙到宝箱的路径上没有别的宝箱，那么这个宝箱就有贡献，这就是两个子树或者子树和子树补的笛卡尔积。如果有很多把呢，枚举经过的第一把钥匙，从它出发在虚树上爆力dfs求出每个点作为经过的最后一个点的结果。为了保证它确实是第一把钥匙，笛卡尔积的一侧是所有点减去以它为根其它钥匙的子树。复杂度$O(n\log n)$。

有趣的是其实不需要这么做，我们从一个钥匙出发在虚树上dfs，走到宝箱就停下，把这一对贡献给此时这条链两端的笛卡尔积。那么看一下发现贡献不可能多也不可能少。

C. 山河重整

收录于 数数从入门到直僵僵地镶嵌在门框里。

D. 回忆

也就是给若干对祖先-后代，选尽可能少的链使得每一对都包含在至少一条链中。

这种题一看就不是很阳间啊。感觉树肯定还是很有性质的。考虑序列怎么做，直接全选!考虑网络流，但是不太好办。线性规划谢谢喵。直接设出每条链选多少次，那么看看这玩意是不是全幺模，发现它不是全幺模，那就离谱啦!

感觉还是比较厉害。既然啥都不行，那么我们嗯贪心吧，自底向上做，首先两边的链可以拼起来，没有拼起来的链可以往上延伸。看起来选链的问题，子树中总是只有已经拼起来的和还没有拼起来的链。

如果这一个点有一个到祖先的限制，我们首先考虑把经过这个点且还没拼起来的往上延伸。如果有多条还没拼起来的，那么我们延伸已经需要到达的高度最高的，因为总有一个要到达那个高度，那么维护按需要到达的高度最大的，在深度上打个标记即可。然后考虑是加一条还是把已经拼起来的破开，显然没再有别的决策了，看起来破开已经拼起来的可以让一条有再拼的机会，而加一条没有这个效果，答案都增加了$1$，所以我们把已经拼起来的破开。

接下来考虑怎么拼。有了这个反悔就比较简单了，我们维护这个点已经拼了多少条，现在加入一棵子树，如果前面还有没拼的就跟它拼一拼，否则，我们可以破开前面的两个拼这棵子树的两个。复杂度线性。

### bjoi

#### 2017

D1

A. 机动训练

平方的组合意义是选两个的方案数。于是设$dp(i,j)$表示分别结束于$i,j$并且前面也完全相同的路径对数，复杂度$O(n^4)$。

B. 树的难题

点分治先，每次合并最小的两棵子树，那么合并的时候也就是枚举一条链，枚举一个点，然后查长度在某个区间的颜色相同和不同的的最大值。对所有颜色开一个单调队列维护前两大，再对每个颜色开一个单调队列维护最大即可。

C. 魔法咒语

在acam上走，矩阵快速幂一下。有点萌萌了（

D2

A. 喷式水战改

平衡树，大力ddp。

B. 开车

单次查询显然是排序之后对应。这里一个非常好的事情是$\vert x-y\vert$对$x,y$还是比较独立的，因为固定$x,y$的大小关系它就是线性的啦。

考虑时间分块，每一块里面一个车的排名移动量不超过根号，也就是说它匹配的加油站的排名移动量不超过根号。对于一个车$i$，如果它匹配加油站$j$，那么在$j$的一个前缀它贡献$1$，对应的后缀它贡献$-1$，对于加油站也是一样的。每次移动的时候，我们查询一个区间内哪些车的贡献变化了，查询对应的区间内哪些加油站的贡献变化了，然后对于块内改到的所有位置和它们对应的位置爆力特殊处理，块间爆力归并重构。看起来这个查询需要离线双指针。复杂度$O(n\sqrt{n})$，细节大概不会少。

题解给了一个比较带劲的转化，数轴上一个单位长度被覆盖的次数就是前面车和加油站个数差的绝对值。所以就变成区间$\pm 1$，求全局绝对值加权和，这就比较经典了。

C. 同构

这么猛。2hard4me。

#### 2018

D1

A. 求和

模拟，插。或者爆力预处理也行/jy

B. 二进制

考虑什么情况下能重排成$3$的倍数啊。注意到$2^k\bmod{3}=1,2,1,2,...$这样的，所以要求就是如果奇数位放了$a$个$1$，偶数位$b$个，那么$a+2b\bmod{3}=0$。

考虑如果一个区间有至少两个$1$和两个$0$，那么一定行，因为$1100=0,1010=2,0101=1$，也就是说不管剩下的部分是啥，总可以把它调对。这里数组是从左往右写的。

如果不满足上面这个。如果没有$0$，结果是确定的。如果没有$1$，总是可行。如果有一个$1$，那么总是不行。如果有一个$0$，讨论一下如果区间长奇数则可行，否则不行。

然后可以开始大力维护啦。初始化答案是子区间个数，然后减去$0$或$1$的个数$<2$的。维护$0$的连续段，$1$的连续段，对每个$1$维护左右极长$0$长度，每个$0$维护左右极长$1$长度，每次修改变化量都是$O(1)$，平衡树即可。

看看能不能线段树啊。全$0/1$段个数是经典的。恰好一个$0/1$的段个数，再维护第二段极长$0$长度即可。

C. 染色

这么猛。考虑有奇环显然无解。但是有偶环也可能无解。手玩一下样例$1$，发现其实是说两个长$4$的偶环交于两个点，那么我们让两个交点分别是ab，在一侧限制如果是ab就撞，另一侧限制如果是ba就撞即可，那么让ab会撞的方法就是ac连a，bc连b。

然后就不知道我在想啥了。考虑长$4$的环，放ab bc ac cd这样的东西可以让第四个点总是d。任意长度的偶环也是可以的。那么如果两个偶环不交并且能各找一个点使得距离不经过这俩环且是奇数那就死了。距离是偶数的情况，注意到我们可以钦点任何颜色，所以只要反过来就好啦。

考虑两个环有交的情况。如果两个偶环有任意长度的连续的交。如果交的长度是偶数，我们还是在交上放满ab，这样两边一定一边是a一边是b，然后放ac和bc，中间放满cd这样的东西即可。如果交的长度是奇数，手玩一下，比如两个长$6$的环交于$3$个点，我们在交上放满ab，两边分别放ac cd ad和对称地ban掉两个b的东西即可。但是考虑长$4$的环交于$3$个点，看起来它是必然有解的。也就是说交之外的长度必须$>1$才能构造出来。

对于交不连续的情况，我们的构造大多数时候在用ab这样的东西，所以其实没有影响。

这就几乎结束啦。问题是怎么判，首先对每个连通块分开，随便找个dfs树，那么基础环个数就是$m-n+1$对吧。如果$m-n+1=0,1$，那么必然有解。否则先不停剥叶子。如果$=2$，就有至少两个偶环，如果有两个三度点，有解当且仅当剩下是那个两个环在交之外各只有一个点的case，如果是一个四度点，那么就有两个偶环交于一点而无解。如果$>2$，那么必然无解。

D2

A. 治疗之雨

当然dp，每轮我们会有$\frac{1}{m+1}$的概率$+1$，然后有$\binom{k}{i}\frac{m^{k-i}}{(m+1)^k}$的概率$-i$。

那么问题是怎么才能消的快一点。注意到它是一个上海森堡矩阵，所以直接做就$n^2$啦，也就是说我们用$f_i$去消$f_i-1$中的$f_i$这样的。

B. 链上二次求和

考虑一个点的贡献，如果链长是$n$，它在位置$p$，那么包含它的长度在$[l,r]$的区间个数就是

$$
\sum_{i=l}^r(\min(p,n-i+1)-\max(1,p-i+1))
$$

这个就是计算可能的左端点个数。为了方便一点，差分，现在只剩下$r$。把这个拆开，显然左边被$p=n-i+1$分成两段，右边被$p-i+1=1$分成两段，感觉上我们已经很接近了。

$$
\sum_{i=1}^r\min(p,n-i+1)=\sum_{i=1}^{n-p}p+\sum_{i=n-p+1}^r(n-i+1)=(n-p)p+\frac{(p+n-r+1)(r-n+p)}{2}
$$

需要特殊处理$r<n-p$的情况，此时它等于$rp$。那个$\max$是一样的。然后就可以求和，带深度的和，带深度平方的和来解决啦。

C. 双人猜数游戏

经典的。枚举答案$n,m$，那么两个人一开始知道$(i<s,j<s)$是不合法的，A知道$ij\neq nm$是不合法的，B知道$i+j\neq n+m$是不合法的。

A表示不知道，说明此时还有不止一种$(i,j)$，所以B可以同时对所有$i+j=n+m$的$(i,j)$一起模拟，A可以对所有$ij=nm$的$(i,j)$一起模拟。如果哪一轮两个人都没有排除任何东西，那就无解啦。这样的话B的初始状态数是$O(k)$，而A看起来跟因数个数有关所以非常低阶，单次复杂度$O(k^2)$。

然后也并不需要这样，我们可以估计一个答案的范围，同时进行所有的模拟，这样就是$O(k^3)$的。

#### 2019

D1

A. 奥术神杖

建个acam先，然后设$dp(i,j,k)$表示前$i$个，走到$j$，匹配了$k$次的最大乘积，复杂度$O(n^3\Sigma)$。

这个东西就是个$\ln$的平均，因为是平均我们希望尽可能把小的扔掉，但是这里有一些固定的位置所以比较麻烦。

考虑二分答案，然后就可以把个数移过去啦，这就$O(n^2\Sigma\log v)$了。但是看着不像能跑过啊?但是就是跑过了。

B. 勘破神机

$n=2$就是fib数下降幂和，转成普通幂，对着通项公式拆拆即可，复杂度大概是$O(k^2\log v)$。那么$n=3$大概也是个线性递推，根据具体数学上看到的奇怪式子的一点印象可以知道它确实是。容易写出一个dp，然后对着它jordan标准化即可，或者直接打表bm，或者直接用gf方法。递推式也是二阶的。

那么具体说一说怎么推吧，做点计算练习!设$f_n$是答案，$g_n$是有一侧多一个的答案，那么枚举最后一列有没有一个竖块，有$f_n=f_{n-2}+2g_{n-1}$，同样的有$g_n=g_{n-2}+f_{n-1}$。$4\times 4$矩阵的jordan标准型看起来就比较阴间。bm的话直接上即可。gf方法就是$F=z^2F+2zG+1,G=z^2G+zF$，需要手动检查一下边界，然后这是一个二元一次方程组。解是$F=\frac{1-z^2}{1-4z^2+z^4}$，虽然有$z^4$，但它是$z^2$的函数，所以这实际上是一个二阶的递推式。

然后强行展开。我们得到$\frac{1}{2(1-az)}+\frac{1}{2(1-bz)},a=2+\sqrt{3},b=2-\sqrt{3}$。$[z^n]\frac{1}{1-az}=a^n$，于是答案就是$\frac{1}{2}(a^n+b^n)$。然后我们要算

$$
\begin{aligned}
&\sum_i(-1)^i{k\brace i}\sum_{j=0}^l\left(\frac{1}{2}(a^j+b^j)\right)^i\\
=&\sum_i\frac{1}{2^i}(-1)^i{k\brace i}\sum_{j=0}^l\sum_{t=0}^i\binom{i}{t}a^{jt}b^{j(i-t)}\\
=&\sum_i\frac{1}{2^i}(-1)^i{k\brace i}\sum_{t=0}^i\binom{i}{t}\frac{1-a^tb^{i-t}^{l+1}}{1-a^tb^{i-t}}
\end{aligned}
$$

这就结束啦，复杂度$O(k^2\log v)$。更牛逼的做法是，注意到对于$m=2$，$ab=-1$，对于$m=3$，$ab=1$，也就是说不同的$a^tb^{i-t}$只有$O(k)$种。爆力计算每种的系数和即可做到$O(k^2+k\log v)$。$a^tb^{i-t}=(ab)^tb^{i-2t}$，我们只需要算每个$(i-2t,t\bmod{2})$的系数和，大概是

$$
\begin{aligned}
&\sum_i\frac{1}{2^i}(-1)^i{k\brace i}z^i\sum_{t=0}^i\binom{i}{t}\left(\frac{x}{z^2}\right)\bmod{x^2-1}\\
=&\sum_i\frac{1}{2^i}(-1)^i{k\brace i}z^i(1+\frac{x}{z^2})^i\\
=&\sum_i(-1)^i{k\brace i}\left(\frac{1}{2}z(1+\frac{x}{z^2})\right)^i\\
=&\left(\frac{1}{2}z(1+\frac{x}{z^2})\right)^\underline{k}
\end{aligned}
$$

看起来又变回去了。分治法法即可，复杂度$O(k\log^2 k)$。

C. 送别

这么猛。线段树分治，平衡树维护一下。但是也可以不用时间分治，用时间分治是因为插入删除的时候可能有信息量很大的一段出现或者消失，但是其实消失的时候可以split出去，出现的时候merge回来即可。

D2

A. 排兵布阵

直接大力合并。一眼看上去是$s$个长$m$的物品，实际上是$O(ns)$个长$1$的物品，复杂度$O(nms)$。

B. 光线

classic。dp，设$l(i)$表示从$i$左边来一束光的答案，$r(i)$表示从$i$右边来的答案，那么$l(i)=b_ir(i-1)+a_il(i+1),r(i)=a_ir(i-1)+b_il(i+1)$，边界是$r(0)=0,l(n+1)=1$，要求$l(1)$。容易想到消消，但是$n$很大。考虑这个矩阵非常带状，直接做就是$O(n)$的啦，不过这个直接做比较麻烦，考虑设出$l(1),r(1)$，那么可以解出$l(2)$，还可以解出$l(3)$，于是又可以解出$r(2)$，这样就可以表示所有东西了。

C. 删数

感觉峰哥前几天刚教我这个题。考虑答案是，如果$i$出现$c_i$次，则给$[i-c_i+1,i]$加上$1$，然后数$[1,n]$中$0$的个数。那么全局加减的时候我们不需要全都shift，只需要把查询的这个$[1,n]$ shift一下即可。

#### 2020

只有一题。

A. 封印

这么猛。不过看起来比较经典，建个$t$的sam，然后拿$s$在上面匹配，可以对于每个$r$求出它和$t$的lcs，设为$f_r$。那么问题是查询$\max\limits_{i=l}^r\min(f_i,i-l+1)$，二分答案，st表维护即可。

### gdkoi

#### 2023

提高组

D1

A. 太典啦。

B. 错排

收录于 数数从入门到直僵僵地镶嵌在门框里。

C. 异或图

感觉还是比较带劲。容易想到从高到低逐位确定，但是这样我们就需要知道连通性啦，比较没救。

考虑容斥，钦点一些边让端点相同，然后每个连通块选的就不超过其中$a$的$\min$。我们dp出这些连通块，同时直接强行记录哪些点是大小为奇数的连通块中的$\min$，只记奇数是因为大小为偶数的没有贡献。也就是设$dp(S,T)$表示已经决策了$S$中的点，$T$中的点是$\min$的方案数，那么$T$是$S$的子集，所以状态数是$O(3^n)$。转移枚举没选的编号最小的点所在的连通块，那么需要求出每个点集的连通生成子图个数。容斥，枚举编号最小的点所在的连通块，让它和剩下的点不连通，复杂度$O(3^n)$。这样一共就是$O(4^n)$啦。具体一点，$\sum\limits_i\binom{n}{i}2^i2^{n-i}=4^n$。

牛逼优化是，我们每次枚举还没选的部分中的$\min$包含在哪个连通块中，这样$T$中的点必然都比$\overline{S}$中的小。设$T$中的$\max$为$k$，那么$S$必须包含所有$\leq k$的点，设$S$大小为$s+k$。转移的复杂度是$2^{n-s-k}$，状态数则降为$2^k\binom{n-k}{s}$，对$s$求和得到$2^n\left(\frac{3}{2}\right)^{n-k}=2^k3^{n-k}$，总共是$O(3^n)$。感觉很震撼。

D2

A. 游戏

好眼熟。这个题是xxvii poi stage 3 Bieg na orientację。

B. 马戏团里你最忙

也就是每轮有$p$的概率等概率转移到一个超集，$1-p$的概率等概率转移到一个子集，对前$k$轮求每轮在每个$x$概率的加权和。

$n\leq 8$是好做的，矩阵快速幂即可。但是现在$n\leq 17$，好在我们已经知道这是一个线性递推题，但是你发现初值就不会求捏。

考虑怎么$\tilde{O}(2^n)$地迭代一轮。当然是使用法嘛塔。

劲爆的事情是递推式长度只有$O(n)$，这就赢了。爆力多项式取膜即可。为什么只有$O(n)$?不知道。

让我们复习一下怎么求最小多项式。随机两个向量把它压缩到一个数，然后跑bm。

C. 树

长剖先，主要问题是怎么shift一位，也就是所有$d$都$+1$。考虑链怎么做，感觉会链就都会了啊，所以链并不好做!

可以发现的是我们完全不会shift。但是链还是可以做的，考虑枚举一位看它出现多少次，那么相当于每$2^k$个位置交替求$0,1$的个数，可以前缀和一下。于是对于原问题，长剖，维护这个前缀和即可，为了维护它我们需要每个长$2^k$前缀的$k$位的$0,1$个数。复杂度$O(n\log n)$。

发现每条边合并量总是$\log$，所以我们其实不需要长剖，不过维护长$2^k$的前缀和时需要查子树某一层，在bfs序上前缀和即可。

### zjoi

#### 2022

D1

A. 树

考虑我们从左往右决策每个点是不是叶子，那么一个点可以在前面不是叶子的点中随便选父亲。但是第二棵树是倒着的，这就不是很好。

考虑钦点出后面有多少个点是叶子。这就好了。但是还有一个问题，就是我们钦点出来的叶子可能不是所有的叶子，也就是说不是叶子的点不一定真的有儿子。

继续大力钦点，我们记录现在是第几个点，第一棵树上前面有多少个钦点为不是叶子的还没有儿子，第二棵树上后面有多少个叶子，有多少个不是叶子的还没有儿子。复杂度$O(n^4)$。

考虑怎么砍一维，感觉不太好办。没有办法的话就考虑容斥，我们钦点一个位置是不是被错误地选成了叶子，于是钦点为叶子的和钦点为错误的叶子的的数量就可以合起来放在一维里，复杂度$O(n^3)$。

B. 众数

也就是我们可以选择一个区间，然后选择区间内的众数和区间外的众数拼起来。

首先我们选的这个区间，两端必然可以都是区间内的众数。于是考虑根号分治，少的数只给出$n\sqrt{n}$个可能的区间作为答案。

考虑多的数$x$作为区间外的众数的情况，我们把$x$看成$-1$，把另一种数$y$看成$1$，那么也就是要找一个最大子段和。同时对每个$y$维护当前的某种前缀和，加入$y$的时候，如果前缀和是负的则把它先置$0$，然后更新答案即可，加入$x$的时候则是全局$-1$。对于多的数作为区间内的众数的情况，也就是反过来了，看起来做法是一样的。

那么考虑少的数$x$作为区间外的众数的情况。我们知道这个区间端点的两侧可以都是$x$的一次出现，那么也就是求自己笛卡尔积自己的区间众数，但是这个看起来不是很好做。不过好消息是这个区间众数的出现次数不超过根号。考虑对于每个左端点预处理最小的右端点满足众数出现次数$\geq k$，双指针扫扫即可。总复杂度$O(n\sqrt{n})$。

C. 简单题

一般图上这是#p complete的，我们每条边给一个大约$2^\binom{n}{2}$的边权就可以归约哈密顿链计数啦(因为这里用到的数的长度还是多项式级别的)，所以一开始这个条件居然是重要的。

v-dcc之间看起来没有影响。考虑一个v-dcc可能是啥样的。考虑如果两个环有超过一段交，那么因为边权全是正的，这个可以推出一些边权是$0$，所以就不可能了。如果任意两个环只有一段交，如果有一个环，它和另外某两个环的交不完全相同，也是不可能的。那么也就是说所有的环都交于同一条链，此时相当于两个点之间有若干条不交的链，这个肯定是可以的，这种图好像被称为 杏仁 或者 纺锤体。

现在，爆力的话，要算从纺锤体一个点走到另一个点的方案数，那么我们走的路径一定是，如果在同一条纺锤丝上，可以直接冲过去。如果没有直接冲过去，那么必然先到达纺锤体的一极，于是就是ban了一条链之后一极到某个点的答案了，或者我们更多地枚举就是ban两条链之后两极的答案。如果是同一极那么我们选偶数条链排列，否则选奇数条，可以分治法法法出来。但是这个处理不了lca处的问题，感觉需要在平面分治结构或者平面扫描线上法法捏。

你是不是没有看懂我在说什么啊。妈的，怎么是权值和啊?那么考虑权值和怎么做，我们就只需要方案数了，所以可以直接预处理出来，复杂度就是线性的啦。

D2

A. 面条

这么猛。考虑$n=2^k$怎么做，发现$\log$轮之后就变成全部相同的了。那么考虑$n=98304=3\times 32768$，发现最后会剩下$[1,65536],[65537,98304]$两段，然后可以矩阵快速幂求出每一时刻两段分别是啥。但是这东西好像没啥用。

考虑$n=500$怎么做，因为是稀疏的线性递推，可以bm一下。$5\times 10^3$大概是一样的做法。

这个东西必须得有点用啊!猜测最后只会剩下$\log$段。我手玩了一下$n=18$之类的，看起来如果$n=2^kt$，$t>1$，那么$k+1$轮之后会有$\frac{t-1}{2}$个长$2^{k+1}$的段和最后的一个长$2^k$的，$t=1$则需要特判。设$l=\frac{t+1}{2}$为段数。强行考虑发生了什么，看起来如果每一段分别是$a_i$，$a_l$是那个长$2^k$的段，那么它就变成$\frac{1}{2}(a_1+a_l,a_1+a_{l-1},a_2+a_{l-1},...,a_\frac{l-1}{2}+a_\frac{l+1}{2},2a_\frac{l+1}{2})$。扔掉$\frac{1}{2}$，经典地考虑差分，令$b_i=a_i-a_{i-1},a_0=0$，那么前者操作后的$b$就是$a_1+a_l,a_{l-1}-a_l,a_2-a_1,...,a_\frac{l+1}{2}-a_\frac{l-1}{2}$，用$b$表示就是$b_1+\sum b_i,-b_l,b_2,-b_{l-1},...,b_\frac{l+1}{2}$，于是这非常接近一个置换了。$a_l=\sum b_i$很是不好，牛逼做法是我们直接把它扔掉，因为知道$l-1$个差分和总和(总和每次翻倍)还是可以还原整个序列。类似地考虑长$2^k$的段在最前面的情况，爆力计算可以知道它对差分的影响和$2^k$段在最后的情况的区别就是交换了相邻两项。建一个两层的图表示正负，现在我们会$q\leq 50$了。

现在考虑这个变换有啥性质，因为没性质还是不能做啊。首先考虑为了解出某个$a_i$我们到底需要啥信息，所有数的和中$b_i$会贡献$l-i+1$次，那么$b_1=s-\sum\limits_{i=2}^l b_i(l-i+1)$，而$b_1=a_1$，$a_i=a_1+\sum\limits_{j=2}^i b_j$。也就是说我们要求一个带下标作为系数的和和一个前缀和。爆力考虑这个变换在干啥，看起来它会把$1,...,l$变成$-l,1,-(l-1),2,-(l-2),3$，发现前一半的数位置都翻倍了。考虑一个牛逼构造，我们把数排成$1,...,l,-l,...,-1$，然后把$i$换到$2i\bmod{2l+1}$，看起来正好就是这个置换，非常猛兄弟!

那么接下来所有环的长度都是$\mathrm{ord}_{2l+1}(2)$的因数，我们爆力对每个环长$d$算一下贡献，于是每个查询都可以膜$d$，也就是说只有$d$种查询。对于每个查询，要查环上那个前缀中的位置的和，以及每个位置带一个位置的权的和，看起来前者也是某种带权和嘛，看起来这就是膜环长的循环卷积，可以法法一下做到$O(n\log n)$。然后每个环爆力贡献给膜$\mathrm{ord}_{2l+1}(2)$的所有余数，这个复杂度是经典的$O(n\log\log n)$。总共是$O(n\log n+q+\sqrt{v})$，最后那个是$\sqrt{v}$进制快速幂的预处理。

B. 计算几何

原来是典题/cf

菱形划分，完美匹配，最大独立集，原来都是你。



C. 深搜

## cnoi全国性

### ctt

#### 2012

D1

A. 楼房重建

classic。

B. 序列染色



### 集训队胡策

