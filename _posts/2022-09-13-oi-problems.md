---
layout: post
title: oi题选做
subtitle: 麻麻麻
tags: 题选做
---

从这一篇开始我要使用两个\$作为latex的标识符。

## Polish OI

poi大概是，有三轮，r1五题，r2 r3都是有D0 D1 D2，D0一题，D1 D2两题。

#### VIII(2000~2001)

R1

A. Liczby antypierwsze

tooooooooooooooo classic。

B. Mapa gęstości

前缀和。

C. Przedziały

模拟。

D. Gra w zielone

幸运的，这个题在谷上有。

请注意是在环上的部分要走过一个绿点，而不是整个/jy

发现如果一个A的点的后继有让A赢的，它就也是赢的，否则它是输的。如果一个B的点后继全是让A赢的，那么它也是赢的，否则它是输的。但是只知道这些不管用，我们可以让所有点都赢，也可以让所有点都不赢。

考虑如果不在环上的绿点也算数的话，那么我们只要一开始让所有绿点赢，然后按上面递推就好了。注意到如果从一个绿点出发必然可以到达自己，那么它必然是赢的，否则这个绿点是无用的。发现我们从有用的绿点出发递推就可以得到正确答案，所以问题是求出哪些绿点是有用的。

做法是，我们先把所有绿点置为有用的，然后有用的绿点必然是赢的，递推出哪些点是赢的，如果一个有用的绿点其实是输的，那么就把它置为无用的。于是每轮减少至少一个绿点，复杂度$O(cm)$。

为了证明这个奇怪东西的正确性，考虑最后每个输的点显然真的不能赢，而每个赢的点确实可以走到一个环上，而由于是从一些绿点开始递推，环上确实必然有一个绿点。

R2

D0

Gorszy Goldbach

找到一些大素数快速减少数的大小。打表即可。

D1

Spokojna komisja

2-sat。

Wyspa

没太看懂题意。应该模拟就行了吧/oh

D2

Mrówki i biedronka

没太看懂题意。应该模拟就行了吧/oh

Podróż

题意不是很懂，看起来是什么大力建图dij?

R3

D0

Wędrowni treserzy pcheł

判定基环树森林同构，考虑基环树，每个子树树hash之后相当于判定两个序列是否循环同构，跑个最小表示然后hash即可。

D1

Porównywanie naszyjników

考虑那个简单的最小表示都需要啥。发现我们需要求lcp，然后需要保证可能作为最小表示开头的位置数量很少。注意到一段只有第一次循环和最后一次循环中的位置可能成为最小表示的开头，所以后者已经结束了，而前者，考虑倍增hash，结束了。

Zwiedzanie miasta

智障了。随便跑一个欧拉回路，然后找到前缀和最小的点，从它出发就得到一个全正的。和raney引理有点像。

D2

Bank

如果只有一种货币，注意到每个人都不会让你的资金量变小，所以我们会每次选择加最少初始资金就能选的。

但是现在有四种货币，感觉上贪心好像真的可以得到一个极优解，我们只需要先让第一种最小，如果有很多个可以选的，让第二种最小，这样的。

Kopalnia złota

枚举一个横坐标，线段树维护纵坐标，那么一个点在一个横坐标区间贡献一个纵坐标区间。

Łańcuch

直接dp。考虑我们首先要让$n-1$是1，剩下的都是0，所以设$dp(i)$表示变成$i$是1前面都是0的步数，为了这么做发现我们只有送一个1上去才能把最低的1拿掉，所以看起来策略就是每次把当前末尾极长我们想要的段(一些0之后一个1)往上扩展一个1，然后把下面那个1扔了，直到够到$n$这样的。

#### IX(2001~2002)

R1

Superskoczek

我们尝试让马分别往上走一步，往下走一步，往左走一步，往右走一步。注意到必然存在一种方案使得马的坐标绝对值保持在$101$以内。搜即可。

或者使用格的线性基，称为hermite标准化的算法。std做法本质就是这个。

Komiwojażer Bajtazar

模拟。

Wyspa

转一圈双指针即可。

Zamek

直接dp。

Koleje

noip2012 借教室。noip出poi原题/jy

线段树模拟一下。

R2

Izolator

这是一个匹配问题。考虑每个数可能贡献正的它，负的它或者不贡献，不贡献显然没劲，然后我们希望让最大的若干个数贡献正的，最小的贡献负的，所以构造一下发现可以最大的$\lfloor\frac{n}{2}\rfloor$个数贡献正的，最小的$\lfloor\frac{n}{2}\rfloor$个数贡献负的。

Działka

模板 最大子矩形。

Wyliczanka

excrt。

Kurort narciarski

还是直接dp。

Protokoły

不是很能看懂题意。不过肯定可以直接dp吧。

R3

Minusy

这个问题好像很经典，似乎在arc出现过。对于每一段连续的加号，我们在两边放一对括号。arc搬poi/jy

Narciarze

这个看起来不是最小路径覆盖啊，也不是最小割。但是上下界最小流就好了!

Waga

背包。

Liczby B-gładkie

数论题/jy

min_25/洲阁筛的第二部分。

Nawiasy

直接dp。

Szyfr

模板 knapsack。折半。

#### X(2002~2003)

R1

Ciągi bez zająknięć

考虑有没有一个$\log$个的构造。发现可以把原序列复制一份，在中间加入一个没有出现过的字符。

交一发wa了。考虑有没有一个$O(1)$的构造。发现两个字母肯定不行，但是搜一搜或者手动构造，发现三个字母可以构造出$n=8$，一个做法是$abcbabca$。结论是thue-morse序列的差分是square free的。

或者可以大力随。注意到长度超过某个足够大的$k$的square几乎不可能出现，而它们有$n^2$个，那么取$k=120$看起来足够，如果往后加入一个字符后，出现了长度$\leq k$的square，则删掉它。我们只需要维护$k$个前缀和即可。为了证明这个东西的复杂度，请见 https://www.sciencedirect.com/science/article/pii/S0304397515006489。

为了写checker，看起来需要使用lyndon array那一套。

Liczby Przesmyków

数位dp。

Czekolada

也就是如果选一个x的时候，前面有$k$个y被选了，那么它带一个$k+1$的系数。dp即可。

Przemytnicy

dij。

Płytki drukowane

大力dp，直接存两端的状态。

R2

Mastermind II

模拟。

Autostrady

2-sat。hnoi搬poi/jy

Trójmian

读错了三遍题。

弱于 zjoi2017 多项式。

Kafelki

根据周期引理，如果$k+l-\gcd(k,l)\leq n$，那么$\gcd(k,l)$也是周期，并且显然不需要存在比它更小的周期，所以答案是$\gcd(k,l)$。如果$k+l-\gcd(k,l)>n$，那么$\max(k,l)>\frac{n}{2}$，不妨设$k>l$，那么我们知道如果没有$k$，$l$导致了$l$个等价类，而$k$的作用是合并了其中$n-k$对，所以答案是$l-(n-k)$。

Połączenia

考虑k短路说了啥，我们跑一个floyd，从每个点出发建最短路树，然后真的跑k短路。这里我们可以$O(nk)$跑一次，方法是不合并堆而直接爆力向上找。

R3

Gra w dzielniki

如果这个数是一个素数，那么我们就需要遍历所有的素数。所以按任意顺序问所有的素数，问中了就除一下再问剩下的就好了。

Skarb

主要问题是两个人能不能相遇。我们分别找到环，进入环之前模拟一下，进入环之后只需要算个$\gcd$。

Sumy

考虑同余最短路，我们从$0$出发bfs，但是直接做是$O(na)$的，所以bitset维护一下就$O(\frac{a^2}{w})$了。

Kryształ

完全没懂它在说啥。

Małpki

终于有2e5题了。直接拓扑排序。

Tasowanie

把环求出来，然后直接算这个置换就好了。

#### XI(2003~2004)

R1

PIN-kod

没看懂。

Zawody

模板 有向图最小环。跑两个bfs。

然后发现可能不太对啊!不过我们枚举第一条边走的是哪条边就好了。

Gra

跳棋/jy

读错题/jy

很容易想起sdoi2019 金币游戏，所以我们尝试转成staircase nim。发现两个空格之间就是一个staircase，然后就结束了。

Szpiedzy

也就是有一个内向基环树森林，那么我们在环上枚举任意一个点选还是不选把环断开，在树上直接dp即可。

Sznurki

原来string真的是弦而不是串串。

数量可以直接dp，把子树传上来的接起来即可。长度的话当然二分，然后就是接的时候最长的接最短的，次长的接次短的，这样的。长剖之后计排，复杂度$O(n\log n)$。

R2

Most

好像很经典，但是我好像没见过。

考虑样例，容易想到我们可能让两个很慢的老哥一起过，此时对面需要有一个快的老哥等着回来。也就是说，我们可以

 - 让最快的人带一个人过去

 - 让最快的人和第二快的人过去，最快的人回来，两个人过去，第二快的人回来

一定是一个后缀被第二种带过去，枚举即可。

Bramki

问题是可能有环，有趣的是如果有环的话输出可能仍然是确定的，这个题意大概是对于一开始的状态，按任意顺序调整，直到。类似 viii poi Gra w zielone 的做法，我们全赋成$1$调整一遍，全赋成$0$调整一遍，如果一个门两遍得到的相同，那么它是确定的，否则它是不确定的。

Jaskinia

也就是求一个深度最小的点分治。

看起来很困难。考虑点分治本质是什么，发现它是给每个点分配了一个深度，然后我们找到深度最小的点划分下去，如果这个点唯一那么就可以建立一个分治结构，而唯一当且仅当两个深度相同的点不会出现在同一个分治块，也就是它们之间的路径上有一个深度更小的点已经把它们分开了。

考虑自底向上做，维护哪些深度有一个点满足上面还没有一个深度更小的点，这里深度是$\log$级别的。然后合并子树的时候如果有相同的，那么这个点的深度必须比它们小，分配尽可能大的深度即可。这么做是不劣的，因为大的深度可以由大的深度来解决，小的深度则需要小的深度，这玩意感觉上有点类似树上的某种进位，但是不是很理解啊。

考虑用一个简单的东西描述一个过程，这种做法可能叫compress?感觉它可以帮助你换扫描线方向，比如点分的方向是在点分树上扫，但是我们描述了点分树之后，就可以直接在原树上扫。但是也许除了点分治以外没有哪个题可以这么做了。

Przeprawa

又见面了。然而好像没有，这个直接爆力即可。

Turniej

考虑一个波特什么时候能赢，我们认为一条边从赢指向输，那么如果把没有边都当成双向边，从它出发可以到达每个波特，它就赢了，构造方法是在生成树上自底向上进行比赛。但是这个好像不是很行。

注意到如果有超过一个波特能赢，那么一个波特能赢，当且仅当它可以打败一个能赢的波特，因为它必须打败所有波特，而打败了一个能赢的波特的话，只需要先让这个波特打败别的所有波特即可。所以我们找到一个能赢的波特，然后找到所有可以打败它的波特，就得到了答案。

考虑凑一些限制，如果波特$u$必然不能打败$v$，那么说明$v$必然打败$u$和所有$u$可能可以打败的波特，那么$v$的出度必然严格比$u$大，所以我们知道出度最大的波特必然可能赢任何波特。

接下来找到所有能赢的波特，我们知道如果不是所有能赢的波特都到某个波特有边，那么这个波特也能赢。一开始把出度最大的波特标记为能赢的，每次取出一个能赢的波特，维护一个还没能赢的波特的列表，找到所有它不必然打败的波特，标记为能赢的。注意到每次一个还没能赢的波特没有被标记为能赢的，都要求新处理的能赢的波特到它有边，所以复杂度是线性。

R3

Zgadywanka

为了得到满分，你需要赢三场。

我们直接找到概率最大的。如果这个数是$x$，还有$t$个数没出现，其中有$k$个$<x$的概率就是$x^k(1-x)^{t-k}$。

Wschód-Zachód

注意到主要问题是要到达中间那个狭窄的地方。直接在东侧模拟即可。

Wyspy

怎么还计算几何的。

为了把树建出来，经典做法是从边上往外画一条射线，考虑撞到的第一个多边形，它要么是父亲要么是兄弟。为了避免成环，每个多边形从最右的点往右画射线即可。为了画这个射线，使用线段树维护。

Kaglony

对于第一种，我们可以把每个连通块分开。对于第二种，在补图上把每个连通块分开。

但是怎么算补图的连通块啊?简单想法是bitset，复杂想法是别乳卡。更简单的想法是，我们每次加入一个点，然后枚举它的邻边，如果一个连通块中不是每个点都和它有邻边，那么发生了一次合并，这个可以维护没有边的连通块的列表做到线性。注意到每两轮必然分别是两种情况，所以边数会减少至少$n$，并且进行$n$轮必然结束，所以轮数是$O(\min(n,\frac{m}{n}))$的，当然一般来说很松。复杂度$O(m\sqrt{m})$。

Maksymalne rzędy permutacji

周期是所有环的周期的$\operatorname{lcm}$。为了最大化这个，我们必然选择一些不同素数的幂，然后从小到大排列它们，对得到的每一个区间转一下。现在问题是最大化$\operatorname{lcm}$，dp值我们猜测取个$\ln$就赢麻了，所以要用若干个素数幂做背包。为了卡常，注意到很大的素数不会用到，扔了就赢了。

Misie-Patysie

相当于平面上有一个棋子，你可以往左，往下，往左下移动。

不知道干什么的时候你就打个表，发现先手必败的状态$0$很少，只看$x\geq y$的部分，那么可以这么走出来 : 每一步可能是$x+=2,y+=1$或者$x+=3,y+=2$，记前者为$1$后者为$2$，则$0$的位置可以通过一个序列生成，序列的构造方式是一开始有一个$1$，接下来每次把$1$替换成$12122$，$2$替换成$12122122$。我们需要每次移动到一个$0$上，那么生成所有的$0$，然后找到一个即可。直接生成会得到长2e7的串，其实挺可以接受，但是你也可以预处理每一轮保留多长做到恰好够用。

#### XII(2004~2005)

R1

Bankomat

一个密码可能出现，当且仅当去掉相邻的重复元素之后，它是所有移动序列的子序列。对每个串建子序列自动机，然后枚举每个密码上去跑，复杂度$O(10^lnl+\sum \vert t\vert)$，其中$l$当然是密码长度。

Punkty

经典问题是判断两个多边形是否相似，做法是转一圈求相邻边的点积和叉积，然后跑一个最小表示判断是否相等，如果允许对称则翻转之后再跑一遍。

现在问题是我们没法唯一地连成一个多边形。考虑求出凸包，剥掉凸包，求出凸包，剥掉凸包，如此直到所有点都被剥掉，然后依次比较每个凸包，每个凸包会确定一圈可能的变换，然后我们需要对这些东西求一个交，看起来很复杂啊。

考虑有没有一个简单想法。我们首先确定平移量，发现找到重心，然后把重心平移到重合即可。然后考虑放缩，可以选择距离重心最远的点，把这两个距离放缩到相等。然后考虑旋转，我们从重心出发记录相邻两个点的点积和叉积，然后跑最小表示。

Samochodziki

这个是 模板 离线寄存器调度问题。做法是贪心把下一次选择时间最远的放回去。

Skarbonki

当然是内向基环树，我们打开环就赢了，为此需要打碎每个环上一个点。

Skoczki

又见面了/jy

R2

Lot na Marsa

又见面了/jy

然而这个没那么原，因为它让你求出所有解啊。问题是查询区间最小前缀和，这里单调队列即可。

Banknoty

已经不会背包了。单调队列。

Sumy Fibonacciego

加起来爆力模拟进位。

Kości

也就是给图定向，使得出度的最大值最小。二分答案，然后考虑网络流，直接建就行了，复杂度$O(m\sqrt{m}\log n)$。

Szablon

好像前两天汪娟给我看这个题来着。考虑答案必然是一个前缀，当然也必然是一个后缀。我们枚举一个前缀，考虑所有它的出现位置，如果这些出现覆盖了整个串那么就可行，这可以z algo求出来。所以我们只关心相隔最远的两次出现。从短到长枚举前缀，那么出现的集合会逐渐缩小，用链表维护所有的出现即可。

R3

Dziuple

也就是求二分图的平面嵌入数。考虑连通怎么做，注意到如果左部最下面那个点是$u$，那么$u$的邻接点只能有最多一个还有别的出边，否则就会相交。设这一个点是$v$，那么$v$的邻接点只能有最多一个还有别的出边。所以图必然是一个毛毛虫，我们把主链两端的叶子数$+1$再乘起来，剩下的叶子可以随便排列，还要考虑翻转链和放在哪一边，再乘一个$4$得到答案。注意单点需要特殊处理。

考虑不连通怎么做，不是单点的连通块之间排一排，单点则可以插在任意位置。

Akcja komandosów

没太看懂。据说是求最小的前缀使得这些圆没有交。

考虑了随机增量，好像不太行。

考虑我们找到交中最右的点和最左的点，考虑前者，发现这个点必然是由一个圆中最右的点或者两个圆的交中最右的点贡献，继续发现它必然是所有两个圆交中最右的点中最左的。所以爆力枚举即可，复杂度$O(n^2)$。

Dwa przyjęcia

猜测答案必然是$n$。归纳，如果所有点都是偶度点就赢了，否则删掉一个奇度点$u$，得到一个方案，那么$u$必然到其中一边有偶数条边，另一边是奇数。不管加入到哪一边，$u$加进去之后，邻接点的度数就都变成奇数了，于是我们考虑能不能通过加一些边再递归下去，然后把这些边删掉换成$u$和它们之间的边。把邻接点之间的边全部取反然后递归，此时删掉这些边，那么到$u$有偶数条边的部分，$u$的邻接点度数都是奇数，此时加入$u$就赢了。

译自 Combinatorial Problems and Exercises by László Lovász。

Dwuszereg

容易想到抽象成xor方程组，这里问题是什么有若干个$x_i\operatorname{xor}x_j=0/1$，当然把它看成边，注意到每个点度数不超过$2$，所以是若干个环和链，模拟即可。

Autobus

usaco好像也搬过这个。扫描线BiT或者分治一下。

Lustrzana pułapka

首先注意到我们只关心是否回到了原点，所以可以把反射改成取模，也就是从一个边界出去则从另一个边界回来，这相当于撞了一个边界就进行一次对称。这个看起来性质要好一些。接下来自然考虑把它无限延伸变成一条完整的射线，而原点被复制无限份，不过这个好像没太有必要。

设射到了$(a,b,c)$，那么我们称这是一步，则会在$\frac{\operatorname{lcm}(2x,a)\operatorname{lcm}(2y,b)\operatorname{lcm}(2z,c)}{abc}$步之后撞到原点。所以我们得到答案是$(a+b+c)\frac{\operatorname{lcm}(2x,a)\operatorname{lcm}(2y,b)\operatorname{lcm}(2z,c)}{abc}$。

但是还有一个小问题，就是这里射线不能碰到棱，所以还需要算一下。注意到我们要么永远不会撞到棱，要么在第一次撞到原点之前就会撞到棱。考虑前两维，如果存在$\frac{a}{b}=\frac{(2i+1)x}{(2j+1)y}$，也就是$2(jay-ibx)=bx-ay$，那么就会撞到棱。exgcd一下，我们知道这等价于$\gcd(ay,bx)\mid\frac{ay-bx}{2}$。注意到这个式子成立当且仅当$ay-bx=k\gcd(ay,bx)$中的$k$是偶数，那么$\frac{ay}{\gcd(ay,bx)},\frac{bx}{\gcd(ay,bx)}$不可能都是偶数，所以它们必然都是奇数，所以也就是$ay,bx$中$2$的幂次相同。

现在可以一个$\log$算一个点的答案了。考虑什么样的点可能有贡献，注意到如果$a,b,c$都选的很大，并且分别和$2x,2y,2z$互素，显然是很优的。如果$a,b,c$都很小，那么好像就比较的拉。选择$a=x-1,b=y-1,c=z-1$，答案至少是$(x+y+z-3)\frac{xyz}{8}$，如果想要进一步改善，$a,b,c$中有至少一个要和$x,y,z$对应互素。考虑$x$以内最大的和$2x$互素的数，发现它要么是$x-1$要么是$x-2$。但是很遗憾，这里还有一个限制，不过我们预处理一下哪些互素，然后分别往下枚举一些检查那个不能碰到棱就好了。看了一眼，三个分别往下枚举$12$个就过了。

Prawoskrętny wielbłąd

注意要回家的。

画一画观察一下，猜测一条路径合法，当且仅当每个角都合法，并且边的方向没有跨过$1\rightarrow 2$的方向，或者说只能转一圈。正确性还是比较显然的。

那么从$1$出发，把$2$作为$0$排一个极角序。现在开始dp。设$dp(i,j)$表示当前刚走了$i\rightarrow j$的答案，那么转移可以转移到$0\rightarrow j$和$i\rightarrow j$两个半平面bound住的一个部分。注意到固定$j$，则可以转移到的部分是$0\rightarrow j$右侧，$j$出发顺时针排极角序得到的一个后缀，所以对每个$j$开一个前缀和优化即可。复杂度$O(n^2\log n)$，瓶颈是排序。

#### XIII(2005~2006)

R1

Okresy słów

border和周期一一对应，这里好像就是要找一个最短border，那就真的把所有border跑出来就好了。但是应该没有这么复杂啊?

考虑我们类似于kmp，设$f_i$是前缀$i$的最短border长度，先爆力向$f_{i-1}$中插入$i$，然后最短border的信息就都包含在前缀$f_i$中了，跳$f_{f_i}$就得到答案。复杂度$O(n)$。

Krążki

模拟。

Żaby

请注意这里是平面，距离是欧几里得距离。

最小瓶颈树是线性的，主要问题是要求到每个点最近的关键点。把式子写出来，发现它是一个二维的东西，看起来我们需要把它化成一维的。

试了一下发现好像不能类似 货币兑换 一样做，那么就是不能直接化成凸壳了。考虑怎么让它简单一点，注意到两维是独立的(你不会没有把根号扔掉吧?)，所以先对每个点求出同一行的点中最近的，然后这个就变成了一个常数，再对每个点求同一列中最近的即可。总复杂度线性。

Tetris 3D

发现是矩形max矩形推平，然后这里max是单增的。满点集，四分树，复杂度$O(d^3)$，是不是就过了啊!

注意到并不是满点集，最大值必然在某个立方体的角上取得，所以只把这些点拿出来建2-dt，复杂度是$O(n\sqrt{n})$的。

由于max是单增的，也可以树套树俩$\log$。

Profesor Szu

没有环的话就dag dp。有环的话，只要可以走到环就是答案，所以从环出发倒着dfs即可。有向图找环，使用kosaraju或者tarjan scc。

R2

Magazyn

当然切比雪夫转曼哈顿，然后就中位数了。转回来之后不一定是整数。

Szkoły

容易想到费用流，但是直接建的话边数是$n^2$的。哦network simplex是不是就过了啊?事实是，所有东西都过了。

由于$k$都不一样，看起来很难优化建图。

Metro

这里是允许交的。注意到我们每次必然是从已经选了的部分出发往边上扩展两条链，因为如果和已经选的部分不交，换一下就交了并且必然不劣。从一个直径端点出发长剖，选前$2l-1$长链。

Najazd

凸包上的差分，我们设$s(i,j)$表示从$i$顺时针转到$j$的区域中所有点的权值和。

Listonosz

我们把规定的一串边直接从起点连到终点。但是问题是，可能出现两个序列包含同一条边，所以需要先建一个空图把这些序列加进去，然后在上面dfs得到所有极长的序列，然后拿这些去跑。

Orka

考虑最后我们肯定会把一维全部删完，另一维则可以留一些不删。区间dp，设$dp_1(i,j)$表示第一维删到$[i,j]$，尽量删第二维，可以删到哪里。转移就往里删一步。

R3

Tańce w kółkach

感觉小膜数很有用，所以先搞个式子。发现它就是$n![z^n](\sum\limits_{i=l}^\infty\frac{z^i}{i})^k$，那么猜测$n$很大的话直接全膜成$0$了，想了想发现是真的，因为$p$出现至少$\lfloor\frac{n}{p}\rfloor$次，那么注意到$5^\frac{n}{5}401^\frac{n}{401}$增长的显然比$n$快多了，所以比如$n\leq 1000$爆力卷，更大的直接输出$0$即可。

Estetyczny tekst

dp，设$dp(i,j)$表示最后一段选了$[i,j]$的答案，转移考虑上一段，发现就是某个长度以内的绝对值是一边，以上的是另一边，那么我们双指针扫这个分界点，前缀和优化即可。

Kryształy

容易想到从高到低数位dp。注意到如果一个数不顶上界了，它就完全自由了，剩下的数不管怎么选，它都有唯一的方式把剩下的数调整成正确的。所以我们考虑在最先不顶上界的数处统计一个方案，如果有多个那就取编号最小的。

Misie

大力dp。

Palindromy

题意好像是，给若干个回文串，求其中有多少对接起来还是回文串。

枚举长的，那么短的需要是它的前缀，插个trie即可。

Zosia

发现这个有向边其实是无向边，所以就是求一个最大独立集。注意到一个连通图的最大独立集不超过点数的一半上取整，所以只有$O(k)$个点在非平凡连通块中，套用$1.1996^n$的最大独立集，复杂度在有且只有一个非平凡连通块，大小为$2k+1$时最劣，所以是$O(1.1996^{2k})$。

遗憾，这个题直接随一个顺序贪心就过了。

#### XIV(2006~2007)

R1

Drzewa

考虑我们直接枚举换完之后的四个符号，得到四维偏序，然后仨$\log$排序分治分治BiT即可。需要特殊处理相邻的。

注意到我们要换的位置左右哪个大哪个小是没有关系的，所以就只剩下两维了，也就是对于$i$有$a_i<\min(a_{j-1},a_{j+1}),\min\leq a_i<\max,\max\leq a_i$，对$j$同理。

Biura

也就是在补图求连通块个数，怎么感觉已经出过这个了。考虑枚举一个点，如果它到前面某个点有边则标记不合并，然后把剩下的都合并了，复杂度线性。

Zapytania

经典。莫反。

Osie symetrii

所有的对称轴必然过重心，所以先找到重心，然后维护哈希值和中心对称之后的哈希值即可。

Atrakcje turystyczne

从每个关键点出发dij，然后状压dp。

R2

Grzbiety i doliny

模拟。

Powódź

注意到每个最低的点组成的连通块显然需要放一个，所以从小到大放，模拟一下它排空了哪些点。但是可能你会从一个谷里跳过去，复杂度就飞了，这就很麻烦。发现这是瓶颈路，所以考虑从低往高扫，某种意义上是自底向上扫答案的kru重构树。

Skalniak

考虑了很多强行做法，但是不好优化。考虑如果一个方案中$x=y$两侧都有点，那么全都翻到$x=y$的一侧必然不会让周长变长，画一画你就发现这些边全都对应起来了。

于是考虑如何最小化重量和。我们可能会把一些东西翻回去，要想不让周长变长，只能是做刚才那样的翻折的逆，所以画一画一共有四种可能的答案。赢了。

Megalopolis

差分，问题变成子树加单点查询。

Tetris Attack

考虑直接从左往右扫，维护还未匹配的部分，加入一个的时候往前找，如果有就换到一块，感觉除了它没啥东西可以正确了。用BiT维护还剩多少即可。

R3

Koleje

看起来是一个斯坦呐树。两倍让我们想起tsp的近似算法，考虑用任意dfs序近似最小斯坦呐树，于是从每个关键点跑dij即可。

Gazociągi

注意到每个点的贡献是确定的。

Odważniki

先全都除掉最小的那个。考虑这个东西相当于，每个容器的容量是一个奇怪进制的数，那么从低到高尝试消掉每个容器的每位即可。也就是如果有一个容器当前这一位非零，那就去放。如果物品用完了，就看下一位，否则尝试把下一位也填满，这里优先填下一位非零的。

据说可以直接把所有的容器不进位地加起来。

Egzamin na prawo jazdy

完全没有一个方向啊。考虑每条路能到一个区间，那么能到所有路当且仅当能到第一条和最后一条。同时，第一条路能被一个前缀到达，最后一条能被一个后缀到达，所以答案是一个区间。注意到能到第一条路是贪心往右走，能到最后一条是贪心往左走，两边是独立的，所以可以分别求出加$i$条边最远可以到哪，然后卷起来。

先考虑第一条，最后一条是类似的。看起来我比较智障，可以发现跑一个lis，不在lis中的位置就是需要加边的位置，然后就结束了。

Klocki

容易想到$n^2$，设$dp(i)$表示最后一个选了并且有贡献的是第$i$个的答案，那么$i$可以转移到$j$，当且仅当$j-i\geq a_j-a_i$，也就是$a_j-j\leq a_i-i$。BiT即可。

Waga czwórkowa

感觉很困难。还是考虑数位dp，设$dp(i,j)$表示高$i$位，$i$及以上还有$j$没有消去的最小个数和方案数，这里$j$是以$i$作为第$0$位记录的。注意到如果一位选了超过$4$个，那么也一定不优，如果一位同时被两边选了，那么也一定不优。主要问题是$j$可以多大，显然它不能超过$2\log_4 n$，当然这个还是太松了，可以猜测它的绝对值不超过$2$，因为低位最多只能凑一个无限接近$1$的数。

#### XV(2007~2008)

R1

Klocki

枚举最后我们选的区间，那么肯定它们都要贴到中位数上去。对顶堆即可。

Plakatowanie

单调栈，贪心地，这看起来确实是最优的。

Cło

二分图匹配。

或者发现我们只要找到一个生成基环树森林即可，所以dfs然后随便再找一条边。

Szklana pułapka

感觉很离奇。首先由于这是光，我们只要找到从每个点出发会在哪结束。考虑不会有两个这样的过程在某一时刻状态相同，否则它们必然来自同一个起点。

洛谷上的翻译没提到周长很小。爆力找到边界上所有点，然后模拟即可。

Robinson

相当于把每个障碍物都变成中心对称的船的样子，然后船变成一个点。bfs即可。

但是这里有$2000$啊?考虑找到船的中心，然后我们希望每次都能真的把一个位置推成障碍，那么容易想到bitset，但是这里不太需要，考虑我们顺着船的方向扫，那么每个障碍是一个长度先变大再变小的区间推平，注意到投影在扫描线上同一个位置的障碍，同时只有一个在贡献，并且一个贡献结束了就不再贡献，双指针一下，然后差分-前缀和就赢了。复杂度$O(n^2)$。

R2

Blokada

建个圆方树，然后直接结束。

BBB

枚举转了多少次，然后我们会把前若干个$-1$改成$+1$，后若干个$+1$改成$-1$。现在$n\log n$是简单的。

考虑类似于某个经典题，发现其实我们所要的就是前缀和的最小值，因为它变成正的了就全都变成正的了，并且它必然可以变成正的。单调队列即可。

Pociągi

爆力hash。对每个等价类维护一个大小，一共有$O(n+m)$个等价类，一个车相当于查询了一个区间$\max$，四毛子即可。另外最好写的区间半群是并查集。

Mafia

这是一个内向基环树森林。dp，如果是树，设$dp(u,0/1)$表示$u$能/不能活到开枪的答案，转移枚举每个儿子有没有开枪，如果有儿子开枪了那么$u$就可以死。现在有一个环，钦点一个人，从他身后断开即可。

Ucieczka

感觉很厉害。考虑只能往右拐说的是啥，发现我们接下来可以干啥会受到且仅受到前两次转弯时位置的影响，于是可能的状态数是$O(n^4)$。前缀和优化，直接冲，直接过。小问题是按什么顺序枚举，按两维的差枚举就行了，类似于区间dp。

R3

Lampki

请注意颜色$k_i$只是一个说法，实际上它们是互不相同的。考虑crt，发现对于$i$，答案是$\displaystyle\frac{\prod_{j>i}(p_j-1)}{\prod_{j\geq i} p_j}$。

Kupno gruntu

容易想到$n^3$，也就是枚举一边，双指针另一边。猜测我们需要一些好性质。如果一个数$\geq k,\leq 2k$，那么可以直接选它。如果一个数$>2k$，那么不可能选它。现在每个数要么是障碍要么$<k$。考虑如果有一行的一个区间和$\geq k$，那么必然可以删一些数使得它$\leq 2k$，所以就赢了。但是答案可能不是行的区间，继续考虑这个想法，枚举$y$上的投影，我们得到若干个列的和，如果一列的和$\geq k,\leq 2k$，直接选，如果$>2k$则是障碍，那么问题是求障碍之间有没有一段的和$\geq k$。考虑固定这个投影的上端点，枚举下端点，那么我们可以知道每个位置何时变成障碍，在它变成障碍的时候分裂它所在的段。倒过来把分裂改成合并，并查集维护，复杂度$O(n^2\alpha n)$。

然后发现这个过于复杂。注意到如果一个矩形不包含$>2k$的数，并且它的总和$\geq k$，那么它的子矩形中必然有解。考虑如果有一行的和$>2k$，那么这一行一定有一个区间是解，否则一定有若干行组成一个解。单调栈求个最大权子矩形即可。

Podział królestwa

也就是求一个子集到另一个子集的边数。dp，复杂度$O(2^n)$。但是这个题卡空间，那就一边搜一边算。

具体地，也就是你要把一个点从一个集合移动到另一个集合，那么边数的变化量是简单的。为了从这个生成所有可能的状态，枚举所有$2^n$个状态，然后总共发生$O(2^n)$次切换。

Trójkąty

直接做。注意到叉积的式子是$(x_b-x_a)(y_c-y_a)-(y_b-y_a)(x_c-x_a)$，展开之后每一项只和两个点有关，不过外面还有一个绝对值，发现这个符号就是它的方向，所以就是半平面数点，枚举一个点，给剩下的排极角序扫过去即可。

Permutacja

感觉之前有场cf出过这个。如果这一位卡着，那么就卡着了，否则这一位放一个更小的，剩下的部分可以随便排，一个还有$c$次没有出现的元素的贡献是$\frac{1}{c!}$，那么所有更小的的贡献就是$\frac{1}{c!}+\frac{z}{(c-1)!}$，BiT维护前缀积即可。

膜数不是素数，crt，维护一个数的时候附带当前考虑的素数的次数即可。当要做加法的时候，必然是直接统计进答案了，所以可以直接转成整数。

Stacja

发现如果两个点只需要一张票，那么一个是另一个的祖先，那么省掉的票的总数就是每个点的深度和。直接换根dp即可。

#### XVI(2008~2009)

R1

Straż pożarna

注意到到两个点距离相等的点是一条折线，大概是这个样子 : 

![img](/img/xiv-poi-r1-a.png)

那么边上的都矩形数点数掉了，主要问题是中间那个。考虑平时我们是怎么数任意多边形的，差分成一条斜线下方的部分和一个矩形，那么斜着扫，维护每个位置下方的点数即可，BiT。

Słonie

考虑每个位置不对的数至少要参与一次交换，分开考虑每个环，对于那个转一圈的构造，一个数要参与$n-1$次交换，剩下的每个数参与一次交换。那么我们显然希望最小的那个数贡献$n-1$次。考虑也可能会换环外的，那么我们希望全局最小贡献$n$次，这个环上每个数贡献一次。每个环对这两种取个$\min$即可。

Gaśnice

考虑了网络流，但是不凸，所以只好dp，但是dp也不会处理$s$。

考虑直接贪心，我们在尽可能高的地方放一个灭火器即可，也就是一个灭火器总是可以比它匹配的子树内最深的点高$k$。需要维护所有未被覆盖的点，每次取出其中最深的，然后维护子树中的灭火器。每次让尽可能深的灭火器匹配最深的未被覆盖的点。复杂度$O(nk)$。

Kamyki

考虑其差分，发现就是staircase nim。

Przyspieszenie algorytmu

也就是每次取$p$或者取$s$，用相同的调用序列取得的值的集合也相同。取出来的都是区间，所以我们直接会了多项式复杂度。

可以猜测，把连续段缩成一个，只保留每个数第一次出现和最后一次出现之后，两个序列相同那就是相同了。但是看样例发现假了。考虑取$p$就是删到第一次出现最右的数的第一次出现，取$s$就是删到最后一次出现最左的数的最后一次出现，但是注意到删的时候可能影响别的数的第一次和最后一次出现，这就完蛋了。

注意到颜色个数很少，考虑这玩意有没有什么用，首先这限制了状态数不超过$2^{100}$。/jy

考虑对于每个左端点，向右找到每个颜色个数增加的位置之前，反过来也是一样的，这样我们得到$O(nk)$个状态，猜测只有这些状态是可达的。考虑如果一个区间$[l,r]$，比如取了$p$，没有得到一个这样的区间，那么继续向右扩展，颜色个数仍然不变。

考虑直接搞出每个等价类。按颜色数从小到大处理，那么根据上一句话，我们已经知道取$p$取$s$分别会到哪里了，然后还需要限制取$p$删掉的那个字符相同，所以对于每个颜色数，给每个等价类分配一个编号，那么颜色数为$i$的就是颜色数为$i-1$的两个，和一个字符乘起来，基排然后离散化即可。复杂度$O(nk)$。

感觉我理解的很不深刻啊。

R2

Przechadzka Bajtusia

从两边往中间dp，设$dp(i,j)$表示$i$到$j$的答案，转移枚举两条边，转移的复杂度是$\prod\limits_{i,j}\deg(i)\deg(j)=O(m^2)$，然后转移的边权都是$1$，队列维护即可。考虑能不能把同一个字符的边搞得快一点，字符只有$\Sigma=26$种，注意到枚举了一个字符之后，可以$O(n^2\Sigma)$地计算这个子矩阵$\min$之类的东西，因为它的一维是啥跟另一维没有关系，只跟这个字符有关。复杂度$O(n^2(n+\Sigma)+nm)$。

Konduktor

dp，设$dp(i,j,k)$表示这次在$i$检票，上次在$j$，总共用了$k$次的答案。

Architekci

感觉感觉。建立子序列自动机，那么需要求一个长$k$的路，贪心地转化成最长路长度是不是足够。那么从后往前扫，用可撤销化数组存转移，对不够长的位置开个BiT，够长的位置直接维护最大的，那么只有在后$k$个位置，以及前面的位置中最多$k$次会操作BiT，所以复杂度就是$O(n+k\log k)$。

或者看看题解，发现合法当且仅当我们第$i$次选了$[b_{i-1}+1,k-i+1]$之间一个数。单调队列维护第一个$\max$即可。

Łyżwy

hall定理。重温一下经典，考虑这个也就是每个人匹配一个长$d$的区间，要求人是否有一个完美匹配，那么也就是求任何一个人的集合是否满足邻接的鞋比人多，也就是求鞋数减去人数的$\min$，称这个是权值。注意到最小的集合必然是一个区间，因为如果我们从小到大排序，相邻两个人邻接的鞋不相交了，那么这就分成了两个集合，其中某一个必然不比另一个小；如果所有相邻两个人邻接的鞋都相交，那么把最左边到最右边的人中间全选上必然不劣。于是现在我们要求一个最小子段和，线段树即可。

Wyspy na trójkątnej sieci

主要问题是怎么编码一个这样的图。感觉上直接用每一步绝对的方向编码就行了(而不是记录你怎么转弯这种东西)。

R3

Wiedźmak

dij。状态数是$2^pn$，大约是1e6。但是需要注意一下边数，是$2^pm$的，大约是2e7。考虑有没有一个简单的$O(1)$ decrease key的做法，感觉一下没有。考虑是否有一个顺序让我们不用decrease key，感觉一下把手中剑的状态相同的分为一层，那么一层内的边需要dij，层间的则不需要。于是我们的堆大小就是$O(m)$，感觉上很可过。

Słowa/Słowa 2

考虑如果是给你了一个串应该咋办，毕竟我通过$k=0,k=1$可以拼出所有串。类似于找到所有$10$和开头的$0$，它们必然由$1$得到。最后一个$1$在上一轮是$0$还是$1$不能确定，但是此外的$1$必然由$0$得到。如果有两个相邻的$0$，那就爆炸了。如果最后只剩一个字符了，那就可行。所以我们会了$O(2^m)$。

感觉一下，状态只有$O(m)$种，因为只有最后一位在变啊。

现在考虑各$k$任意怎么做。每个串内部啥样是确定了的，但是边界上可能有问题。注意到每个串前两个字符必然是$10$，最后一个可能是$1$也可能是$0$，除了$k=0,k=1$的情况。找到所有$k\geq 1$的串，爆力维护$k=0$的。如果一个串最后是$0$，那么需要判断它后面是不是$0$。如果它最后是$1$，后面有一个$0$，那么这个$1$就要被拿出来跟后面合并。那么每个串可能，正常，最后一个位置本来是$1$而变成$0$了，已经消失了，强行维护一下即可。

Tablice

妈的，怎么还元素互不相同的。直接多重集hash。

Wyspa

发现我们希望尽可能贴着$1\rightarrow n$走，然后这条路好像就是所有边的半平面交。看看这个半平面交怎么求啊，发现对每个点只需要找到最低的和它有边的点。

Kod

读错题。

看起来复杂度是$O(L)$，其中$L$是总长。

也就是给一个每个叶子代表一个串的$01$ trie，求有多少个串$a$满足，对于任意可能出现的编码的前缀$s$，$s+a$在trie上不停贪心匹配，到最后恰好匹配完。发现$s$具体是啥是没有用的，只有它最后停在哪个点有用，于是也就是在任何一个 从根出发，走某个编码的后缀，然后走某些编码 可以到达的点，走一个$a$都会到根(叶子和根是同一个点)，那么爆力就是枚举一个起点，dfs地枚举一个串，复杂度$O(n^2)$。我们将 从根出发，走某个编码的后缀 可以到达的点称为关键的，将关键点走某些编码可以到达的点称为有效的。

考虑怎么找到所有关键点。找一个dfa匹配后缀，那么当然可以多串sam。或者考虑有没有什么$O(L)$的做法，考虑枚举一个点，处理它到子树中叶子的所有路径，也就是一边dfs子树一边同时dfs整个trie，这个东西复杂度是子树大小之和，看起来它是$O(L)$，因为子树大小不超过两倍的叶子数，而每个叶子会被算对应的串长次。

接下来找到所有有效点。注意到如果从一个关键点出发，经过根到达了一个有效点，那么这个有效点必然也是关键的，因为从根到它走的是一个串的后缀。所以每个关键点也只需要找到子树内的有效点。一边dfs整个trie一边同时dfs子树，如果离开了子树则剪掉即可。

接下来统计答案。对于所有有效点再类似地dfs，但是这次是如果到不了根则把这个字符标记为不行，如果到了根还没匹配完，则再递归到根，并记忆化一下。总复杂度$O(L)$。

Poszukiwania

可能没太看懂题意，说的大概是如果答案是yes则支付$1$，no则支付$2$?设$dp(i)$表示用$i$块钱可以搞定最长多长的区间。翻译比较奇怪，但是看起来$dp(0)=1,dp(i)=dp(i-1)+dp(i-2)$之类的。交互则记录转移。

#### XVII(2009~2010)

R1

Kolej

每个栈必须是有序的。如果什么时候栈顶是接下来应该放的数，那么直接pop。现在考虑插入一个数，如果它比一边的栈顶小，比另一边大，那么当然插入这一边。如果比两边的都大，那么没救了。如果比两边的都小，这个是主要问题，猜测我们应该push进栈顶更小的那一边。但是这个看起来很假啊，因为有pop的话，我们可能会希望pop一串之后得到一个更大的栈顶，来放接下来比较大的一个数。

考虑一些强行做法。对于一个栈的情况，结论是如果存在$i<j<k$满足$a_k<a_i<a_j$，那么不可行。对于两个栈的情况，这里$a_k$是作为一个 不能进行pop 的限制，于是如果出现这种情况，$i,j$不能在同一个栈中。为了证明这是充要的，类似于一个栈的情况，我们知道在任意pop结束后的时刻，两个栈都是单调递减的，而递减就说明不会有数被卡死。

所以从后往前枚举一个$k$，在前面比$a_k$大的顺序对之间连边，然后二分图染色。于是也就是给若干个矩形的顺序对连了边。转而考虑两个点$i<j$之间何时有边，如果$a_i<a_j$，并且有$k>j,a_k<a_i$，那就有边了。于是找到$a_k<a_i$的最大的$k$，$i$向这个$3$-side矩形连边，主席树优化建图即可。

为了砍空间，考虑直接从下往上扫，扫到一个点的时候，它贡献了一个区间推平，如果两个推平冲突则无解，线段树维护即可。

Gildie

注意到我们不需要没有办事处的点，那么考虑随便找一棵生成树，奇数层分配裁，偶数层分配缝，就赢了。

Test na inteligencję

subsequence am，vector上二分找转移就好了。

Korale

hash。

Najdzielniejszy dzielnik

那么也就是求出现次数最多的素因数的出现次数。看起来并不能全pr一遍，所以我们就只分解三次根号以内的好了，看起来算量是4e7左右，然后开根，mr判一下，剩下的必然是两个素数的乘积。我们枚举每两个算它们的$\gcd$，就可以得到这些素数，然后试除一轮，可能还会剩下两个一起的，mr判一下，直接统计进答案即可，复杂度$O(n^3+nv^{\frac{1}{3}})$。

R2

Antysymetria

由于它是对称的，可以manacher。或者二分hash。

Chomiki

考虑如果现在以$a$结尾，接下来再以$b$结尾需要的长度是确定的，因为保证了串互不包含，这个也就是求最长的$a$的后缀满足它是$b$的前缀，acam即可。然后矩阵快速幂即可。

Klocki

考虑什么时候一个区间合法，发现如果区间和$\geq k\cdot len$必然合法，如果不满足这个那么可能两边还可以救一救，但是发现答案必然没有被两边救，因为救完了之后算上两边就得到更长的区间。拆拆前缀和，大概是$s_i=\sum\limits_{j\leq i}(a_j-k)$，答案要满足$s_r-s_{l-1}\geq 0$，也就是$s_r\geq s_{l-1}$。单调栈即可。

Owce

强行dp，经典的，枚举一条边和这条边连向的点，那么划分出来的每个部分都是一个区间，然后就是三角形数点了。一共有$O(n^3)$个三角形，不过没有关系，使用经典的差分即可。需要排$n$次极角序，复杂度$O(n^3+nm\log m)$。

Teleporty

经典的，大力讨论，最后图有七层$1,S_1,S_2,M,T_2,T_1,2$，答案是所有相邻两层连成完全二分图，每层内部连成完全图。

R3

Monotoniczność/Monotoniczność 2

看起来很带劲。设$dp(i,j)$表示是否存在以$i$结尾长度为$j$的子序列。发现只有$j\bmod{k}$有用，但是此时就需要记多长了，BiT一下，我们会$O(nk\log n)$了。

考虑怎么对每个$j$批量转移所有的$i$。画到平面上，考虑$<$怎么做，也就是每个点推平右上方所有点。感觉比较困难。

考虑怎么对每个$i$批量转移所有的$j$。对于$dp(k<i,j-1)$，如果$j-1,j$之间是个$<$，我们扫到$i$的时候只需要考虑$a_i$最小，且$dp(k,j-1)=1$的那个$k$。于是我们会$n^2$了，但是看起来很不够啊。

考虑有没有什么性质。强行猜测如果存在以$i$结尾长$j$的满足条件的子序列，那么必然存在长$j-1$的，然后啪的一下就做完了。但是遗憾，这个是假的，我只知道要么存在长$j-1$的要么存在长$j-2$的，但是不知道是啥结构。

考虑有没有什么别的性质。感觉比较厉害，强行猜测，虽然可行的$j$不一定连续，我们还是只需要维护最大的那个，设为$f(i)$。从左往右归纳，现在考虑到$i$，假设$j<i$的$f(j)$都是从前面的$f$中最大的那些转移来的，$p(k)$是$k$的最优决策点，设$j=p(i)$。我们尝试构造一个$i$结尾长度$>f(i)$，或长度$=f(i)$而转移到一个已经被归纳的情况的方案。设$p_{f(j)}=j,p_{f(j)-k}=p(p_{f(j)-k+1})$为$f(j)$对应的方案。

 - 如果$a_j=a_i$，在$f(j)$的方案中把最后的$j$换成$i$，得到的长度$\geq f(j)\geq f(i)$，而$f(j)$是从前面某个$f$转移来的。

 - 不妨设$a_j<a_i$，那么也就是说$f(i)-1,f(i)$之间的限制是$<$。还是考虑拿$j$凑个方案。

   - 若$a_{p_{f(i)-1}}<a_i$，还是可以在$f(j)$的方案中把最后的$j$换成$i$。

   - 否则$a_{p_{f(i)-1}}\geq a_i$，而$a_j<a_i$，于是$f(i)-1$到$f(j)$之间必然有一个限制是$>$，把$>$后面的位置换成$i$。

于是我们证明了，对于每个不从前面最长的状态转移得到的方案，都有一个从前面最长的状态转移得到的方案不比它劣。BiT维护一下即可。

Gra w minima

猜测每次被选的必然是一个前缀，前缀和优化dp。

为什么必然是前缀?考虑如果你选了一个前缀挖掉一些，那么对手下一步带上这些挖掉的地方不会更劣。

Latarnia

计算几何/jy，矩形反射得到矩形，所以大力模拟。但是好像会出来指数个矩形啊/yiw

Żabka

批量二分双指针求出转移到哪，然后倍增。

Jedynki

考虑直接算最左边的$1$后面是$0$的方案数，对应的最右边，然后减去只有一个$1$的。

首先描述如何计算两个这种表示的数的加减法，也就是讨论相加的两段分别是什么，以及前面有没有进位。看起来跟正常的加法是一致的。和的段数不超过段数的和。

然后开始计算这些方案数。简单地，只有一个$1$的方案数就是$n$的长度。

枚举最左边的$1$的位置，不管顶不顶上界，下一位有恰好一种方案，然后如果$n$开头是$10$，那么一开始会顶上界，方案数是$n$的后这些位，否则每一位都自由了，方案数是若干个$2$的幂，也就是一堆$1$加起来得到一串$1$。

右边看起来要困难一点，枚举最右边$1$的位置，左边是若干个$n$的前缀加起来。不过没有关系，考虑每个位置的贡献，发现第$i$位是$\sum\limits_{k=0}^i 2^k=2^{i+1}-1$，当然如果是$0$则没有贡献，所以也就是整个数乘$2$再减去$1$的个数。模拟即可。

Mosty

二分答案，然后有的边两个方向都能走，考虑用网络流给边定向。只考虑已经确定方向的边，每个点有一个入度和出度的差，把这个差搞成$0$就胜利了，同时我们知道度数，所以一个点应该有几条未定向的边指向它是确定的，匹配一下即可。复杂度$O(m\sqrt{m}\log n)$。

Piloci

首先可以枚举左端点二分。左端点从左往右，右端点也从左往右，所以可以两个单调队列。

#### XVIII(2010~2011)

R1

Lizak

容易想到法，但是这里必要不大。考虑枚举区间长度$k$，然后把所有数都减去$1$，问题是有没有一个长$k$的区间有给定个$0$，那么发现每次加入一个$0$删除一个$0$，$1$的个数是连续变化的，所以求出最小值和最大值即可。

想了想你发现最小值和最大值好像也不是那么好求。那么也就根本不要这么做，设$s_i$表示$i$位置的后缀和，找到第一个$1$，设它在$p$，那么所有以$p$或$p+1$为左端点的区间拼成了$[1,s_i]$，那么完全在$p$右边的区间都已经没有用了。同理找到最后一个$1$。现在还剩下端点在第一个$1$左边，最后一个$1$右边的部分，它们是这两个$1$之间的和，加上若干个$2$。

Piorunochron

classic。在洛谷上你可能需要搜这个题的英文名 lightning conductor。

Przekładanka

也就是有两个环。这个题在arc出现过，看起来任意置换都可以换出来。但是想了想你发现逆序对数不对的不行。

感觉一下，注意到前三个就是某种窗口，a操作的作用是移动这个窗口，于是冒泡即可。但是有操作数限制，再感觉一下大概是不会爆的。

需要特判$n\leq 3$。

Konspiracja

注意是划分。那么如果两个人之间有一条边，他们就不能都在第一组，如果没有边则不能都在第二组，这个是充要的。考虑2-sat。结束了。

但是2-sat怎么计数啊?感觉很困难。考虑有没有啥性质。

考虑设第一组的大小是$k$，那么它合法，当且仅当第一组中所有点的度数之和是$m+\binom{k}{2}$。然后发现度数之和总是不可能比这个大，所以我们只需要考虑度数最大的$k$个点，如果可行，考虑其中度数最小的那些，尝试把它们换成一些度数相等的，组合数选一选即可。

Wykres

二分答案，然后向右贪心，但是随机增量需要你的顺序是随机的，所以我们先倍增地找到这一段大概的长度，然后在里面二分，复杂度$O(n\log^2 n)$。

R2

Sejf

考虑对于最小的生成元$g$，整个群都是它的倍数，这里没有发生取膜。考虑我们可以辗转相减，所以如果有$a,b$则必然有$\gcd(a,b)$，那么最小的生成元必然整除剩下的所有数，否则取一个$\gcd$就得到更小的。

所以枚举这个最小的生成元$g$，它必然是$m_k$的因数，然后判断$m_1,...,m_{k-1}$中是否存在一个数是$g$的倍数，然后还需要它有可能是最小的生成元，看起来这个只需要当且仅当它也是$n$的因数，所以枚举$\gcd(n,m_k)$的因数即可。1e14以内最大的$d$在2e4左右，看起来不太行啊。

把每个素因数分开考虑，那么$m_1,...,m_{k-1}$每个数的作用相当于把各维都$\leq$某些数的位置给ban掉了。于是我们打个标记并做前缀和，这个前缀和是每一维前缀和的卡笛尔积，复杂度是$O((k\log\log v+d(v))\omega(v)+\sqrt{v})$。

另一个做法是把$\gcd(m_i,\gcd(m_k,n))$相同的数只留一个，据说得到的状态数会很少，经典的，$n$以内$k$-smooth数的个数，在$k$很小的时候近似为$\frac{1}{\pi(k)}\prod\limits_{p\leq k}\frac{\log n}{\log p}$，但是

Różnica

这个 出现过的 听起来就很困难。

注意到是极差，我们可以放成任意两个的差，然后你就会了$O(n\Sigma^2)$，也就是枚举最小的和最大的，赋成$\pm 1$求最大子段和，这里初值需要找到上一个字符的上一次出现，或者你可以拆前缀和。显然只需要在我们枚举的字符里面做，所以复杂度是$O(n\Sigma)$的。

Śmieci

也就是指定了每条边经过奇数次还是偶数次。我们可以且只能自由地给一个环的经过次数$+1$，要得到一个每个点度数都是偶数的，那么容易想到线性基，如果给的这些经过奇数次的边组成的向量在图的环空间中，那么就可以搞出来。所以跑一个dfs树找到所有非树边确定的环也就是基本环，它们组成一个环空间的基，我们可以把这些非树边换到前面来变成一个单位矩阵拼上一些可能是任何东西的树边的部分，所以也就是说我们把非树边搞对就赢了。然后差分一下找到每条边最后应该经过多少次，跑欧拉回路分解即可。使用四毛子lca，复杂度是线性的。

又看了看发现完全不对啊，给一个环的经过次数$+1$其实没有改变度数的奇偶性，也就是说我们保留所有经过奇数次的边直接跑欧拉回路即可。太智障了。

Rotacje na drzewie

注意到一个点换或者不换的贡献，跟子树中做了啥操作是没关系的，所以我们只是要求出换或者不换的贡献。这个是经典线段树合并，这里我们放了一个数的时候需要求它在另一棵树上的前缀和，带着这个前缀和递归下去即可，递归到只剩一边的时候就乘上子树中数的个数贡献进答案。

Temperatura

不太习惯poi说明部分分，我还以为整个题都$v\leq 50$。不过关系不大，dp，设$dp(i,j)$表示结尾于$i$，$i$的温度是$j$的答案，转移枚举上一个的温度，也就是推平为前缀$\max$，然后全局$+1$，并把比$l$小的和比$r$大的扔了。

那么你发现它总是单调的，这个推平其实啥用没有，所以用一个双端队列维护这些段就行了。

R3

Dynamit

二分然后自底向上贪心，如果子树中有一个点距离为$k$的点还没被覆盖，那就在这个点上放一个。注意到未被覆盖的点中只有最远的有用。

然后需要考虑如果一个点有多棵子树，一棵子树放了的东西如何影响另一棵，我们只需要维护最近的放了的点。然后找到所有放了的东西里面最近的那个，看它能不能推掉所有没覆盖的里面最远的，如果不能就要在这个点放一个了。

另一个等价的做法是，按深度从大到小扫，每次找到一个还未覆盖的点，就在上面放一个，并标记所有被它新覆盖的点，每条边只会来回贡献两次，所以每轮复杂度是线性的。

Impreza

考虑如果两个点之间没有边，那么其中至少一个必然不在团中，注意到$\frac{2}{3}-\frac{1}{3}=\frac{1}{3}$，于是我们每次找到一对没有边的点删掉，剩下的就是答案。

Inspekcja

感受一下，只有所有子树大小都不超过$\frac{n}{2}$才行，也就是说最多只有两个点行。

Okresowość

考虑转成border，那么所有border的信息都被最长真border包括了，所以求出最长真border递归下去即可。但是如果最长真border长度不超过一半，那么中间会空一些，直接猜测判断如果目前是全$0$，则在最右边填一个$1$，否则填全$0$。为了证明这东西的正确性，画一画你发现如果填全$0$不行，根据定义当且仅当全$0$产生了新的周期，考虑一下，如果有一个周期长度不超过中间这一段，那么整个串都是$0$，此时在中间那一段最右边填一个$1$，剩下的还是$0$必然是可行的。

否则，先弱周期引理一下，设我们想要的那个最长真border的长度是$k$，那么它对应的周期长度是$n-k$，新产生的周期中最短的那个长度是$t$，那么$\gcd(n-k,t)$也是周期，如果它不比$n-2k$小那就没救了，然后你发现$\gcd(n-k,t)$

所以两边都是全$0$，。感觉挺对啊。

Meteory

过于经典。

Patyczki

考虑如果我们确定了两个短边，则只要找到某个区间中的三个出现过的颜色，使用st表，复杂度$O(n^2)$。

考虑怎么只带一个$n$，我们枚举最长边，设它的长度是$k$，以及另两条边的颜色，设它们的长度(还未确定)是$x,y$，那么要满足$x+y\geq k,x-y\leq k,y-x\leq k$。于是相当于问两个集合的笛卡尔积中，一个斜着的3-side矩形中是否有点。

画一画你发现这个查询看起来其实比较简单，它是查了一个有宽度的后缀，那么我们还是只需要一个斜着的单调栈，这部分排序双指针即可，总复杂度$O(nk^2)$。

优化也是简单的，我们只枚举一条边的颜色，然后维护另一条边的两个特例即可。复杂度$O(nk)$。

Konkurs programistyczny


