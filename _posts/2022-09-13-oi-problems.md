---
layout: post
title: oi题选做
subtitle: 麻麻麻
tags: 题选做
---

从这一篇开始我要使用两个\$作为latex的标识符。

## Polish OI

poi大概是，有三轮，r1五题，r2 r3都是有D0 D1 D2，D0一题，D1 D2两题。

#### VIII(2000~2001)

R1

A. Liczby antypierwsze

tooooooooooooooo classic。

B. Mapa gęstości

前缀和。

C. Przedziały

模拟。

D. Gra w zielone

幸运的，这个题在谷上有。

请注意是在环上的部分要走过一个绿点，而不是整个/jy

发现如果一个A的点的后继有让A赢的，它就也是赢的，否则它是输的。如果一个B的点后继全是让A赢的，那么它也是赢的，否则它是输的。但是只知道这些不管用，我们可以让所有点都赢，也可以让所有点都不赢。

考虑如果不在环上的绿点也算数的话，那么我们只要一开始让所有绿点赢，然后按上面递推就好了。注意到如果从一个绿点出发必然可以到达自己，那么它必然是赢的，否则这个绿点是无用的。发现我们从有用的绿点出发递推就可以得到正确答案，所以问题是求出哪些绿点是有用的。

做法是，我们先把所有绿点置为有用的，然后有用的绿点必然是赢的，递推出哪些点是赢的，如果一个有用的绿点其实是输的，那么就把它置为无用的。于是每轮减少至少一个绿点，复杂度$O(cm)$。

为了证明这个奇怪东西的正确性，考虑最后每个输的点显然真的不能赢，而每个赢的点确实可以走到一个环上，而由于是从一些绿点开始递推，环上确实必然有一个绿点。

R2

D0

Gorszy Goldbach

找到一些大素数快速减少数的大小。打表即可。

D1

Spokojna komisja

2-sat。

Wyspa

没太看懂题意。应该模拟就行了吧/oh

D2

Mrówki i biedronka

没太看懂题意。应该模拟就行了吧/oh

Podróż

题意不是很懂，看起来是什么大力建图dij?

R3

D0

Wędrowni treserzy pcheł

判定基环树森林同构，考虑基环树，每个子树树hash之后相当于判定两个序列是否循环同构，跑个最小表示然后hash即可。

D1

Porównywanie naszyjników

考虑那个简单的最小表示都需要啥。发现我们需要求lcp，然后需要保证可能作为最小表示开头的位置数量很少。注意到一段只有第一次循环和最后一次循环中的位置可能成为最小表示的开头，所以后者已经结束了，而前者，考虑倍增hash，结束了。

Zwiedzanie miasta

智障了。随便跑一个欧拉回路，然后找到前缀和最小的点，从它出发就得到一个全正的。和raney引理有点像。

D2

Bank

如果只有一种货币，注意到每个人都不会让你的资金量变小，所以我们会每次选择加最少初始资金就能选的。

但是现在有四种货币，感觉上贪心好像真的可以得到一个极优解，我们只需要先让第一种最小，如果有很多个可以选的，让第二种最小，这样的。

Kopalnia złota

枚举一个横坐标，线段树维护纵坐标，那么一个点在一个横坐标区间贡献一个纵坐标区间。

Łańcuch

直接dp。考虑我们首先要让$n-1$是1，剩下的都是0，所以设$dp(i)$表示变成$i$是1前面都是0的步数，为了这么做发现我们只有送一个1上去才能把最低的1拿掉，所以看起来策略就是每次把当前末尾极长我们想要的段(一些0之后一个1)往上扩展一个1，然后把下面那个1扔了，直到够到$n$这样的。

#### IX(2001~2002)

R1

Superskoczek

我们尝试让马分别往上走一步，往下走一步，往左走一步，往右走一步。注意到必然存在一种方案使得马的坐标绝对值保持在$101$以内。搜即可。

或者使用格的线性基，称为hermite标准化的算法。std做法本质就是这个。

Komiwojażer Bajtazar

模拟。

Wyspa

转一圈双指针即可。

Zamek

直接dp。

Koleje

noip2012 借教室。noip出poi原题/jy

线段树模拟一下。

R2

Izolator

这是一个匹配问题。考虑每个数可能贡献正的它，负的它或者不贡献，不贡献显然没劲，然后我们希望让最大的若干个数贡献正的，最小的贡献负的，所以构造一下发现可以最大的$\lfloor\frac{n}{2}\rfloor$个数贡献正的，最小的$\lfloor\frac{n}{2}\rfloor$个数贡献负的。

Działka

模板 最大子矩形。

Wyliczanka

excrt。

Kurort narciarski

还是直接dp。

Protokoły

不是很能看懂题意。不过肯定可以直接dp吧。

R3

Minusy

这个问题好像很经典，似乎在arc出现过。对于每一段连续的加号，我们在两边放一对括号。arc搬poi/jy

Narciarze

这个看起来不是最小路径覆盖啊，也不是最小割。但是上下界最小流就好了!

Waga

背包。

Liczby B-gładkie

数论题/jy

min_25/洲阁筛的第二部分。

Nawiasy

直接dp。

Szyfr

模板 knapsack。折半。

#### X(2002~2003)

R1

Ciągi bez zająknięć

考虑有没有一个$\log$个的构造。发现可以把原序列复制一份，在中间加入一个没有出现过的字符。

交一发wa了。考虑有没有一个$O(1)$的构造。发现两个字母肯定不行，但是搜一搜或者手动构造，发现三个字母可以构造出$n=8$，一个做法是$abcbabca$。结论是thue-morse序列的差分是square free的。

或者可以大力随。注意到长度超过某个足够大的$k$的square几乎不可能出现，而它们有$n^2$个，那么取$k=120$看起来足够，如果往后加入一个字符后，出现了长度$\leq k$的square，则删掉它。我们只需要维护$k$个前缀和即可。为了证明这个东西的复杂度，请见 https://www.sciencedirect.com/science/article/pii/S0304397515006489。

为了写checker，看起来需要使用lyndon array那一套。

Liczby Przesmyków

数位dp。

Czekolada

也就是如果选一个x的时候，前面有$k$个y被选了，那么它带一个$k+1$的系数。dp即可。

Przemytnicy

dij。

Płytki drukowane

大力dp，直接存两端的状态。

R2

Mastermind II

模拟。

Autostrady

2-sat。hnoi搬poi/jy

Trójmian

读错了三遍题。

弱于 zjoi2017 多项式。

Kafelki

根据周期引理，如果$k+l-\gcd(k,l)\leq n$，那么$\gcd(k,l)$也是周期，并且显然不需要存在比它更小的周期，所以答案是$\gcd(k,l)$。如果$k+l-\gcd(k,l)>n$，那么$\max(k,l)>\frac{n}{2}$，不妨设$k>l$，那么我们知道如果没有$k$，$l$导致了$l$个等价类，而$k$的作用是合并了其中$n-k$对，所以答案是$l-(n-k)$。

Połączenia

考虑k短路说了啥，我们跑一个floyd，从每个点出发建最短路树，然后真的跑k短路。这里我们可以$O(nk)$跑一次，方法是不合并堆而直接爆力向上找。

R3

Gra w dzielniki

如果这个数是一个素数，那么我们就需要遍历所有的素数。所以按任意顺序问所有的素数，问中了就除一下再问剩下的就好了。

Skarb

主要问题是两个人能不能相遇。我们分别找到环，进入环之前模拟一下，进入环之后只需要算个$\gcd$。

Sumy

考虑同余最短路，我们从$0$出发bfs，但是直接做是$O(na)$的，所以bitset维护一下就$O(\frac{a^2}{w})$了。

Kryształ

完全没懂它在说啥。

Małpki

终于有2e5题了。直接拓扑排序。

Tasowanie

把环求出来，然后直接算这个置换就好了。

#### XI(2003~2004)

R1

PIN-kod

没看懂。

Zawody

模板 有向图最小环。跑两个bfs。

然后发现可能不太对啊!不过我们枚举第一条边走的是哪条边就好了。

Gra

跳棋/jy

读错题/jy

很容易想起sdoi2019 金币游戏，所以我们尝试转成staircase nim。发现两个空格之间就是一个staircase，然后就结束了。

Szpiedzy

也就是有一个内向基环树森林，那么我们在环上枚举任意一个点选还是不选把环断开，在树上直接dp即可。

Sznurki

原来string真的是弦而不是串串。

数量可以直接dp，把子树传上来的接起来即可。长度的话当然二分，然后就是接的时候最长的接最短的，次长的接次短的，这样的。长剖之后计排，复杂度$O(n\log n)$。

R2

Most

好像很经典，但是我好像没见过。

考虑样例，容易想到我们可能让两个很慢的老哥一起过，此时对面需要有一个快的老哥等着回来。也就是说，我们可以

 - 让最快的人带一个人过去

 - 让最快的人和第二快的人过去，最快的人回来，两个人过去，第二快的人回来

一定是一个后缀被第二种带过去，枚举即可。

Bramki

问题是可能有环，有趣的是如果有环的话输出可能仍然是确定的，这个题意大概是对于一开始的状态，按任意顺序调整，直到。类似 viii poi Gra w zielone 的做法，我们全赋成$1$调整一遍，全赋成$0$调整一遍，如果一个门两遍得到的相同，那么它是确定的，否则它是不确定的。

Jaskinia

也就是求一个深度最小的点分治。

看起来很困难。考虑点分治本质是什么，发现它是给每个点分配了一个深度，然后我们找到深度最小的点划分下去，如果这个点唯一那么就可以建立一个分治结构，而唯一当且仅当两个深度相同的点不会出现在同一个分治块，也就是它们之间的路径上有一个深度更小的点已经把它们分开了。

考虑自底向上做，维护哪些深度有一个点满足上面还没有一个深度更小的点，这里深度是$\log$级别的。然后合并子树的时候如果有相同的，那么这个点的深度必须比它们小，分配尽可能大的深度即可。这么做是不劣的，因为大的深度可以由大的深度来解决，小的深度则需要小的深度，这玩意感觉上有点类似树上的某种进位，但是不是很理解啊。

考虑用一个简单的东西描述一个过程，这种做法可能叫compress?感觉它可以帮助你换扫描线方向，比如点分的方向是在点分树上扫，但是我们描述了点分树之后，就可以直接在原树上扫。但是也许除了点分治以外没有哪个题可以这么做了。

Przeprawa

又见面了。然而好像没有，这个直接爆力即可。

Turniej

考虑一个波特什么时候能赢，我们认为一条边从赢指向输，那么如果把没有边都当成双向边，从它出发可以到达每个波特，它就赢了，构造方法是在生成树上自底向上进行比赛。但是这个好像不是很行。

注意到如果有超过一个波特能赢，那么一个波特能赢，当且仅当它可以打败一个能赢的波特，因为它必须打败所有波特，而打败了一个能赢的波特的话，只需要先让这个波特打败别的所有波特即可。所以我们找到一个能赢的波特，然后找到所有可以打败它的波特，就得到了答案。

考虑凑一些限制，如果波特$u$必然不能打败$v$，那么说明$v$必然打败$u$和所有$u$可能可以打败的波特，那么$v$的出度必然严格比$u$大，所以我们知道出度最大的波特必然可能赢任何波特。

接下来找到所有能赢的波特，我们知道如果不是所有能赢的波特都到某个波特有边，那么这个波特也能赢。一开始把出度最大的波特标记为能赢的，每次取出一个能赢的波特，维护一个还没能赢的波特的列表，找到所有它不必然打败的波特，标记为能赢的。注意到每次一个还没能赢的波特没有被标记为能赢的，都要求新处理的能赢的波特到它有边，所以复杂度是线性。

R3

Zgadywanka

为了得到满分，你需要赢三场。

我们直接找到概率最大的。如果这个数是$x$，还有$t$个数没出现，其中有$k$个$<x$的概率就是$x^k(1-x)^{t-k}$。

Wschód-Zachód

注意到主要问题是要到达中间那个狭窄的地方。直接在东侧模拟即可。

Wyspy

怎么还计算几何的。

为了把树建出来，经典做法是从边上往外画一条射线，考虑撞到的第一个多边形，它要么是父亲要么是兄弟。为了避免成环，每个多边形从最右的点往右画射线即可。为了画这个射线，使用线段树维护。

Kaglony

对于第一种，我们可以把每个连通块分开。对于第二种，在补图上把每个连通块分开。

但是怎么算补图的连通块啊?简单想法是bitset，复杂想法是别乳卡。更简单的想法是，我们每次加入一个点，然后枚举它的邻边，如果一个连通块中不是每个点都和它有邻边，那么发生了一次合并，这个可以维护没有边的连通块的列表做到线性。注意到每两轮必然分别是两种情况，所以边数会减少至少$n$，并且进行$n$轮必然结束，所以轮数是$O(\min(n,\frac{m}{n}))$的，当然一般来说很松。复杂度$O(m\sqrt{m})$。

Maksymalne rzędy permutacji

周期是所有环的周期的$\operatorname{lcm}$。为了最大化这个，我们必然选择一些不同素数的幂，然后从小到大排列它们，对得到的每一个区间转一下。现在问题是最大化$\operatorname{lcm}$，dp值我们猜测取个$\ln$就赢麻了，所以要用若干个素数幂做背包。为了卡常，注意到很大的素数不会用到，扔了就赢了。

Misie-Patysie

相当于平面上有一个棋子，你可以往左，往下，往左下移动。

不知道干什么的时候你就打个表，发现先手必败的状态$0$很少，只看$x\geq y$的部分，那么可以这么走出来 : 每一步可能是$x+=2,y+=1$或者$x+=3,y+=2$，记前者为$1$后者为$2$，则$0$的位置可以通过一个序列生成，序列的构造方式是一开始有一个$1$，接下来每次把$1$替换成$12122$，$2$替换成$12122122$。我们需要每次移动到一个$0$上，那么生成所有的$0$，然后找到一个即可。直接生成会得到长2e7的串，其实挺可以接受，但是你也可以预处理每一轮保留多长做到恰好够用。

#### XII(2004~2005)

R1

Bankomat

一个密码可能出现，当且仅当去掉相邻的重复元素之后，它是所有移动序列的子序列。对每个串建子序列自动机，然后枚举每个密码上去跑，复杂度$O(10^lnl+\sum \vert t\vert)$，其中$l$当然是密码长度。

Punkty

经典问题是判断两个多边形是否相似，做法是转一圈求相邻边的点积和叉积，然后跑一个最小表示判断是否相等，如果允许对称则翻转之后再跑一遍。

现在问题是我们没法唯一地连成一个多边形。考虑求出凸包，剥掉凸包，求出凸包，剥掉凸包，如此直到所有点都被剥掉，然后依次比较每个凸包，每个凸包会确定一圈可能的变换，然后我们需要对这些东西求一个交，看起来很复杂啊。

考虑有没有一个简单想法。我们首先确定平移量，发现找到重心，然后把重心平移到重合即可。然后考虑放缩，可以选择距离重心最远的点，把这两个距离放缩到相等。然后考虑旋转，我们从重心出发记录相邻两个点的点积和叉积，然后跑最小表示。

Samochodziki

这个是 模板 离线寄存器调度问题。做法是贪心把下一次选择时间最远的放回去。

Skarbonki

当然是内向基环树，我们打开环就赢了，为此需要打碎每个环上一个点。

Skoczki

又见面了/jy

R2

Lot na Marsa

又见面了/jy

然而这个没那么原，因为它让你求出所有解啊。问题是查询区间最小前缀和，这里单调队列即可。

Banknoty

已经不会背包了。单调队列。

Sumy Fibonacciego

加起来爆力模拟进位。

Kości

也就是给图定向，使得出度的最大值最小。二分答案，然后考虑网络流，直接建就行了，复杂度$O(m\sqrt{m}\log n)$。

Szablon

好像前两天汪娟给我看这个题来着。考虑答案必然是一个前缀，当然也必然是一个后缀。我们枚举一个前缀，考虑所有它的出现位置，如果这些出现覆盖了整个串那么就可行，这可以z algo求出来。所以我们只关心相隔最远的两次出现。从短到长枚举前缀，那么出现的集合会逐渐缩小，用链表维护所有的出现即可。

R3

Dziuple

也就是求二分图的平面嵌入数。考虑连通怎么做，注意到如果左部最下面那个点是$u$，那么$u$的邻接点只能有最多一个还有别的出边，否则就会相交。设这一个点是$v$，那么$v$的邻接点只能有最多一个还有别的出边。所以图必然是一个毛毛虫，我们把主链两端的叶子数$+1$再乘起来，剩下的叶子可以随便排列，还要考虑翻转链和放在哪一边，再乘一个$4$得到答案。注意单点需要特殊处理。

考虑不连通怎么做，不是单点的连通块之间排一排，单点则可以插在任意位置。

Akcja komandosów

没太看懂。据说是求最小的前缀使得这些圆没有交。

考虑了随机增量，好像不太行。

考虑我们找到交中最右的点和最左的点，考虑前者，发现这个点必然是由一个圆中最右的点或者两个圆的交中最右的点贡献，继续发现它必然是所有两个圆交中最右的点中最左的。所以爆力枚举即可，复杂度$O(n^2)$。

Dwa przyjęcia

猜测答案必然是$n$。归纳，如果所有点都是偶度点就赢了，否则删掉一个奇度点$u$，得到一个方案，那么$u$必然到其中一边有偶数条边，另一边是奇数。不管加入到哪一边，$u$加进去之后，邻接点的度数就都变成奇数了，于是我们考虑能不能通过加一些边再递归下去，然后把这些边删掉换成$u$和它们之间的边。把邻接点之间的边全部取反然后递归，此时删掉这些边，那么到$u$有偶数条边的部分，$u$的邻接点度数都是奇数，此时加入$u$就赢了。

译自 Combinatorial Problems and Exercises by László Lovász。

Dwuszereg

容易想到抽象成xor方程组，这里问题是什么有若干个$x_i\operatorname{xor}x_j=0/1$，当然把它看成边，注意到每个点度数不超过$2$，所以是若干个环和链，模拟即可。

Autobus

usaco好像也搬过这个。扫描线BiT或者分治一下。

Lustrzana pułapka

首先注意到我们只关心是否回到了原点，所以可以把反射改成取模，也就是从一个边界出去则从另一个边界回来，这相当于撞了一个边界就进行一次对称。这个看起来性质要好一些。接下来自然考虑把它无限延伸变成一条完整的射线，而原点被复制无限份，不过这个好像没太有必要。

设射到了$(a,b,c)$，那么我们称这是一步，则会在$\frac{\operatorname{lcm}(2x,a)\operatorname{lcm}(2y,b)\operatorname{lcm}(2z,c)}{abc}$步之后撞到原点。所以我们得到答案是$(a+b+c)\frac{\operatorname{lcm}(2x,a)\operatorname{lcm}(2y,b)\operatorname{lcm}(2z,c)}{abc}$。

但是还有一个小问题，就是这里射线不能碰到棱，所以还需要算一下。注意到我们要么永远不会撞到棱，要么在第一次撞到原点之前就会撞到棱。考虑前两维，如果存在$\frac{a}{b}=\frac{(2i+1)x}{(2j+1)y}$，也就是$2(jay-ibx)=bx-ay$，那么就会撞到棱。exgcd一下，我们知道这等价于$\gcd(ay,bx)\mid\frac{ay-bx}{2}$。注意到这个式子成立当且仅当$ay-bx=k\gcd(ay,bx)$中的$k$是偶数，那么$\frac{ay}{\gcd(ay,bx)},\frac{bx}{\gcd(ay,bx)}$不可能都是偶数，所以它们必然都是奇数，所以也就是$ay,bx$中$2$的幂次相同。

现在可以一个$\log$算一个点的答案了。考虑什么样的点可能有贡献，注意到如果$a,b,c$都选的很大，并且分别和$2x,2y,2z$互素，显然是很优的。如果$a,b,c$都很小，那么好像就比较的拉。选择$a=x-1,b=y-1,c=z-1$，答案至少是$(x+y+z-3)\frac{xyz}{8}$，如果想要进一步改善，$a,b,c$中有至少一个要和$x,y,z$对应互素。考虑$x$以内最大的和$2x$互素的数，发现它要么是$x-1$要么是$x-2$。但是很遗憾，这里还有一个限制，不过我们预处理一下哪些互素，然后分别往下枚举一些检查那个不能碰到棱就好了。看了一眼，三个分别往下枚举$12$个就过了。

Prawoskrętny wielbłąd

注意要回家的。

画一画观察一下，猜测一条路径合法，当且仅当每个角都合法，并且边的方向没有跨过$1\rightarrow 2$的方向，或者说只能转一圈。正确性还是比较显然的。

那么从$1$出发，把$2$作为$0$排一个极角序。现在开始dp。设$dp(i,j)$表示当前刚走了$i\rightarrow j$的答案，那么转移可以转移到$0\rightarrow j$和$i\rightarrow j$两个半平面bound住的一个部分。注意到固定$j$，则可以转移到的部分是$0\rightarrow j$右侧，$j$出发顺时针排极角序得到的一个后缀，所以对每个$j$开一个前缀和优化即可。复杂度$O(n^2\log n)$，瓶颈是排序。

#### XIII(2005~2006)

R1

Okresy słów

border和周期一一对应，这里好像就是要找一个最短border，那就真的把所有border跑出来就好了。但是应该没有这么复杂啊?

考虑我们类似于kmp，设$f_i$是前缀$i$的最短border长度，先爆力向$f_{i-1}$中插入$i$，然后最短border的信息就都包含在前缀$f_i$中了，跳$f_{f_i}$就得到答案。复杂度$O(n)$。

Krążki

模拟。

Żaby

请注意这里是平面，距离是欧几里得距离。

最小瓶颈树是线性的，主要问题是要求到每个点最近的关键点。把式子写出来，发现它是一个二维的东西，看起来我们需要把它化成一维的。

试了一下发现好像不能类似 货币兑换 一样做，那么就是不能直接化成凸壳了。考虑怎么让它简单一点，注意到两维是独立的(你不会没有把根号扔掉吧?)，所以先对每个点求出同一行的点中最近的，然后这个就变成了一个常数，再对每个点求同一列中最近的即可。总复杂度线性。

Tetris 3D

发现是矩形max矩形推平，然后这里max是单增的。满点集，四分树，复杂度$O(d^3)$，是不是就过了啊!

注意到并不是满点集，最大值必然在某个立方体的角上取得，所以只把这些点拿出来建2-dt，复杂度是$O(n\sqrt{n})$的。

由于max是单增的，也可以树套树俩$\log$。

Profesor Szu

没有环的话就dag dp。有环的话，只要可以走到环就是答案，所以从环出发倒着dfs即可。有向图找环，使用kosaraju或者tarjan scc。

R2

Magazyn

当然切比雪夫转曼哈顿，然后就中位数了。转回来之后不一定是整数。

Szkoły

容易想到费用流，但是直接建的话边数是$n^2$的。哦network simplex是不是就过了啊?事实是，所有东西都过了。

由于$k$都不一样，看起来很难优化建图。

Metro

这里是允许交的。注意到我们每次必然是从已经选了的部分出发往边上扩展两条链，因为如果和已经选的部分不交，换一下就交了并且必然不劣。从一个直径端点出发长剖，选前$2l-1$长链。

Najazd

凸包上的差分，我们设$s(i,j)$表示从$i$顺时针转到$j$的区域中所有点的权值和。

Listonosz

我们把规定的一串边直接从起点连到终点。但是问题是，可能出现两个序列包含同一条边，所以需要先建一个空图把这些序列加进去，然后在上面dfs得到所有极长的序列，然后拿这些去跑。

Orka

考虑最后我们肯定会把一维全部删完，另一维则可以留一些不删。区间dp，设$dp_1(i,j)$表示第一维删到$[i,j]$，尽量删第二维，可以删到哪里。转移就往里删一步。

R3

Tańce w kółkach

感觉小膜数很有用，所以先搞个式子。发现它就是$n![z^n](\sum\limits_{i=l}^\infty\frac{z^i}{i})^k$，那么猜测$n$很大的话直接全膜成$0$了，想了想发现是真的，因为$p$出现至少$\lfloor\frac{n}{p}\rfloor$次，那么注意到$5^\frac{n}{5}401^\frac{n}{401}$增长的显然比$n$快多了，所以比如$n\leq 1000$爆力卷，更大的直接输出$0$即可。

Estetyczny tekst

dp，设$dp(i,j)$表示最后一段选了$[i,j]$的答案，转移考虑上一段，发现就是某个长度以内的绝对值是一边，以上的是另一边，那么我们双指针扫这个分界点，前缀和优化即可。

Kryształy

容易想到从高到低数位dp。注意到如果一个数不顶上界了，它就完全自由了，剩下的数不管怎么选，它都有唯一的方式把剩下的数调整成正确的。所以我们考虑在最先不顶上界的数处统计一个方案，如果有多个那就取编号最小的。

Misie

大力dp。

Palindromy

题意好像是，给若干个回文串，求其中有多少对接起来还是回文串。

枚举长的，那么短的需要是它的前缀，插个trie即可。

Zosia

发现这个有向边其实是无向边，所以就是求一个最大独立集。注意到一个连通图的最大独立集不超过点数的一半上取整，所以只有$O(k)$个点在非平凡连通块中，套用$1.1996^n$的最大独立集，复杂度在有且只有一个非平凡连通块，大小为$2k+1$时最劣，所以是$O(1.1996^{2k})$。

遗憾，这个题直接随一个顺序贪心就过了。

#### XIV(2006~2007)

R1

Drzewa

考虑我们直接枚举换完之后的四个符号，得到四维偏序，然后仨$\log$排序分治分治BiT即可。需要特殊处理相邻的。

注意到我们要换的位置左右哪个大哪个小是没有关系的，所以就只剩下两维了，也就是对于$i$有$a_i<\min(a_{j-1},a_{j+1}),\min\leq a_i<\max,\max\leq a_i$，对$j$同理。

Biura

也就是在补图求连通块个数，怎么感觉已经出过这个了。考虑枚举一个点，如果它到前面某个点有边则标记不合并，然后把剩下的都合并了，复杂度线性。

Zapytania

经典。莫反。

Osie symetrii

所有的对称轴必然过重心，所以先找到重心，然后维护哈希值和中心对称之后的哈希值即可。

Atrakcje turystyczne

从每个关键点出发dij，然后状压dp。

R2

Grzbiety i doliny

模拟。

Powódź

注意到每个最低的点组成的连通块显然需要放一个，所以从小到大放，模拟一下它排空了哪些点，复杂度线性。

Skalniak

考虑了很多强行做法，但是不好优化。考虑如果一个方案中$x=y$两侧都有点，那么全都翻到$x=y$的一侧必然不会让周长变长，画一画你就发现这些边全都对应起来了。

于是考虑如何最小化重量和。我们可能会把一些东西翻回去，要想不让周长变长，只能是做刚才那样的翻折的逆，所以画一画一共有四种可能的答案。赢了。

Megalopolis

差分，问题变成子树加单点查询。

Tetris Attack

考虑直接从左往右扫，维护还未匹配的部分，加入一个的时候往前找，如果有就换到一块，感觉除了它没啥东西可以正确了。用BiT维护还剩多少即可。

R3

Koleje

看起来是一个斯坦呐树。两倍让我们想起tsp的近似算法，考虑用任意dfs序近似最小斯坦呐树，于是从每个关键点跑dij即可。

Gazociągi

注意到每个点的贡献是确定的。

Odważniki

先全都除掉最小的那个。考虑这个东西相当于，每个容器的容量是一个奇怪进制的数，那么从低到高尝试消掉每个容器的每位即可。也就是如果有一个容器当前这一位非零，那就去放。如果物品用完了，就看下一位，否则尝试把下一位也填满，这里优先填下一位非零的。

据说可以直接把所有的容器不进位地加起来。

Egzamin na prawo jazdy

完全没有一个方向啊。考虑每条路能到一个区间，那么能到所有路当且仅当能到第一条和最后一条。同时，第一条路能被一个前缀到达，最后一条能被一个后缀到达，所以答案是一个区间。注意到能到第一条路是贪心往右走，能到最后一条是贪心往左走，两边是独立的，所以可以分别求出加$i$条边最远可以到哪，然后卷起来。

先考虑第一条，最后一条是类似的。看起来我比较智障，可以发现跑一个lis，不在lis中的位置就是需要加边的位置，然后就结束了。

Klocki

容易想到$n^2$，设$dp(i)$表示最后一个选了并且有贡献的是第$i$个的答案，那么$i$可以转移到$j$，当且仅当$j-i\geq a_j-a_i$，也就是$a_j-j\leq a_i-i$。BiT即可。

Waga czwórkowa

感觉很困难。还是考虑数位dp，设$dp(i,j)$表示高$i$位，$i$及以上还有$j$没有消去的最小个数和方案数，这里$j$是以$i$作为第$0$位记录的。注意到如果一位选了超过$4$个，那么也一定不优，如果一位同时被两边选了，那么也一定不优。主要问题是$j$可以多大，显然它不能超过$2\log_4 n$，当然这个还是太松了，可以猜测它的绝对值不超过$2$，因为低位最多只能凑一个无限接近$1$的数。

#### XV(2007~2008)

R1

Klocki

枚举最后我们选的区间，那么肯定它们都要贴到中位数上去。对顶堆即可。

Plakatowanie

单调栈，贪心地，这看起来确实是最优的。

Cło

二分图匹配。

或者发现我们只要找到一个生成基环树森林即可，所以dfs然后随便再找一条边。

Szklana pułapka

感觉很离奇。首先由于这是光，我们只要找到从每个点出发会在哪结束。考虑不会有两个这样的过程在某一时刻状态相同，否则它们必然来自同一个起点。

洛谷上的翻译没提到周长很小。爆力找到边界上所有点，然后模拟即可。

Robinson

相当于把每个障碍物都变成中心对称的船的样子，然后船变成一个点。bfs即可。

但是这里有$2000$啊?考虑找到船的中心，然后我们希望每次都能真的把一个位置推成障碍，那么容易想到bitset，但是这里不太需要，考虑我们顺着船的方向扫，那么每个障碍是一个长度先变大再变小的区间推平，注意到投影在扫描线上同一个位置的障碍，同时只有一个在贡献，并且一个贡献结束了就不再贡献，双指针一下，然后差分-前缀和就赢了。复杂度$O(n^2)$。

R2

Blokada

建个圆方树，然后直接结束。

BBB

枚举转了多少次，然后我们会把前若干个$-1$改成$+1$，后若干个$+1$改成$-1$。现在$n\log n$是简单的。

考虑类似于某个经典题，发现其实我们所要的就是前缀和的最小值，因为它变成正的了就全都变成正的了，并且它必然可以变成正的。单调队列即可。

Pociągi

爆力hash。对每个等价类维护一个大小，一共有$O(n+m)$个等价类，一个车相当于查询了一个区间$\max$，四毛子即可。另外最好写的区间半群是并查集。

Mafia

这是一个内向基环树森林。dp，如果是树，设$dp(u,0/1)$表示$u$能/不能活到开枪的答案，转移枚举每个儿子有没有开枪，如果有儿子开枪了那么$u$就可以死。现在有一个环，钦点一个人，从他身后断开即可。

Ucieczka

感觉很厉害。考虑只能往右拐说的是啥，发现我们接下来可以干啥会受到且仅受到前两次转弯时位置的影响，于是可能的状态数是$O(n^4)$。前缀和优化，直接冲，直接过。小问题是按什么顺序枚举，按两维的差枚举就行了，类似于区间dp。

R3

Lampki

请注意颜色$k_i$只是一个说法，实际上它们是互不相同的。考虑crt，发现对于$i$，答案是$\displaystyle\frac{\prod_{j>i}(p_j-1)}{\prod_{j\geq i} p_j}$。

Kupno gruntu

容易想到$n^3$，也就是枚举一边，双指针另一边。猜测我们需要一些好性质。如果一个数$\geq k,\leq 2k$，那么可以直接选它。如果一个数$>2k$，那么不可能选它。现在每个数要么是障碍要么$<k$。考虑如果有一行的一个区间和$\geq k$，那么必然可以删一些数使得它$\leq 2k$，所以就赢了。但是答案可能不是行的区间，继续考虑这个想法，枚举$y$上的投影，我们得到若干个列的和，如果一列的和$\geq k,\leq 2k$，直接选，如果$>2k$则是障碍，那么问题是求障碍之间有没有一段的和$\geq k$。考虑固定这个投影的上端点，枚举下端点，那么我们可以知道每个位置何时变成障碍，在它变成障碍的时候分裂它所在的段。倒过来把分裂改成合并，并查集维护，复杂度$O(n^2\alpha n)$。

然后发现这个过于复杂。注意到如果一个矩形不包含$>2k$的数，并且它的总和$\geq k$，那么它的子矩形中必然有解。考虑如果有一行的和$>2k$，那么这一行一定有一个区间是解，否则一定有若干行组成一个解。单调栈求个最大权子矩形即可。

Podział królestwa

也就是求一个子集到另一个子集的边数。dp，复杂度$O(2^n)$。但是这个题卡空间，那就一边搜一边算。

具体地，也就是你要把一个点从一个集合移动到另一个集合，那么边数的变化量是简单的。为了从这个生成所有可能的状态，枚举所有$2^n$个状态，然后总共发生$O(2^n)$次切换。

Trójkąty

直接做。注意到叉积的式子是$(x_b-x_a)(y_c-y_a)-(y_b-y_a)(x_c-x_a)$，展开之后每一项只和两个点有关，不过外面还有一个绝对值，发现这个符号就是它的方向，所以就是半平面数点，枚举一个点，给剩下的排极角序扫过去即可。

Permutacja

感觉之前有场cf出过这个。如果这一位卡着，那么就卡着了，否则这一位放一个更小的，剩下的部分可以随便排，一个还有$c$次没有出现的元素的贡献是$\frac{1}{c!}$，那么所有更小的的贡献就是$\frac{1}{c!}+\frac{z}{(c-1)!}$，BiT维护前缀积即可。

膜数不是素数，crt，维护一个数的时候附带当前考虑的素数的次数即可。当要做加法的时候，必然是直接统计进答案了，所以可以直接转成整数。

Stacja

发现如果两个点只需要一张票，那么一个是另一个的祖先，那么省掉的票的总数就是每个点的深度和。直接换根dp即可。

#### XVI(2008~2009)

R1

Straż pożarna

注意到到两个点距离相等的点是一条折线，大概是这个样子 : 

![img](/img/xiv-poi-r1-a.png)

那么边上的都矩形数点数掉了，主要问题是中间那个。考虑平时我们是怎么数任意多边形的，差分成一条斜线下方的部分和一个矩形，那么斜着扫，维护每个位置下方的点数即可，BiT。

Słonie

考虑每个位置不对的数至少要参与一次交换，分开考虑每个环，对于那个转一圈的构造，一个数要参与$n-1$次交换，剩下的每个数参与一次交换。那么我们显然希望最小的那个数贡献$n-1$次。考虑也可能会换环外的，那么我们希望全局最小贡献$n$次，这个环上每个数贡献一次。每个环对这两种取个$\min$即可。

Gaśnice

考虑了网络流，但是不凸，所以只好dp，但是dp也不会处理$s$。

考虑直接贪心，我们在尽可能高的地方放一个灭火器即可，也就是一个灭火器总是可以比它匹配的子树内最深的点高$k$。需要维护所有未被覆盖的点，每次取出其中最深的，然后维护子树中的灭火器。每次让尽可能深的灭火器匹配最深的未被覆盖的点。复杂度$O(nk)$。

Kamyki

考虑其差分，发现就是staircase nim。

Przyspieszenie algorytmu

也就是每次取$p$或者取$s$，用相同的调用序列取得的值的集合也相同。取出来的都是区间，所以我们直接会了多项式复杂度。

可以猜测，把连续段缩成一个，只保留每个数第一次出现和最后一次出现之后，两个序列相同那就是相同了。但是看样例发现假了。考虑取$p$就是删到第一次出现最右的数的第一次出现，取$s$就是删到最后一次出现最左的数的最后一次出现，但是注意到删的时候可能影响别的数的第一次和最后一次出现，这就完蛋了。

注意到颜色个数很少，考虑这玩意有没有什么用，首先这限制了状态数不超过$2^{100}$。/jy

注意到取$p$和取$s$是互不影响的，除非你把区间取空了。那么也就是说非空的状态有$O(k^2)$个。记搜即可。

R2

Przechadzka Bajtusia

Konduktor

Architekci

Łyżwy

Wyspy na trójkątnej sieci

R3

Wiedźmak

Słowa 2

Słowa

Tablice

Wyspa

Kod

Poszukiwania


