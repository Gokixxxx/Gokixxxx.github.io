---
layout: post
title: AtC选㗅
subtitle: /kk
tags: 题选做 atc
---

A Way to Practice Competitive Programming里面说要做一做ARC的EF，所以就来做了（

然而放学了。明天再说。

如果将来做AGC的话也会写在这里，所以标题就叫AtC选㗅好了。

-----

ARC058E : 还真就不会做/kk

发现$$x+y+z$$小的可怜，只有$$17$$，看起来像是状压dp。

想了想怎么直接做，容易想到枚举四个端点然后背包预处理一个方案数，但是你发现这不行，因为一个序列可能有很多可行的区间。

所以需要容斥。但是这就需要钦定一堆区间然后算方案数，这太难了。

反过来做，考虑计算没有可行区间的方案数。

枚举可行区间的右端点，你发现存在以你枚举的右端点为右端点的可行区间，当且仅当这个右端点往左看，同时存在$$x+y+z,y+z,z$$三个后缀和。这启示我们把后缀和扔进状态。

设$$dp(i,S)$$表示长为$$i$$的序列，有集合$$S$$中的后缀和的方案数。注意到$$17$$以上的后缀和没有意义，所以状态数是$$O(2^{x+y+z}n)$$。转移枚举下一个选什么进行刷表，复杂度是$$O(2^{x+y+z}nv)$$。

-----

ARC058F : 神仙背包。

爆力dp就是设$$dp(i,j)$$表示用前$$i$$个串拼成长度为$$j$$的串，得到的字典序最小的串。复杂度是$$O(nk^2)$$。

考虑一件事情 : 如果$$dp(i,j_1)$$和$$dp(i,j_2)$$有不同的位，比如它们在$$l$$位前完全相同，但是$$dp(i,j_1)$$在第$$l$$位小于$$dp(i,j_2)$$，那么后面不管接上什么，$$j_1$$都比$$j_2$$优，所以$$j_2$$就是无用的。

这里有一个问题，就是如果$$dp(i,j_1)$$本身不可能转移到$$dp(n,k)$$，那么它有可能是随便拼出来的，我们要先倒着用长度跑一个可行性背包来筛去这些状态。

这个东西有什么用?它说明有用状态们一定都是最长的$$dp(i,j)$$的一个前缀。

考虑对于每个$$i$$的转移，我们维护一个长度递减的栈。每次转移完了当前的$$j$$，拿着它和栈顶也就是最长的串比较，如果栈顶是它的前缀，那么我们直接把它入栈，否则就看两个串哪个更优，如果当前串不优那就扔掉它，否则就弹掉栈顶继续检查下一个。

然后发现因为是前缀，我们可以只记录每个$$i$$最长的串，其它的都可以用长度表示。

现在只有一个问题了，怎么比较两个串。这个比较有两种

 - 转移的时候，比较一个$$dp$$加上一个$$s_i$$和一个$$dp$$

 - 弹栈的时候，比较两个$$dp$$

。当然可以二分hash!复杂度多个$$\log$$，过不去。

考虑使用Z algo，然后就$$O(nk+\vert s\vert)$$了。

然而我不会Z algo/cy

-----

ARC059E : 式子好长......

实际上这个超长式子是用来迷惑你的，真正的题意应该是对于每种兴奋度和每种分糖果方案求和。

设$$dp(i,j)$$表示前$$i$$个小朋友拿了$$j$$个糖的答案，转移枚举第$$i$$个小朋友的兴奋度和拿了多少糖，有

$$
\begin{aligned}
dp(i,j)&=\sum_{k=a_i}^{b_i}\sum_{l=0}^jk^ldp(i-1,j-l)\\
&=\sum_{l=0}^jdp(i-1,j-l)(\sum_{k=a_i}^{b_i}k^l)
\end{aligned}
$$

直接预处理后面那个括号即可，复杂度是$$O(n^3)$$。

-----

ARC059F : 字符串题?

然而不是。

首先有个奇妙想法，那就是得到任何一种字符串的方案数是相同的，所以这个$$S$$没有用，只有$$\vert S\vert$$有用。

可以先算出打出$$\vert S\vert$$长度的方案数，然后除一个$$2^{\vert S\vert}$$即可。

我们设$$dp(i,j)$$表示打了$$i$$次打出长度是$$j$$的方案数，那么有$$dp(i,j)=dp(i-1,j+1)+dp(i-1,j-1)$$，注意$$0$$处退格需要特判。复杂度$$O(n^2)$$。

AtC题还是很好玩的!

-----

ARC060E : 洛谷上D比E难?

经典题啊!倍增即可。

-----

ARC060F : 题意很麻烦。说的是，让你把一个串$$w$$划分成尽量少的段，使得每一段都不能划分成完全相同的若干段，求最小的划分段数和这样划分的方案数。

猜一个结论 : 如果$$w$$本身不能划分成完全相同的若干段，那么答案是$$1,1$$，如果$$w$$是一个字符重复若干次那么答案是$$\vert w\vert,1$$，否则是$$2$$，方案数可以正反两边kmp求出来。

草，一看题解发现对了/jk

这么猜测的原因是，如果$$1$$不是周期，那么至少需要选择所有质数周期才能ban掉所有分成两段的方案，而每次选一个质数就意味着要给串长乘上这个质数，就需要选择更多新的质数......所以是不可能ban完的。这句话是瞎写的，看不懂很正常/jk

-----

ARC061E : 非常简单，建个虚点处理中转，然后01bfs即可。

-----

ARC061F : 多 人 运 动（

首先我们把牌堆转化成序列，按照摸牌的顺序把牌们排成一排。

因为游戏结束的时候$$b,c$$可能还没有摸完，所以这个序列的长度在$$n+m+k$$以内，而不一定是$$n+m+k$$。在序列之外的牌是什么都可以。

考虑$$a$$赢说的是什么，看起来好像是这个序列中$$a$$出现的次数刚好是$$n$$，而$$b,c$$出现的次数都小于等于$$m,k$$(她们取到$$m+1,k+1$$才能赢)，并且最后一个一定是$$a$$。让$$n:=n-1$$，我们就可以去掉最后一个了。然后枚举这个长度，问题转化成

计算有多少个$$a,b,c$$组成的、长度是$$l$$的序列，满足出现了$$n$$个$$a$$，$$m$$以内个$$b$$，$$k$$以内个$$c$$。

我们用二项式系数来选所有的$$a$$，然后枚举有多少个$$b$$，此时剩下的全是$$c$$，如果这两个数量满足要求我们用二项式系数选出来。

可以写出这样的式子

$$
\binom{l}{n}\sum_{t=l-n-m}^{m}\binom{l-n}{t}
$$

当然下指标是负数的话我们认为值是$$0$$。那么我们的答案就是

$$
\sum_{l=n}^{n+m+k}3^{n+m+k-l}\binom{l}{n}\sum_{t=l-n-m}^{m}\binom{l-n}{t}
$$

直接计算复杂度是$$O(n^2)$$，考虑优化。

后面那个是一行组合数的区间和，众所周知难以直接解，但是应该可以快速递推。

设那个东西是$$f(\max(l-n-m,0),m,l-n)$$，那么问题就是如何从$$f(k-1,l-1,r)$$推到$$f(k,l,r)$$。

$$
\begin{aligned}
f(k,l,r)&=\sum_{i=l}^r\binom{k}{i}\\
&=\sum_{i=l}^r\binom{k-1}{i}+\sum_{i=l}^r\binom{k-1}{i-1}\\
&=\sum_{i=l-1}^r\binom{k-1}{i}-\binom{k-1}{l-1}+\sum_{i=l-1}^r\binom{k-1}{i}-\binom{k-1}{r}\\
&=2f(k-1,l-1,r)-\binom{k-1}{l-1}-\binom{k-1}{r}
\end{aligned}
$$

就做完了!

-----

ARC062E : hash!

枚举上下两个面，那么就能确定剩下四个面的颜色。

然后进行hash，扔进map统计即可。

-----

ARC062F : 看到这个简单环......

考虑v-DCC。容易发现每个v-DCC是独立的，可以求出方案数乘起来。

 - 如果一个v-DCC只有一条边，那么它有$$k$$种选法。

 - 如果一个v-DCC是一个环，那么它的选法可以用Polya定理计算。

 - 如果一个v-DCC是别的东西，那么任意置换都能被换出来，可以直接用隔板法选。

就做完了。

-----

ARC063E : 

这题真是太妙了。完全想不到。

考虑怎么决策才能没有后效性。

我们按照从小到大的顺序决策。

开一个堆，每次取出已经决定的点中最小的点，然后把它周围的点点权设成它的点权$$+1$$，最后检查合法性。

-----

ARC063F : 

第一步转化是，这个东西等价于求不包含特殊点的最大矩形(可以在边界上)。

分治。拿一条横线切开这个矩形。

然后我们枚举一个横线，