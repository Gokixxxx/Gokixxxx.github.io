---
layout: post
title: ARC选㗅
subtitle: /kk
tags: 题选做 atc
---

A Way to Practice Competitive Programming里面说要做一做ARC的EF，所以就来做了（

看起来058之前题目编号是ABCD，058及之后是CDEF。

-----

ARC012D : 

-----

ARC058E : 还真就不会做/kk

发现$$x+y+z$$小的可怜，只有$$17$$，看起来像是状压dp。

想了想怎么直接做，容易想到枚举四个端点然后背包预处理一个方案数，但是你发现这不行，因为一个序列可能有很多可行的区间。

所以需要容斥。但是这就需要钦定一堆区间然后算方案数，这太难了。

反过来做，考虑计算没有可行区间的方案数。

枚举可行区间的右端点，你发现存在以你枚举的右端点为右端点的可行区间，当且仅当这个右端点往左看，同时存在$$x+y+z,y+z,z$$三个后缀和。这启示我们把后缀和扔进状态。

设$$dp(i,S)$$表示长为$$i$$的序列，有集合$$S$$中的后缀和的方案数。注意到$$17$$以上的后缀和没有意义，所以状态数是$$O(2^{x+y+z}n)$$。转移枚举下一个选什么进行刷表，复杂度是$$O(2^{x+y+z}nv)$$。

-----

ARC058F : 神仙背包。

爆力dp就是设$$dp(i,j)$$表示用前$$i$$个串拼成长度为$$j$$的串，得到的字典序最小的串。复杂度是$$O(nk^2)$$。

考虑一件事情 : 如果$$dp(i,j_1)$$和$$dp(i,j_2)$$有不同的位，比如它们在$$l$$位前完全相同，但是$$dp(i,j_1)$$在第$$l$$位小于$$dp(i,j_2)$$，那么后面不管接上什么，$$j_1$$都比$$j_2$$优，所以$$j_2$$就是无用的。

这里有一个问题，就是如果$$dp(i,j_1)$$本身不可能转移到$$dp(n,k)$$，那么它有可能是随便拼出来的，我们要先倒着用长度跑一个可行性背包来筛去这些状态。

这个东西有什么用?它说明有用状态们一定都是最长的$$dp(i,j)$$的一个前缀。

考虑对于每个$$i$$的转移，我们维护一个长度递减的栈。每次转移完了当前的$$j$$，拿着它和栈顶也就是最长的串比较，如果栈顶是它的前缀，那么我们直接把它入栈，否则就看两个串哪个更优，如果当前串不优那就扔掉它，否则就弹掉栈顶继续检查下一个。

然后发现因为是前缀，我们可以只记录每个$$i$$最长的串，其它的都可以用长度表示。

现在只有一个问题了，怎么比较两个串。这个比较有两种

 - 转移的时候，比较一个$$dp$$加上一个$$s_i$$和一个$$dp$$

 - 弹栈的时候，比较两个$$dp$$

。当然可以二分hash!复杂度多个$$\log$$，过不去。

考虑使用Z algo，然后就$$O(nk+\vert s\vert)$$了。

然而我不会Z algo/cy

-----

ARC059E : 式子好长......

实际上这个超长式子是用来迷惑你的，真正的题意应该是对于每种兴奋度和每种分糖果方案求和。

设$$dp(i,j)$$表示前$$i$$个小朋友拿了$$j$$个糖的答案，转移枚举第$$i$$个小朋友的兴奋度和拿了多少糖，有

$$
\begin{aligned}
dp(i,j)&=\sum_{k=a_i}^{b_i}\sum_{l=0}^jk^ldp(i-1,j-l)\\
&=\sum_{l=0}^jdp(i-1,j-l)(\sum_{k=a_i}^{b_i}k^l)
\end{aligned}
$$

直接预处理后面那个括号即可，复杂度是$$O(n^3)$$。

-----

ARC059F : 字符串题?

然而不是。

首先有个奇妙想法，那就是得到任何一种字符串的方案数是相同的，所以这个$$S$$没有用，只有$$\vert S\vert$$有用。

可以先算出打出$$\vert S\vert$$长度的方案数，然后除一个$$2^{\vert S\vert}$$即可。

我们设$$dp(i,j)$$表示打了$$i$$次打出长度是$$j$$的方案数，那么有$$dp(i,j)=dp(i-1,j+1)+dp(i-1,j-1)$$，注意$$0$$处退格需要特判。复杂度$$O(n^2)$$。

AtC题还是很好玩的!

-----

ARC060E : 洛谷上D比E难?

经典题啊!倍增即可。

-----

ARC060F : 题意很麻烦。说的是，让你把一个串$$w$$划分成尽量少的段，使得每一段都不能划分成完全相同的若干段，求最小的划分段数和这样划分的方案数。

猜一个结论 : 如果$$w$$本身不能划分成完全相同的若干段，那么答案是$$1,1$$，如果$$w$$是一个字符重复若干次那么答案是$$\vert w\vert,1$$，否则是$$2$$，方案数可以正反两遍kmp求出来。

草，一看题解发现对了/jk

这么猜测的原因是，如果$$1$$不是周期，那么至少需要同时具有$$n$$以内所有质数周期才能ban掉所有分成两段的方案，所以$$n$$以内所有质数都应该是$$n$$的因数，而当$$n\geq 3$$的时候$$n$$以内所有质数的乘积一定比$$n$$大，所以这是不可能的。

-----

ARC061E : 非常简单，建个虚点处理中转，然后01bfs即可。

-----

ARC061F : 多 人 运 动（

首先我们把牌堆转化成序列，按照摸牌的顺序把牌们排成一排。

因为游戏结束的时候$$b,c$$可能还没有摸完，所以这个序列的长度在$$n+m+k$$以内，而不一定是$$n+m+k$$。在序列之外的牌是什么都可以。

考虑$$a$$赢说的是什么，看起来好像是这个序列中$$a$$出现的次数刚好是$$n$$，而$$b,c$$出现的次数都小于等于$$m,k$$(她们取到$$m+1,k+1$$才能赢)，并且最后一个一定是$$a$$。让$$n:=n-1$$，我们就可以去掉最后一个了。然后枚举这个长度，问题转化成

计算有多少个$$a,b,c$$组成的、长度是$$l$$的序列，满足出现了$$n$$个$$a$$，$$m$$以内个$$b$$，$$k$$以内个$$c$$。

我们用二项式系数来选所有的$$a$$，然后枚举有多少个$$b$$，此时剩下的全是$$c$$，如果这两个数量满足要求我们用二项式系数选出来。

可以写出这样的式子

$$
\binom{l}{n}\sum_{t=l-n-m}^{m}\binom{l-n}{t}
$$

当然下指标是负数的话我们认为值是$$0$$。那么我们的答案就是

$$
\sum_{l=n}^{n+m+k}3^{n+m+k-l}\binom{l}{n}\sum_{t=l-n-m}^{m}\binom{l-n}{t}
$$

直接计算复杂度是$$O(n^2)$$，考虑优化。

后面那个是一行组合数的区间和，众所周知难以直接解，但是应该可以快速递推。

设那个东西是$$f(\max(l-n-m,0),m,l-n)$$，那么问题就是如何从$$f(k-1,l-1,r)$$推到$$f(k,l,r)$$。

$$
\begin{aligned}
f(k,l,r)&=\sum_{i=l}^r\binom{k}{i}\\
&=\sum_{i=l}^r\binom{k-1}{i}+\sum_{i=l}^r\binom{k-1}{i-1}\\
&=\sum_{i=l-1}^r\binom{k-1}{i}-\binom{k-1}{l-1}+\sum_{i=l-1}^r\binom{k-1}{i}-\binom{k-1}{r}\\
&=2f(k-1,l-1,r)-\binom{k-1}{l-1}-\binom{k-1}{r}
\end{aligned}
$$

就做完了!

-----

ARC062E : hash!

枚举上下两个面，那么就能确定剩下四个面的颜色。

然后进行hash，扔进map统计即可。

-----

ARC062F : 看到这个简单环......

考虑v-DCC。容易发现每个v-DCC是独立的，可以求出方案数乘起来。

 - 如果一个v-DCC只有一条边，那么它有$$k$$种选法。

 - 如果一个v-DCC是一个环，那么它的选法可以用Polya定理计算。

 - 如果一个v-DCC是别的东西，那么任意置换都能被换出来，可以直接用隔板法选。

就做完了。

-----

ARC063E : 

这题真是太妙了。完全想不到。

考虑怎么决策才能没有后效性。

我们按照从小到大的顺序决策。

开一个堆，每次取出已经决定的点中最小的点，然后把它周围的点点权设成它的点权$$+1$$，最后检查合法性。

-----

ARC063F : 

第一步转化是，这个东西等价于求不包含特殊点的最大周长矩形(可以在边界上)。画一画好像很好理解。

分治。假设我们拿一条竖线切开这个矩形。

枚举两条横线，看它们最远延伸到哪里即可，这部分可以容易地递推出来。复杂度$$O(n^2\log n)$$。

-----

ARC064F : 

直接做的话，考虑把一个前缀移到最后去，回文串会变成两个回文串连起来，不过这样肯定会算重。

发现只有在原回文串是循环串的时候才会算重，换句话说一个 两个回文串连起来 可能被多种回文串搞出来，而这些回文串一定循环同构。

然后你发现就简简单单了，因为只有原串循环节长度是偶数的时候才会发生这种事情，并且这种事情发生的时候一定恰好是两个回文串产生冲突。

于是直接数 两个回文串连起来 就完全没有前途了，考虑这样的数法 : 

枚举一个循环节长度，计算有多少个这样的回文串，然后算贡献。

循环节长度只有$$d(n)$$种。

可以用一个dp来容易地搞定。但是这里有一个问题，就是我们的dp会算上回文串更短的情况，此时只需要简简单单差分一下就好了。

算贡献简简单单，如果最小循环节长度是$$k$$，随便考虑一下你发现可以移出$$k$$种不同的串，当然$$k$$是偶数的时候刚才我们考虑过需要除一个$$2$$。

-----

ARC065E : 

好像是说，给定点集，有两个指针，一开始指针指向$$a,b$$，$$a,b$$都在点集内，然后你每次可以把$$b$$移动到从$$a$$画的一个曼哈顿距离下的半径为$$\mathrm{dist}(a,b)$$的圆上任意一点(其实是个斜的正方形)，或者反过来。问可能指向多少不同的点对。

看起来非常复杂。要不先曼哈顿转切比雪夫?

你发现最坏情况下答案是$$\Omega(n^2)$$的，构造方法是放两排点。所以枚举点对没前途了。

考虑一个简单想法，我们从$$a,b$$中随便一个点开始dfs，每次走到切比雪夫距离意义下是一个圆的所有点，然后对于每个可能的点对，我们在先被遍历到的点处统计答案。数据结构问题是这样的 : 

 - 删除一个点

 - 查询一行/列的一个区间上点数

 - 查询一行/列的一个区间里任意一个点

然后直接开`map`套`set`即可。复杂度是一个$$\log$$。

-----

ARC065F : 

没看到$$l$$递增/cy

那么我们可以发现一个性质，每次操作之后，当前左端点到下一个左端点之前这一段就再也不能变化了。我们可以在此时确定下来这一段是什么。

考虑一个牛逼dp，既然前$$i$$次操作之后$$l_i$$到$$l_{i+1}-1$$就确定了，而$$r_i+1$$到$$n$$还没变，$$l_{i+1}$$到$$r_i$$里面只有$$0,1$$的个数有用，于是我们设$$dp(i,j)$$表示考虑前$$i$$次操作，$$l_{i+1}$$到$$r_i$$里面有$$j$$个$$1$$的方案数。

转移好像比较简单，只需要考虑这$$j$$个$$1$$里面有多少个是从$$i-1$$次操作换过来的，剩下的就是本来就在区间$$[l_i,r_i]$$里的。

式子看起来是 : 

$$
dp(i,j):=dp(i,j)+\binom{l_{i+1}-l_i}{k+s(r_{i-1}+1,r_i)-j}dp(i-1,k)
$$

。爆力转移看起来像是$$O(n^3)$$的，于是考虑优化。但是你发现这个式子太复杂了（

考虑一些奇怪的优化方法，你发现$$j$$有个上下界。

 - 上界大约是$$k+s$$，表示最多就是把所有的$$1$$塞进去

 - 下界大约是$$l_i-l_{i+1}+k+s$$，表示最少就是把所有的$$1$$尽可能往前塞

然后减一下你得到$$l_{i+1}-l_i$$，也就是说如果我们枚举顺序是$$i,k,j$$，那么对于每一个$$k$$，$$j$$在所有$$i$$上的枚举量是$$O(n)$$的。这样总复杂度就是$$O(n^2)$$。

为了省去奇怪的情况，可以先跑掉被包含的区间，然后把所有区间划分成不交的若干段，答案乘起来即可。不过看起来有更奇怪的判法?

-----

ARC066E : 

1e5/jy

考虑减号是什么意思。你可以把后面一段操作数取反。

于是自然想到从右往左dp或者贪心。你发现贪心很好维护，只需要对于后面每个位置维护一个到当前位置的和，也就是支持插入，全局加，查询$$\min$$。

然而这个贪心好像是错的/jy

看题解去/ll，完全想错了。

考虑括号只有在减号后面才有用。

考虑一个非常强的结论 : 在这个括号里面如果还有一个减号，我们可以直接把每一个减号后面所有元素都括起来，直到下一个减号或者外层括号结束。因为$$a$$是正的，这样肯定不劣。

所以你发现，我们一定是在某个减号开始加括号，一直加到最后，然后这个括号里面所有元素都按正的算。枚举从哪个减号开始，维护前面的结果和后面的和即可。

-----

ARC066F : 

如果没有修改，看起来就是简单斜率优化。具体地，选一段$$(j,i]$$的贡献是$$s_i-s_j+\frac{1}{2}(i-j)(i-j+1)$$，拆开变成$$s_i-s_j+\frac{1}{2}(i^2+i+j^2-j-2ij)$$。

考虑单点修改，修改独立的套路，我们预处理前后缀的答案，那么如果这次改了$$i$$，如果不选$$i$$就简简单单；如果强制选了$$i$$就比较复杂，不过我们至少知道强制选$$i$$得到的最优方案和$$i$$的代价无关。

爆力的话，当然是枚举$$i$$所在的段，不过这太慢了。爆力优化就是枚举一个区间，更新区间内所有的$$i$$，这个可以做到$$O(n^2)$$。

分治。我们一口气处理所有跨过中点的区间。

你发现我们可以这么做 : 枚举一个左端点，求出从它出发跨过中点的最优方案，然后更新它到中点这一段的答案，右边反过来做一遍。转移可以斜率优化成$$O(n)$$，加上分治就是$$O(n\log n)$$。

-----

ARC067E : 

看起来按组决策没有前途，我们直接按人数决策，组合数选一选就好了。

-----

ARC067F : 

$$nm$$是1e6级别，于是可能要带$$\log$$。也可能是$$n^2+m^3$$什么的?

考虑枚举一个馆子的区间，那么你一定是从左往右走过去，问题就是在哪里用你的券，这里就直接取个$$\max$$。于是抽象成了奇怪的问题 : 矩阵，对于每个行的区间，求每列在这个区间的$$\max$$再加起来的最大值，当然还要减去区间长度。

容易想到分治，但是我不会。

考虑一个决策单调性，你发现这个一堆$$\max$$加起来好像是满足四边形不等式的，但是我也不知道满足不满足，所以分治一下就搞定了，如果你想也可以SMAWK/jy

存在简单做法。考虑对于每张券分开考虑，也就是说我们对于每一列建立笛卡尔树，然后就变成大量矩形加之后一次全局$$\max$$，使用单调栈处理笛卡尔树，大力打标记即可。复杂度$$O(nm)$$。

-----

ARC068E : 

很有意思（

直接对每个数跑的话，去重很复杂，需要观察性质，不过有不用观察性质的做法。

考虑对于每个区间，求出它贡献的所有数。你发现区间$$l,r$$对$$d$$有贡献，当且仅当$$\lfloor\frac{l-1}{d}\rfloor<\lfloor\frac{r}{d}\rfloor$$，然后这个可以整除分块，区间加用差分-前缀和实现，复杂度是一个根号。

-----

ARC068F : 

suxxsfe一眼秒!

考虑这个队列最后一定是先递减再递增，然后我们会弹空一边，另一边弹了一部分。这个是充要的，主要问题在于如何去重，也就是说不同的插入序列可能得到相同的弹出序列。

考虑只有弹出序列的前$$k-1$$项有用，后面的就直接在左右选一边弹，乘上$$2^{n-k-1}$$即可，$$-1$$是因为最后一个没的选。

问题变成，从$$n$$个数里面选出$$k-1$$个构成一个序列，并且这个序列可以划分成两个单调递减序列，这等价于存在一种插入方案。

考虑一个简单dp，我们设$$dp(i,j)$$表示已经选了$$i$$个数，最小值是$$j$$的方案数。

考虑转移。不妨假设$$j$$在第一个单调递减序列$$a$$中，并设$$b$$的最小值是$$t$$。

 - 如果我们要往$$a$$中加一个数，就要求这个数比$$j$$小。

 - 如果我们要往$$b$$中加一个数，就要求这个数要是还没加的数中最大的，不然这个数再也没法加进去了。

第一种转移是容易的，考虑怎么判断第二种转移是否可行。你发现我们只需要判断是否有$$n-j+1=i$$即可。

-----

ARC069E : 

这个题看起来还有点复杂啊?

发现要做的事情不过就是把最高的一层不停往下砍，直接维护当前最高一层的高度，数据结构问题是单点激活，全局加，简简单单。

-----

ARC069F : 

经典2-SAT，二分之后就是2-SAT优化建图板子了。

-----

ARC070E : 

据说一个更强的经典题是 APIO2016 烟火表演?

$$O(nv)$$简简单单，直接dp然后单调队列优化即可。具体地，设$$dp(i,j)$$表示考虑前$$i$$行，第$$i$$行这个区间的左端点是$$j$$的最小代价。转移就是

$$
dp(i,j)=\vert l_i-j\vert+\min_{k=j-len_{i-1}}^{j+len_i}dp(i-1,k)
$$

考虑一些奇怪优化，你发现这个东西有凸性，前面加的是个凸函数，后面是$$len_i+len_{i-1}+1$$个凸函数取$$\min$$，众所周知这两个操作保持凸性，也就是说固定$$i$$的话，$$dp(i,j)$$是个凸函数。

看起来我们还需要更多性质。你发现这个凸函数必然是由若干折线拼起来的，而折线段数很可能是$$O(n)$$，所以我们可以考虑直接维护这些折线。

呃要不先考虑一下为什么是$$O(n)$$吧。那个绝对值的斜率是$$\pm 1$$，这说明$$dp_n$$的任意一点斜率不超过$$\pm n$$，而由于凸性，斜率相同的一定在一段，所以段数是$$O(n)$$的。

然后开始考虑这个转移。你发现那个取$$\min$$的时候，取到哪里是由凸性决定了的，所以最后对函数的改变就是把斜率正的部分向右平移$$len_{i-1}$$，负的部分向左平移$$len_i$$。

然后考虑如何加上$$\vert l_i-j\vert$$，你发现这个东西实在是简简单单，只需要加入一个新的拐点，两边分别打上$$\pm 1$$的标记即可。

平衡树容易维护，但是更简单的做法是对顶堆。

-----

ARC070F : 

非常经典。

-----

ARC071E : 

你发现操作是可逆的!

所以我们全换成A，然后看个数模$$3$$是否相同即可。

-----

ARC071F : 

你发现如果有两个相邻的数都不是$$1$$，就出大问题，后面全都是这两个数中的第二个了。

所以我们的序列一定是若干段的$$1$$和不是$$1$$的数交替，最后有一串不是$$1$$的数，每一部分都可以没有。

考虑一个dp，设$$dp(i)$$表示长为$$i$$的方案数，那么我们发现这个序列往后扩展是困难的，所以考虑往前扩展。

有两种决策 : 

 - 填两个不是$$1$$的数来结束后面的战斗，方案数是$$(n-1)^2$$

 - 填一个任意数和一串$$1$$，需要从后面转移，可以用后缀和优化

就做完了，复杂度$$O(n^2)$$。注意边界。

-----

ARC072E : 

直接读错题/jk

考虑前半部分走到哪是确定了的，所以我们只需要考虑改的这一步走多少，能走出一个后面走不出的距离。设$$f(i,n)$$表示用$$i$$和之后的操作，能不能走出距离$$n$$，如果我们可以快速找到一个$$f_i(n)$$的$$0$$值，那么很有可能就把这个题做完了。

在此之前，考虑我们要找什么样的$$0$$，显然我们是要找尽可能靠前的，因为如果太靠后了，不管怎么修改都走不过去(改的太大会导致操作不执行)。

考虑直接求这个最靠前的$$0$$的位置，发现可以容易地递推。设$$f(i)$$表示用$$i$$和之后的操作，不能走出来的最小距离，那么

 - 如果$$f(i+1)>\frac{d_i}{2}$$，有$$f(i)=f(i+1)+d_i$$

 - 如果$$f(i+1)<\frac{d_i}{2}$$，有$$f(i)=f(i+1)$$

。就做完了，复杂度$$O(n)$$。

背包是复杂的，但是背包可行性的极长前缀$$1$$是简单的，这在类似背包可行性的问题上同样适用。

-----

ARC072F : 

考虑最优策略的性质，我们大胆猜测只可能是每天放空或者尽可能留下。dp即可。

然后你发现这个好像会WA。

说实话水温不太好，我们定义一个 能量，说的是温度乘体积。这东西的好处是可以直接加减，坏处是倒水的时候会降低。

考虑爆力dp，设$$dp(i,j)$$表示考虑前$$i$$天，第$$i$$天结束的时候有$$j$$的水，最高的能量。转移是

$$
dp(i,j)=v_it_i+\max_{k\leq j-v_i}\frac{k-(j-v_i)}{k}dp(i-1,k)
$$

你发现一个奇妙事实，$$\frac{k-(j-v_i)}{k}$$是上凸的，上凸函数的点积还是上凸函数，所以固定$$i$$的话，$$dp(i,j)$$也是上凸的。AtC怎么这么多凸性题（

所以我们可以考虑怎么用这个优化转移。你发现那个乘法并取$$\max$$的几何意义是，从每个点向原点连线，然后如果有另一个点在这条线下面，就把它从凸壳上删去换成这条线。这个操作就是维护一个斜率的单调栈。

加法就简简单单，说的是一个平移。

于是我们可以用单调栈维护一堆向量。但是这里还有个小问题，就是那些超过$$L$$的我们不能要，这个就把单调栈换成单调队列就行了。

-----

ARC073E : 

据说就是card/jy

考虑我们钦定最大的是红色，那么我们枚举红色的最小值在哪，这个可以直接把还没确定的所有球从小到大枚举，那么比这个最小值小的就是蓝色了，剩下没确定的就是蓝色的最大值，数据结构问题是删除，增值，查询$$\max$$，开个堆即可。

需要注意一点特殊情况。

-----

ARC073F : 

这个题看起来非常经典。

容易设出一个$$O(n^2)$$状态的dp，但是状态数过多显然没救。

考虑怎么变成$$O(n)$$，你发现一定是两个棋子交替移动，我们可以以交替的位置划分阶段进行转移。

设$$dp(i)$$表示考虑前$$i$$次操作，第$$i-1$$次是A移过去了，而第$$i$$次是B。当然这个是对称的，或者说把两个人换过来结果是一样的。

转移的话我们就看B搞了多少，前一次就是A搞了，可以写出

$$
dp(i)=\min_{j<i}(dp(j)+c(j,i-1)+\vert x_i-x_{j-1}\vert)
$$

那么第一个问题是$$c$$是个什么东西，你发现它就是一个距离的区间和，所以数据结构问题是全局加，单点插入，全局$$\min$$，我们直接开个堆维护即可。

第二个问题是绝对值，你发现我们可以以$$x_{i-1}$$为下标建立两棵线段树，一棵在绝对值上取负而另一棵不，这样就可以搞定这个绝对值。

-----

