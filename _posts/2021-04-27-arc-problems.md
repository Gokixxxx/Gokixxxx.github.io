---
layout: post
title: ARC选㗅
subtitle: /kk
tags: 题选做 atc
---

A Way to Practice Competitive Programming里面说要做一做ARC的EF，所以就来做了（

看起来058之前题目编号是ABCD，058及之后是CDEF。

-----

ARC012D : 

-----

ARC058E : 还真就不会做/kk

发现$$x+y+z$$小的可怜，只有$$17$$，看起来像是状压dp。

想了想怎么直接做，容易想到枚举四个端点然后背包预处理一个方案数，但是你发现这不行，因为一个序列可能有很多可行的区间。

所以需要容斥。但是这就需要钦定一堆区间然后算方案数，这太难了。

反过来做，考虑计算没有可行区间的方案数。

枚举可行区间的右端点，你发现存在以你枚举的右端点为右端点的可行区间，当且仅当这个右端点往左看，同时存在$$x+y+z,y+z,z$$三个后缀和。这启示我们把后缀和扔进状态。

设$$dp(i,S)$$表示长为$$i$$的序列，有集合$$S$$中的后缀和的方案数。注意到$$17$$以上的后缀和没有意义，所以状态数是$$O(2^{x+y+z}n)$$。转移枚举下一个选什么进行刷表，复杂度是$$O(2^{x+y+z}nv)$$。

-----

ARC058F : 神仙背包。

爆力dp就是设$$dp(i,j)$$表示用前$$i$$个串拼成长度为$$j$$的串，得到的字典序最小的串。复杂度是$$O(nk^2)$$。

考虑一件事情 : 如果$$dp(i,j_1)$$和$$dp(i,j_2)$$有不同的位，比如它们在$$l$$位前完全相同，但是$$dp(i,j_1)$$在第$$l$$位小于$$dp(i,j_2)$$，那么后面不管接上什么，$$j_1$$都比$$j_2$$优，所以$$j_2$$就是无用的。

这里有一个问题，就是如果$$dp(i,j_1)$$本身不可能转移到$$dp(n,k)$$，那么它有可能是随便拼出来的，我们要先倒着用长度跑一个可行性背包来筛去这些状态。

这个东西有什么用?它说明有用状态们一定都是最长的$$dp(i,j)$$的一个前缀。

考虑对于每个$$i$$的转移，我们维护一个长度递减的栈。每次转移完了当前的$$j$$，拿着它和栈顶也就是最长的串比较，如果栈顶是它的前缀，那么我们直接把它入栈，否则就看两个串哪个更优，如果当前串不优那就扔掉它，否则就弹掉栈顶继续检查下一个。

然后发现因为是前缀，我们可以只记录每个$$i$$最长的串，其它的都可以用长度表示。

现在只有一个问题了，怎么比较两个串。这个比较有两种

 - 转移的时候，比较一个$$dp$$加上一个$$s_i$$和一个$$dp$$

 - 弹栈的时候，比较两个$$dp$$

。当然可以二分hash!复杂度多个$$\log$$，过不去。

考虑使用Z algo，然后就$$O(nk+\vert s\vert)$$了。

然而我不会Z algo/cy

-----

ARC059E : 式子好长......

实际上这个超长式子是用来迷惑你的，真正的题意应该是对于每种兴奋度和每种分糖果方案求和。

设$$dp(i,j)$$表示前$$i$$个小朋友拿了$$j$$个糖的答案，转移枚举第$$i$$个小朋友的兴奋度和拿了多少糖，有

$$
\begin{aligned}
dp(i,j)&=\sum_{k=a_i}^{b_i}\sum_{l=0}^jk^ldp(i-1,j-l)\\
&=\sum_{l=0}^jdp(i-1,j-l)(\sum_{k=a_i}^{b_i}k^l)
\end{aligned}
$$

直接预处理后面那个括号即可，复杂度是$$O(n^3)$$。

-----

ARC059F : 字符串题?

然而不是。

首先有个奇妙想法，那就是得到任何一种字符串的方案数是相同的，所以这个$$S$$没有用，只有$$\vert S\vert$$有用。

可以先算出打出$$\vert S\vert$$长度的方案数，然后除一个$$2^{\vert S\vert}$$即可。

我们设$$dp(i,j)$$表示打了$$i$$次打出长度是$$j$$的方案数，那么有$$dp(i,j)=dp(i-1,j+1)+dp(i-1,j-1)$$，注意$$0$$处退格需要特判。复杂度$$O(n^2)$$。

AtC题还是很好玩的!

-----

ARC060E : 洛谷上D比E难?

经典题啊!倍增即可。

-----

ARC060F : 题意很麻烦。说的是，让你把一个串$$w$$划分成尽量少的段，使得每一段都不能划分成完全相同的若干段，求最小的划分段数和这样划分的方案数。

猜一个结论 : 如果$$w$$本身不能划分成完全相同的若干段，那么答案是$$1,1$$，如果$$w$$是一个字符重复若干次那么答案是$$\vert w\vert,1$$，否则是$$2$$，方案数可以正反两遍kmp求出来。

草，一看题解发现对了/jk

这么猜测的原因是，如果$$1$$不是周期，那么至少需要同时具有$$n$$以内所有质数周期才能ban掉所有分成两段的方案，所以$$n$$以内所有质数都应该是$$n$$的因数，而当$$n\geq 3$$的时候$$n$$以内所有质数的乘积一定比$$n$$大，所以这是不可能的。

-----

ARC061E : 非常简单，建个虚点处理中转，然后01bfs即可。

-----

ARC061F : 多 人 运 动（

首先我们把牌堆转化成序列，按照摸牌的顺序把牌们排成一排。

因为游戏结束的时候$$b,c$$可能还没有摸完，所以这个序列的长度在$$n+m+k$$以内，而不一定是$$n+m+k$$。在序列之外的牌是什么都可以。

考虑$$a$$赢说的是什么，看起来好像是这个序列中$$a$$出现的次数刚好是$$n$$，而$$b,c$$出现的次数都小于等于$$m,k$$(她们取到$$m+1,k+1$$才能赢)，并且最后一个一定是$$a$$。让$$n:=n-1$$，我们就可以去掉最后一个了。然后枚举这个长度，问题转化成

计算有多少个$$a,b,c$$组成的、长度是$$l$$的序列，满足出现了$$n$$个$$a$$，$$m$$以内个$$b$$，$$k$$以内个$$c$$。

我们用二项式系数来选所有的$$a$$，然后枚举有多少个$$b$$，此时剩下的全是$$c$$，如果这两个数量满足要求我们用二项式系数选出来。

可以写出这样的式子

$$
\binom{l}{n}\sum_{t=l-n-m}^{m}\binom{l-n}{t}
$$

当然下指标是负数的话我们认为值是$$0$$。那么我们的答案就是

$$
\sum_{l=n}^{n+m+k}3^{n+m+k-l}\binom{l}{n}\sum_{t=l-n-m}^{m}\binom{l-n}{t}
$$

直接计算复杂度是$$O(n^2)$$，考虑优化。

后面那个是一行组合数的区间和，众所周知难以直接解，但是应该可以快速递推。

设那个东西是$$f(\max(l-n-m,0),m,l-n)$$，那么问题就是如何从$$f(k-1,l-1,r)$$推到$$f(k,l,r)$$。

$$
\begin{aligned}
f(k,l,r)&=\sum_{i=l}^r\binom{k}{i}\\
&=\sum_{i=l}^r\binom{k-1}{i}+\sum_{i=l}^r\binom{k-1}{i-1}\\
&=\sum_{i=l-1}^r\binom{k-1}{i}-\binom{k-1}{l-1}+\sum_{i=l-1}^r\binom{k-1}{i}-\binom{k-1}{r}\\
&=2f(k-1,l-1,r)-\binom{k-1}{l-1}-\binom{k-1}{r}
\end{aligned}
$$

就做完了!

-----

ARC062E : hash!

枚举上下两个面，那么就能确定剩下四个面的颜色。

然后进行hash，扔进map统计即可。

-----

ARC062F : 看到这个简单环......

考虑v-DCC。容易发现每个v-DCC是独立的，可以求出方案数乘起来。

 - 如果一个v-DCC只有一条边，那么它有$$k$$种选法。

 - 如果一个v-DCC是一个环，那么它的选法可以用Polya定理计算。

 - 如果一个v-DCC是别的东西，那么任意置换都能被换出来，可以直接用隔板法选。

就做完了。

-----

ARC063E : 

这题真是太妙了。完全想不到。

考虑怎么决策才能没有后效性。

我们按照从小到大的顺序决策。

开一个堆，每次取出已经决定的点中最小的点，然后把它周围的点点权设成它的点权$$+1$$，最后检查合法性。

-----

ARC063F : 

第一步转化是，这个东西等价于求不包含特殊点的最大周长矩形(可以在边界上)。画一画好像很好理解。

分治。假设我们拿一条竖线切开这个矩形。

枚举两条横线，看它们最远延伸到哪里即可，这部分可以容易地递推出来。复杂度$$O(n^2\log n)$$。

-----

ARC064F : 

直接做的话，考虑把一个前缀移到最后去，回文串会变成两个回文串连起来，不过这样肯定会算重。

发现只有在原回文串是循环串的时候才会算重，换句话说一个 两个回文串连起来 可能被多种回文串搞出来，而这些回文串一定循环同构。

然后你发现就简简单单了，因为只有原串循环节长度是偶数的时候才会发生这种事情，并且这种事情发生的时候一定恰好是两个回文串产生冲突。

于是直接数 两个回文串连起来 就完全没有前途了，考虑这样的数法 : 

枚举一个循环节长度，计算有多少个这样的回文串，然后算贡献。

循环节长度只有$$d(n)$$种。

可以用一个dp来容易地搞定。但是这里有一个问题，就是我们的dp会算上回文串更短的情况，此时只需要简简单单差分一下就好了。

算贡献简简单单，如果最小循环节长度是$$k$$，随便考虑一下你发现可以移出$$k$$种不同的串，当然$$k$$是偶数的时候刚才我们考虑过需要除一个$$2$$。

-----

ARC065E : 

好像是说，给定点集，有两个指针，一开始指针指向$$a,b$$，$$a,b$$都在点集内，然后你每次可以把$$b$$移动到从$$a$$画的一个曼哈顿距离下的半径为$$\mathrm{dist}(a,b)$$的圆上任意一点(其实是个斜的正方形)，或者反过来。问可能指向多少不同的点对。

看起来非常复杂。要不先曼哈顿转切比雪夫?

你发现最坏情况下答案是$$\Omega(n^2)$$的，构造方法是放两排点。所以枚举点对没前途了。

考虑一个简单想法，我们从$$a,b$$中随便一个点开始dfs，每次走到切比雪夫距离意义下是一个圆的所有点，然后对于每个可能的点对，我们在先被遍历到的点处统计答案。数据结构问题是这样的 : 

 - 删除一个点

 - 查询一行/列的一个区间上点数

 - 查询一行/列的一个区间里任意一个点

然后直接开`map`套`set`即可。复杂度是一个$$\log$$。

-----

ARC065F : 

没看到$$l$$递增/cy

那么我们可以发现一个性质，每次操作之后，当前左端点到下一个左端点之前这一段就再也不能变化了。我们可以在此时确定下来这一段是什么。

考虑一个牛逼dp，既然前$$i$$次操作之后$$l_i$$到$$l_{i+1}-1$$就确定了，而$$r_i+1$$到$$n$$还没变，$$l_{i+1}$$到$$r_i$$里面只有$$0,1$$的个数有用，于是我们设$$dp(i,j)$$表示考虑前$$i$$次操作，$$l_{i+1}$$到$$r_i$$里面有$$j$$个$$1$$的方案数。

转移好像比较简单，只需要考虑这$$j$$个$$1$$里面有多少个是从$$i-1$$次操作换过来的，剩下的就是本来就在区间$$[l_i,r_i]$$里的。

式子看起来是 : 

$$
dp(i,j):=dp(i,j)+\binom{l_{i+1}-l_i}{k+s(r_{i-1}+1,r_i)-j}dp(i-1,k)
$$

。爆力转移看起来像是$$O(n^3)$$的，于是考虑优化。但是你发现这个式子太复杂了（

考虑一些奇怪的优化方法，你发现$$j$$有个上下界。

 - 上界大约是$$k+s$$，表示最多就是把所有的$$1$$塞进去

 - 下界大约是$$l_i-l_{i+1}+k+s$$，表示最少就是把所有的$$1$$尽可能往前塞

然后减一下你得到$$l_{i+1}-l_i$$，也就是说如果我们枚举顺序是$$i,k,j$$，那么对于每一个$$k$$，$$j$$在所有$$i$$上的枚举量是$$O(n)$$的。这样总复杂度就是$$O(n^2)$$。

为了省去奇怪的情况，可以先跑掉被包含的区间，然后把所有区间划分成不交的若干段，答案乘起来即可。不过看起来有更奇怪的判法?

-----

ARC066E : 

1e5/jy

考虑减号是什么意思。你可以把后面一段操作数取反。

于是自然想到从右往左dp或者贪心。你发现贪心很好维护，只需要对于后面每个位置维护一个到当前位置的和，也就是支持插入，全局加，查询$$\min$$。

然而这个贪心好像是错的/jy

看题解去/ll，完全想错了。

考虑括号只有在减号后面才有用。

考虑一个非常强的结论 : 在这个括号里面如果还有一个减号，我们可以直接把每一个减号后面所有元素都括起来，直到下一个减号或者外层括号结束。因为$$a$$是正的，这样肯定不劣。

所以你发现，我们一定是在某个减号开始加括号，一直加到最后，然后这个括号里面所有元素都按正的算。枚举从哪个减号开始，维护前面的结果和后面的和即可。

-----

ARC066F : 

如果没有修改，看起来就是简单斜率优化。具体地，选一段$$(j,i]$$的贡献是$$s_i-s_j+\frac{1}{2}(i-j)(i-j+1)$$，拆开变成$$s_i-s_j+\frac{1}{2}(i^2+i+j^2-j-2ij)$$。

考虑单点修改，修改独立的套路，我们预处理前后缀的答案，那么如果这次改了$$i$$，如果不选$$i$$就简简单单；如果强制选了$$i$$就比较复杂，不过我们至少知道强制选$$i$$得到的最优方案和$$i$$的代价无关。

爆力的话，当然是枚举$$i$$所在的段，不过这太慢了。爆力优化就是枚举一个区间，更新区间内所有的$$i$$，这个可以做到$$O(n^2)$$。

分治。我们一口气处理所有跨过中点的区间。

你发现我们可以这么做 : 枚举一个左端点，求出从它出发跨过中点的最优方案，然后更新它到中点这一段的答案，右边反过来做一遍。转移可以斜率优化成$$O(n)$$，加上分治就是$$O(n\log n)$$。

-----

ARC067E : 

看起来按组决策没有前途，我们直接按人数决策，组合数选一选就好了。

-----

ARC067F : 

$$nm$$是1e6级别，于是可能要带$$\log$$。也可能是$$n^2+m^3$$什么的?

考虑枚举一个馆子的区间，那么你一定是从左往右走过去，问题就是在哪里用你的券，这里就直接取个$$\max$$。于是抽象成了奇怪的问题 : 矩阵，对于每个行的区间，求每列在这个区间的$$\max$$再加起来的最大值，当然还要减去区间长度。

容易想到分治，但是我不会。

考虑一个决策单调性，你发现这个一堆$$\max$$加起来好像是满足四边形不等式的，但是我也不知道满足不满足，所以分治一下就搞定了，如果你想也可以SMAWK/jy

存在简单做法。考虑对于每张券分开考虑，也就是说我们对于每一列建立笛卡尔树，然后就变成大量矩形加之后一次全局$$\max$$，使用单调栈处理笛卡尔树，大力打标记即可。复杂度$$O(nm)$$。

-----

ARC068E : 

很有意思（

直接对每个数跑的话，去重很复杂，需要观察性质，不过有不用观察性质的做法。

考虑对于每个区间，求出它贡献的所有数。你发现区间$$l,r$$对$$d$$有贡献，当且仅当$$\lfloor\frac{l-1}{d}\rfloor<\lfloor\frac{r}{d}\rfloor$$，然后这个可以整除分块，区间加用差分-前缀和实现，复杂度是一个根号。

-----

ARC068F : 

suxxsfe一眼秒!

考虑这个队列最后一定是先递减再递增，然后我们会弹空一边，另一边弹了一部分。这个是充要的，主要问题在于如何去重，也就是说不同的插入序列可能得到相同的弹出序列。

考虑只有弹出序列的前$$k-1$$项有用，后面的就直接在左右选一边弹，乘上$$2^{n-k-1}$$即可，$$-1$$是因为最后一个没的选。

问题变成，从$$n$$个数里面选出$$k-1$$个构成一个序列，并且这个序列可以划分成两个单调递减序列，这等价于存在一种插入方案。

考虑一个简单dp，我们设$$dp(i,j)$$表示已经选了$$i$$个数，最小值是$$j$$的方案数。

考虑转移。不妨假设$$j$$在第一个单调递减序列$$a$$中，并设$$b$$的最小值是$$t$$。

 - 如果我们要往$$a$$中加一个数，就要求这个数比$$j$$小。

 - 如果我们要往$$b$$中加一个数，就要求这个数要是还没加的数中最大的，不然这个数再也没法加进去了。

第一种转移是容易的，考虑怎么判断第二种转移是否可行。你发现我们只需要判断是否有$$n-j+1=i$$即可。

-----

ARC069E : 

这个题看起来还有点复杂啊?

发现要做的事情不过就是把最高的一层不停往下砍，直接维护当前最高一层的高度，数据结构问题是单点激活，全局加，简简单单。

-----

ARC069F : 

经典2-SAT，二分之后就是2-SAT优化建图板子了。

-----

ARC070E : 

据说一个更强的经典题是 APIO2016 烟火表演?

$$O(nv)$$简简单单，直接dp然后单调队列优化即可。具体地，设$$dp(i,j)$$表示考虑前$$i$$行，第$$i$$行这个区间的左端点是$$j$$的最小代价。转移就是

$$
dp(i,j)=\vert l_i-j\vert+\min_{k=j-len_{i-1}}^{j+len_i}dp(i-1,k)
$$

考虑一些奇怪优化，你发现这个东西有凸性，前面加的是个凸函数，后面是$$len_i+len_{i-1}+1$$个凸函数取$$\min$$，众所周知这两个操作保持凸性，也就是说固定$$i$$的话，$$dp(i,j)$$是个凸函数。

看起来我们还需要更多性质。你发现这个凸函数必然是由若干折线拼起来的，而折线段数很可能是$$O(n)$$，所以我们可以考虑直接维护这些折线。

呃要不先考虑一下为什么是$$O(n)$$吧。那个绝对值的斜率是$$\pm 1$$，这说明$$dp_n$$的任意一点斜率不超过$$\pm n$$，而由于凸性，斜率相同的一定在一段，所以段数是$$O(n)$$的。

然后开始考虑这个转移。你发现那个取$$\min$$的时候，取到哪里是由凸性决定了的，所以最后对函数的改变就是把斜率正的部分向右平移$$len_{i-1}$$，负的部分向左平移$$len_i$$。

然后考虑如何加上$$\vert l_i-j\vert$$，你发现这个东西实在是简简单单，只需要加入一个新的拐点，两边分别打上$$\pm 1$$的标记即可。

平衡树容易维护，但是更简单的做法是对顶堆。

-----

ARC070F : 

非常经典。

-----

ARC071E : 

你发现操作是可逆的!

所以我们全换成A，然后看个数模$$3$$是否相同即可。

-----

ARC071F : 

你发现如果有两个相邻的数都不是$$1$$，就出大问题，后面全都是这两个数中的第二个了。

所以我们的序列一定是若干段的$$1$$和不是$$1$$的数交替，最后有一串不是$$1$$的数，每一部分都可以没有。

考虑一个dp，设$$dp(i)$$表示长为$$i$$的方案数，那么我们发现这个序列往后扩展是困难的，所以考虑往前扩展。

有两种决策 : 

 - 填两个不是$$1$$的数来结束后面的战斗，方案数是$$(n-1)^2$$

 - 填一个任意数和一串$$1$$，需要从后面转移，可以用后缀和优化

就做完了，复杂度$$O(n^2)$$。注意边界。

-----

ARC072E : 

直接读错题/jk

考虑前半部分走到哪是确定了的，所以我们只需要考虑改的这一步走多少，能走出一个后面走不出的距离。设$$f(i,n)$$表示用$$i$$和之后的操作，能不能走出距离$$n$$，如果我们可以快速找到一个$$f_i(n)$$的$$0$$值，那么很有可能就把这个题做完了。

在此之前，考虑我们要找什么样的$$0$$，显然我们是要找尽可能靠前的，因为如果太靠后了，不管怎么修改都走不过去(改的太大会导致操作不执行)。

考虑直接求这个最靠前的$$0$$的位置，发现可以容易地递推。设$$f(i)$$表示用$$i$$和之后的操作，不能走出来的最小距离，那么

 - 如果$$f(i+1)>\frac{d_i}{2}$$，有$$f(i)=f(i+1)+d_i$$

 - 如果$$f(i+1)<\frac{d_i}{2}$$，有$$f(i)=f(i+1)$$

。就做完了，复杂度$$O(n)$$。

背包是复杂的，但是背包可行性的极长前缀$$1$$是简单的，这在类似背包可行性的问题上同样适用。

-----

ARC072F : 

考虑最优策略的性质，我们大胆猜测只可能是每天放空或者尽可能留下。dp即可。

然后你发现这个好像会WA。

说实话水温不太好，我们定义一个 能量，说的是温度乘体积。这东西的好处是可以直接加减，坏处是倒水的时候会降低。

考虑爆力dp，设$$dp(i,j)$$表示考虑前$$i$$天，第$$i$$天结束的时候有$$j$$的水，最高的能量。转移是

$$
dp(i,j)=v_it_i+\max_{k\leq j-v_i}\frac{k-(j-v_i)}{k}dp(i-1,k)
$$

你发现一个奇妙事实，$$\frac{k-(j-v_i)}{k}$$是上凸的，上凸函数的点积还是上凸函数，所以固定$$i$$的话，$$dp(i,j)$$也是上凸的。AtC怎么这么多凸性题（

所以我们可以考虑怎么用这个优化转移。你发现那个乘法并取$$\max$$的几何意义是，从每个点向原点连线，然后如果有另一个点在这条线下面，就把它从凸壳上删去换成这条线。这个操作就是维护一个斜率的单调栈。

加法就简简单单，说的是一个平移。

于是我们可以用单调栈维护一堆向量。但是这里还有个小问题，就是那些超过$$L$$的我们不能要，这个就把单调栈换成单调队列就行了。

-----

ARC073E : 

据说就是card/jy

考虑我们钦定最大的是红色，那么我们枚举红色的最小值在哪，这个可以直接把还没确定的所有球从小到大枚举，那么比这个最小值小的就是蓝色了，剩下没确定的就是蓝色的最大值，数据结构问题是删除，增值，查询$$\max$$，开个堆即可。

需要注意一点特殊情况。

-----

ARC073F : 

这个题看起来非常经典。

容易设出一个$$O(n^2)$$状态的dp，但是状态数过多显然没救。

考虑怎么变成$$O(n)$$，你发现一定是两个棋子交替移动，我们可以以交替的位置划分阶段进行转移。

设$$dp(i)$$表示考虑前$$i$$次操作，第$$i-1$$次是A移过去了，而第$$i$$次是B。当然这个是对称的，或者说把两个人换过来结果是一样的。

转移的话我们就看B搞了多少，前一次就是A搞了，可以写出

$$
dp(i)=\min_{j<i}(dp(j)+c(j,i-1)+\vert x_i-x_{j-1}\vert)
$$

那么第一个问题是$$c$$是个什么东西，你发现它就是一个距离的区间和，所以数据结构问题是全局加，单点插入，全局$$\min$$，我们直接开个堆维护即可。

第二个问题是绝对值，你发现我们可以以$$x_{i-1}$$为下标建立两棵线段树，一棵在绝对值上取负而另一棵不，这样就可以搞定这个绝对值。

-----

ARC074E : 

这个题看起来非常简单，你发现要限制颜色数，当然考虑$$pre$$，于是我们爆力把$$pre$$计入状态，可以写出$$dp(i,a,b,c)$$表示前$$i$$个，三种颜色的$$pre$$分别是$$a,b,c$$的方案数。然后你立刻发现$$i$$位置上的颜色的$$pre=i$$，所以直接砍去一维。

转移怎么做?考虑枚举下一个填什么进行刷表，这个非常自然。当然也可以枚举上一个填什么转移，不过那样复杂一些。

对于限制，我们在右端点处检查合法性即可。

-----

ARC074F : 直接最小割，注意建图需要一点点小技巧。

-----

ARC075E : 非常简单，只需要化个式子。

考虑区间平均值的限制是$$\frac{s_r-s_{l-1}}{r-(l-1)}\geq k$$，这个东西就是$$s_r-s_{l-1}\geq kr-k(l-1)$$，移项变成$$s_r-kr\geq s_{l-1}-k(l-1)$$，于是扫过去，用set维护$$s_i-ki$$即可。

-----

ARC075F : 看起来非常复杂。

考虑满足条件的$$n$$不可能超过1e19，不然翻转的时候值变化一定超过1e9(或者压根不变)。

考虑翻转这个东西怎么描述。你发现我们至少需要知道位数吧!所以先枚举一个位数。

剩下的部分可能是强力数位dp。还是再分析点性质吧。

把数都对应起来，你发现一个显然的事实 : 如果我们确定了这个数的低一半，就可以确定这个数了，因为我们给它加上$$d$$再取反就得到高一半。当然这样搞出来的数不一定合法。

考虑从两边往中间决策，这样在决策过程中就可以检查合法性。你发现我们只需要知道目前决策的两位，低位是否进位了，和高位是否收到了进位。设$$dp(i,0/1,0/1)$$表示已经考虑了前后各$$i$$位，两个进位的情况。

转移枚举当前要处理的两位分别填了什么，以及进位情况即可，复杂度是$$O(k\log^2 v)$$，其中$$k=10$$是进制。

-----

ARC076E : 

这个题看起来非常复杂。不过仔细想一想也好像非常简单，考虑只有存在两端点都在边界上的情况才可能不可行，进一步考虑发现不可行当且仅当两个 两端点都在边界上的点对 相交。然后做法就显然了，我们为了找到是否有相交，直接做括号匹配就好了。

-----

ARC076F : 

你发现这个 加椅子 是一定可以加给那些一开始没有座位的人的，所以问题其实是有多少人没有座位。

这个怎么做呢?考虑前后缀和优化建图，跑Dinic/jy

当然这个跑过去可能性不大。来点正经做法。

简单做法是模拟网络流。考虑爆力建的图，我们按照$$l$$从大到小依次增广每个人，每次尽可能选最大的椅子。

如果增广不动，需要反悔一个$$l$$更大的，讲道理我们应该反悔那个$$r$$更小的，让他去选一个还没选的尽可能小的椅子，没的反悔则直接尝试把这个插到右边。可以用堆维护人，set维护椅子。

复杂做法是Hall定理。Hall定理的一个简单扩展是，设$$k$$为最大匹配，$$n-k$$等于选一个左部点子集，它的点数减去相邻的右部点数的最大值。

考虑这个有什么用。首先你发现如果固定左部点的子集，右部点是一堆点集的并，而这里每个左部点有连边的右部点集合是一个前缀和一个后缀，这个并肯定也是一个前缀一个后缀，如果你不理解的话画个图就理解了。

如果我们确定了这个前缀和后缀，右部点的贡献已经被钦定了，只需要尽可能选连边的部分包含在这里面的左部点就好了。

考虑扫描线扫那个后缀，线段树维护到每个前缀的答案。每个右部点是两个前后缀加减，左部点是前后缀加减，要查询前缀$$\min$$，使用线段树即可。

-----

ARC077E : 

看起来好像是单谷的，然后发现它是循环的并且没有-1操作/cy

考虑每次调节的时候，$$x$$的数值不同都会造成调节次数的不同，其中在一部分是公差为$$1$$的等差数列，另一部分是不会用的也就是常数，所以相当于支持区间加公差为$$0,1$$的等差数列，最后询问整个序列的$$\min$$，用两个差分-前缀和维护即可。

-----

ARC077F : 

看起来非常复杂。

考虑怎么描述 加最少的字符变成偶串。

你发现大概就是，找一个最长的不到原串一半的真border，然后把这个真border之外的部分接一次，比如$$aba$$会变成$$abab$$。注意到保证原串是偶串，所以我们可以直接在它的一半里找最长真border，这样就减少了一点限制。

同时你发现，最后这个串的后一半没有任何意义，因为前一半长度也是不断增长的。

然后我就可以放弃这个题了/cy，这就去学border理论（不过实际上这个题跟那个没关系

硬推一下，考虑设原串为$$ss$$，$$s$$的最长真border为$$r$$，$$s$$砍掉后面的$$r$$之后得到$$t$$(实际上$$t$$就是$$s$$的最短周期)，砍掉前面的$$r$$得到$$t^\prime$$，或者说$$s=tr=rt^\prime$$。

考虑$$ss=rt^\prime tr$$操作之后就是$$rt^\prime trt^\prime t=stst=trttrt$$，这个形式还是很好看的。

继续考虑，你发现此时最长真border可能发生变化。由于$$t$$是$$s$$的周期，现在它和$$s$$拼在一起了，我们不妨对它是否是整周期讨论一下

 - 如果是整周期，新的最长真border应该是原来的border$$r$$加上一个$$t$$(因为$$t$$和$$r$$是可以接起来的)，容易发现我们再操作的时候还是会往后增加一个$$t^\prime t$$，于是接下来就是$$sttstt,stttsttt,sttttstttt,...$$，这个情况显然是容易处理的

 - 如果不是整周期，新的最长真border应该是$$t$$，再操作的时候会往后加上一个$$rttr$$，串变成$$trttr\ trttr=sts\ sts$$。

    - 接下来新的最长真border应该是$$tr=s$$，再操作的时候加上$$ttrtrt$$，串变成$$trttrtrt\ trttrtrt=stsst\ stsst$$。

    - 再接下来新的最长真border应该是$$trt=st$$，再操作的时候加上$$trtrttrttr$$，串变成$$trttrtrttrttr\ trttrtrttrttr=stsststs\ stsststs$$。

    - 你发现这是一个奇妙的过程，每个串都是前面第一个加上第二个。所以它的长度是Fib数，$$\log$$次之后就会达到1e18，可以爆力处理出来每一次操作的区间和各字符出现次数，查询时对左右端点递归到底层同时统计答案，完全覆盖的段直接加进来，复杂度是一个$$\log$$

，就做完了。

-----

ARC078E : 

考虑如果我们确定了位数，就可以直接二分出来了，具体方法就是把这个数后面接一个$$0$$来保证问的数总比答案大，这样就可以保证获得字典序大小的信息，而位数相同时字典序大小就是数值大小。

确定位数也很简单，只需要问一遍$$100...$$这样的数就行了，因为它们是字典序最小的。

-----

ARC078F : 

你以为这是一道图论题，然而$$n$$只有$$15$$/hanx

考虑答案的结构，一定是$$s,t$$之间有一条链，其它所有点到这条链都有一条割边，这个条件看起来是充要的。

考虑我们爆搜哪些点在链上，然后找到最优的方式把链串起来，这个显然可以状压dp搞定。

剩下的部分是计算其它点怎么连到链上。考虑这相当于把点划分成了若干连通块，块之间没有边，每个块保留一条到链上的边。

于是考虑一个非常爆力的状压dp，我们直接设$$dp(S,T)$$表示已经分配了$$S$$中所有点，目前考虑的块是$$T$$的答案。转移考虑是结束这一块并新建一块，还是加入一个还没考虑到的点，按照$$\mathrm{popcnt}$$从小到大处理，复杂度显然是$$O(3^nn)$$。

注意到这个$$T$$其实没有存在的必要，我们直接设$$dp(S)$$，然后枚举$$2^n-S$$的一个子集转移即可。预处理每个子集内边权的和，以及任意两个子集之间最大的边，复杂度还是$$O(3^nn)$$，但是简单的多。

-----

ARC079D/E : 

这是两个version，看起来是互逆的。D是构造而E是常规题。

D : 

首先你发现每次操作之后，总和肯定会减少$$1$$，那么考虑如果我们直接把第一个搞成$$n-1+k$$，别的全是$$n-1$$，最后是不是肯定可以了啊（

然后你发现不行，因为最后可能会操作超过$$k$$次。

那么我们换一个构造。考虑构造$$1,2,3,4,5,6,7,8,9,...,n$$，这样搞的话，你发现全都操作一遍之后会变成$$0,1,2,3,4,...,n-1$$。所以我们如果这样摆上去，最后会剩下$$k\bmod{n}$$次操作没有用，我们再把它们拍到最后那几个上就行了。

E : 

考虑我们刚才那个轮流减，实际上所有数组的操作过程都可以这么描述，有一个集合在被轮流减，有最多$$n$$个时刻会有新元素加入集合，我们只需要处理这些时刻就好了，实际上就是一个数达到集合的$$\min$$的时刻。于是我们可以记录一下当前有多少个数在集合中，$$\min$$是多少，然后不断找到剩下的中最大的，一路减过去并统计答案，最后再特殊处理一下，所以实际上排个序就做完了。我没有写过，不知道正确性（

另一个做法是你发现我们可以一口气把最大值减到$$<n$$，这不会影响答案，因为它最后总要$$<n$$的嘛。爆力做的复杂度?考虑你这是除，所以显然是$$O(n^2\log v)$$的，具体是个啥$$\log$$咱也无从得知是吧（

-----

ARC079F : 

人话题意是说，给一个外向基环树，给每个点分配一个权值，一条边两个端点权值不同，并且要求如果$$u$$的权值是$$a$$，那么对于$$0,...,a-1$$的每一个权值，$$u$$都必须连向一个具有这样权值的点。

考虑外向树怎么做，可以先把叶子全搞成$$0$$，然后直接自底向上递推，每个点是儿子的$$\mathrm{mex}$$，这是一定可行的。

考虑外向基环树怎么做，我们先这么递推一波，然后调整一下环上不满足的，或者说有些可能需要$$+1$$之类的。

你发现讨论起来太过复杂了，不过好像题解里很多人是这么做的。我们直接枚举一个点的权值，然后破环成链大力模拟。不过这个好像有点慢。

考虑因为是$$\mathrm{mex}$$，你发现要达到某个权值，要求的子树大小是指数级的，所以权值最大也是$$O(\log n)$$级别，这样枚举量就很小了。

-----

ARC080E : ???直接懒惰删除一下即可。